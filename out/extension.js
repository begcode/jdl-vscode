"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports2, module2) {
    (function() {
      var undefined2;
      var VERSION2 = "4.17.21";
      var LARGE_ARRAY_SIZE4 = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT3 = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED4 = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE2 = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG2 = 1, CLONE_FLAT_FLAG2 = 2, CLONE_SYMBOLS_FLAG3 = 4;
      var COMPARE_PARTIAL_FLAG7 = 1, COMPARE_UNORDERED_FLAG5 = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT2 = 800, HOT_SPAN2 = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY5 = 1 / 0, MAX_SAFE_INTEGER3 = 9007199254740991, MAX_INTEGER2 = 17976931348623157e292, NAN2 = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag5 = "[object Arguments]", arrayTag4 = "[object Array]", asyncTag2 = "[object AsyncFunction]", boolTag5 = "[object Boolean]", dateTag5 = "[object Date]", domExcTag = "[object DOMException]", errorTag4 = "[object Error]", funcTag4 = "[object Function]", genTag3 = "[object GeneratorFunction]", mapTag8 = "[object Map]", numberTag5 = "[object Number]", nullTag2 = "[object Null]", objectTag5 = "[object Object]", promiseTag2 = "[object Promise]", proxyTag2 = "[object Proxy]", regexpTag6 = "[object RegExp]", setTag8 = "[object Set]", stringTag6 = "[object String]", symbolTag5 = "[object Symbol]", undefinedTag2 = "[object Undefined]", weakMapTag4 = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag5 = "[object ArrayBuffer]", dataViewTag6 = "[object DataView]", float32Tag4 = "[object Float32Array]", float64Tag4 = "[object Float64Array]", int8Tag4 = "[object Int8Array]", int16Tag4 = "[object Int16Array]", int32Tag4 = "[object Int32Array]", uint8Tag4 = "[object Uint8Array]", uint8ClampedTag4 = "[object Uint8ClampedArray]", uint16Tag4 = "[object Uint16Array]", uint32Tag4 = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp2 = /^\w*$/, rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar2.source);
      var reTrimStart2 = /^\s+/;
      var reWhitespace2 = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord2 = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar2 = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags2 = /\w*$/;
      var reIsBadHex2 = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary2 = /^0b[01]+$/i;
      var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
      var reIsOctal2 = /^0o[0-7]+$/i;
      var reIsUint2 = /^(?:0|[1-9]\d*)$/;
      var reLatin2 = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange4 = "\\ud800-\\udfff", rsComboMarksRange5 = "\\u0300-\\u036f", reComboHalfMarksRange5 = "\\ufe20-\\ufe2f", rsComboSymbolsRange5 = "\\u20d0-\\u20ff", rsComboRange5 = rsComboMarksRange5 + reComboHalfMarksRange5 + rsComboSymbolsRange5, rsDingbatRange2 = "\\u2700-\\u27bf", rsLowerRange2 = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange2 = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange2 = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange2 = "\\u2000-\\u206f", rsSpaceRange2 = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange2 = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange4 = "\\ufe0e\\ufe0f", rsBreakRange2 = rsMathOpRange2 + rsNonCharRange2 + rsPunctuationRange2 + rsSpaceRange2;
      var rsApos3 = "['\u2019]", rsAstral2 = "[" + rsAstralRange4 + "]", rsBreak2 = "[" + rsBreakRange2 + "]", rsCombo4 = "[" + rsComboRange5 + "]", rsDigits2 = "\\d+", rsDingbat2 = "[" + rsDingbatRange2 + "]", rsLower2 = "[" + rsLowerRange2 + "]", rsMisc2 = "[^" + rsAstralRange4 + rsBreakRange2 + rsDigits2 + rsDingbatRange2 + rsLowerRange2 + rsUpperRange2 + "]", rsFitz3 = "\\ud83c[\\udffb-\\udfff]", rsModifier3 = "(?:" + rsCombo4 + "|" + rsFitz3 + ")", rsNonAstral3 = "[^" + rsAstralRange4 + "]", rsRegional3 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair3 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper2 = "[" + rsUpperRange2 + "]", rsZWJ4 = "\\u200d";
      var rsMiscLower2 = "(?:" + rsLower2 + "|" + rsMisc2 + ")", rsMiscUpper2 = "(?:" + rsUpper2 + "|" + rsMisc2 + ")", rsOptContrLower2 = "(?:" + rsApos3 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper2 = "(?:" + rsApos3 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod3 = rsModifier3 + "?", rsOptVar3 = "[" + rsVarRange4 + "]?", rsOptJoin3 = "(?:" + rsZWJ4 + "(?:" + [rsNonAstral3, rsRegional3, rsSurrPair3].join("|") + ")" + rsOptVar3 + reOptMod3 + ")*", rsOrdLower2 = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper2 = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq3 = rsOptVar3 + reOptMod3 + rsOptJoin3, rsEmoji2 = "(?:" + [rsDingbat2, rsRegional3, rsSurrPair3].join("|") + ")" + rsSeq3, rsSymbol2 = "(?:" + [rsNonAstral3 + rsCombo4 + "?", rsCombo4, rsRegional3, rsSurrPair3, rsAstral2].join("|") + ")";
      var reApos2 = RegExp(rsApos3, "g");
      var reComboMark2 = RegExp(rsCombo4, "g");
      var reUnicode2 = RegExp(rsFitz3 + "(?=" + rsFitz3 + ")|" + rsSymbol2 + rsSeq3, "g");
      var reUnicodeWord2 = RegExp([
        rsUpper2 + "?" + rsLower2 + "+" + rsOptContrLower2 + "(?=" + [rsBreak2, rsUpper2, "$"].join("|") + ")",
        rsMiscUpper2 + "+" + rsOptContrUpper2 + "(?=" + [rsBreak2, rsUpper2 + rsMiscLower2, "$"].join("|") + ")",
        rsUpper2 + "?" + rsMiscLower2 + "+" + rsOptContrLower2,
        rsUpper2 + "+" + rsOptContrUpper2,
        rsOrdUpper2,
        rsOrdLower2,
        rsDigits2,
        rsEmoji2
      ].join("|"), "g");
      var reHasUnicode2 = RegExp("[" + rsZWJ4 + rsAstralRange4 + rsComboRange5 + rsVarRange4 + "]");
      var reHasUnicodeWord2 = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags2 = {};
      typedArrayTags2[float32Tag4] = typedArrayTags2[float64Tag4] = typedArrayTags2[int8Tag4] = typedArrayTags2[int16Tag4] = typedArrayTags2[int32Tag4] = typedArrayTags2[uint8Tag4] = typedArrayTags2[uint8ClampedTag4] = typedArrayTags2[uint16Tag4] = typedArrayTags2[uint32Tag4] = true;
      typedArrayTags2[argsTag5] = typedArrayTags2[arrayTag4] = typedArrayTags2[arrayBufferTag5] = typedArrayTags2[boolTag5] = typedArrayTags2[dataViewTag6] = typedArrayTags2[dateTag5] = typedArrayTags2[errorTag4] = typedArrayTags2[funcTag4] = typedArrayTags2[mapTag8] = typedArrayTags2[numberTag5] = typedArrayTags2[objectTag5] = typedArrayTags2[regexpTag6] = typedArrayTags2[setTag8] = typedArrayTags2[stringTag6] = typedArrayTags2[weakMapTag4] = false;
      var cloneableTags2 = {};
      cloneableTags2[argsTag5] = cloneableTags2[arrayTag4] = cloneableTags2[arrayBufferTag5] = cloneableTags2[dataViewTag6] = cloneableTags2[boolTag5] = cloneableTags2[dateTag5] = cloneableTags2[float32Tag4] = cloneableTags2[float64Tag4] = cloneableTags2[int8Tag4] = cloneableTags2[int16Tag4] = cloneableTags2[int32Tag4] = cloneableTags2[mapTag8] = cloneableTags2[numberTag5] = cloneableTags2[objectTag5] = cloneableTags2[regexpTag6] = cloneableTags2[setTag8] = cloneableTags2[stringTag6] = cloneableTags2[symbolTag5] = cloneableTags2[uint8Tag4] = cloneableTags2[uint8ClampedTag4] = cloneableTags2[uint16Tag4] = cloneableTags2[uint32Tag4] = true;
      cloneableTags2[errorTag4] = cloneableTags2[funcTag4] = cloneableTags2[weakMapTag4] = false;
      var deburredLetters2 = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt2 = parseInt;
      var freeGlobal2 = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
      var freeExports4 = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule4 = freeExports4 && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
      var freeProcess2 = moduleExports4 && freeGlobal2.process;
      var nodeUtil2 = function() {
        try {
          var types = freeModule4 && freeModule4.require && freeModule4.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil2 && nodeUtil2.isArrayBuffer, nodeIsDate = nodeUtil2 && nodeUtil2.isDate, nodeIsMap2 = nodeUtil2 && nodeUtil2.isMap, nodeIsRegExp2 = nodeUtil2 && nodeUtil2.isRegExp, nodeIsSet2 = nodeUtil2 && nodeUtil2.isSet, nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
      function apply2(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator2(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach2(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery2(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter2(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes2(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf2(array, value, 0) > -1;
      }
      function arrayIncludesWith2(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap2(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush2(array, values2) {
        var index = -1, length = values2.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values2[index];
        }
        return array;
      }
      function arrayReduce2(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome2(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty2("length");
      function asciiToArray2(string) {
        return string.split("");
      }
      function asciiWords2(string) {
        return string.match(reAsciiWord2) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex2(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf2(array, value, fromIndex) {
        return value === value ? strictIndexOf2(array, value, fromIndex) : baseFindIndex2(array, baseIsNaN2, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN2(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN2;
      }
      function baseProperty2(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf2(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce2(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes2(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap2(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim2(string) {
        return string ? string.slice(0, trimmedEndIndex2(string) + 1).replace(reTrimStart2, "") : string;
      }
      function baseUnary2(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues2(object, props) {
        return arrayMap2(props, function(key) {
          return object[key];
        });
      }
      function cacheHas2(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf2(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf2(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter2 = basePropertyOf2(deburredLetters2);
      var escapeHtmlChar = basePropertyOf2(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue2(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode2(string) {
        return reHasUnicode2.test(string);
      }
      function hasUnicodeWord2(string) {
        return reHasUnicodeWord2.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray2(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg2(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray2(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf2(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode2(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray2(string) {
        return hasUnicode2(string) ? unicodeToArray2(string) : asciiToArray2(string);
      }
      function trimmedEndIndex2(string) {
        var index = string.length;
        while (index-- && reWhitespace2.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf2(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode2.lastIndex = 0;
        while (reUnicode2.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray2(string) {
        return string.match(reUnicode2) || [];
      }
      function unicodeWords2(string) {
        return string.match(reUnicodeWord2) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root2 : _.defaults(root2.Object(), context, _.pick(root2, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto2 = Array2.prototype, funcProto3 = Function2.prototype, objectProto21 = Object2.prototype;
        var coreJsData2 = context["__core-js_shared__"];
        var funcToString3 = funcProto3.toString;
        var hasOwnProperty18 = objectProto21.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey2 = function() {
          var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString3 = objectProto21.toString;
        var objectCtorString = funcToString3.call(Object2);
        var oldDash = root2._;
        var reIsNative2 = RegExp2(
          "^" + funcToString3.call(hasOwnProperty18).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer4 = moduleExports4 ? context.Buffer : undefined2, Symbol3 = context.Symbol, Uint8Array3 = context.Uint8Array, allocUnsafe2 = Buffer4 ? Buffer4.allocUnsafe : undefined2, getPrototype2 = overArg2(Object2.getPrototypeOf, Object2), objectCreate2 = Object2.create, propertyIsEnumerable3 = objectProto21.propertyIsEnumerable, splice2 = arrayProto2.splice, spreadableSymbol2 = Symbol3 ? Symbol3.isConcatSpreadable : undefined2, symIterator = Symbol3 ? Symbol3.iterator : undefined2, symToStringTag3 = Symbol3 ? Symbol3.toStringTag : undefined2;
        var defineProperty2 = function() {
          try {
            var func = getNative2(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols3 = Object2.getOwnPropertySymbols, nativeIsBuffer2 = Buffer4 ? Buffer4.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto2.join, nativeKeys2 = overArg2(Object2.keys, Object2), nativeMax5 = Math2.max, nativeMin = Math2.min, nativeNow2 = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto2.reverse;
        var DataView2 = getNative2(context, "DataView"), Map3 = getNative2(context, "Map"), Promise3 = getNative2(context, "Promise"), Set3 = getNative2(context, "Set"), WeakMap2 = getNative2(context, "WeakMap"), nativeCreate2 = getNative2(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString2 = toSource2(DataView2), mapCtorString2 = toSource2(Map3), promiseCtorString2 = toSource2(Promise3), setCtorString2 = toSource2(Set3), weakMapCtorString2 = toSource2(WeakMap2);
        var symbolProto4 = Symbol3 ? Symbol3.prototype : undefined2, symbolValueOf3 = symbolProto4 ? symbolProto4.valueOf : undefined2, symbolToString2 = symbolProto4 ? symbolProto4.toString : undefined2;
        function lodash(value) {
          if (isObjectLike2(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty18.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate2 = /* @__PURE__ */ function() {
          function object() {
          }
          return function(proto) {
            if (!isObject2(proto)) {
              return {};
            }
            if (objectCreate2) {
              return objectCreate2(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate2(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray2(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray2(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray2(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate2(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash2(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear2() {
          this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
          this.size = 0;
        }
        function hashDelete2(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet2(key) {
          var data = this.__data__;
          if (nativeCreate2) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED4 ? undefined2 : result2;
          }
          return hasOwnProperty18.call(data, key) ? data[key] : undefined2;
        }
        function hashHas2(key) {
          var data = this.__data__;
          return nativeCreate2 ? data[key] !== undefined2 : hasOwnProperty18.call(data, key);
        }
        function hashSet2(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate2 && value === undefined2 ? HASH_UNDEFINED4 : value;
          return this;
        }
        Hash2.prototype.clear = hashClear2;
        Hash2.prototype["delete"] = hashDelete2;
        Hash2.prototype.get = hashGet2;
        Hash2.prototype.has = hashHas2;
        Hash2.prototype.set = hashSet2;
        function ListCache2(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear2() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete2(key) {
          var data = this.__data__, index = assocIndexOf2(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice2.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet2(key) {
          var data = this.__data__, index = assocIndexOf2(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas2(key) {
          return assocIndexOf2(this.__data__, key) > -1;
        }
        function listCacheSet2(key, value) {
          var data = this.__data__, index = assocIndexOf2(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache2.prototype.clear = listCacheClear2;
        ListCache2.prototype["delete"] = listCacheDelete2;
        ListCache2.prototype.get = listCacheGet2;
        ListCache2.prototype.has = listCacheHas2;
        ListCache2.prototype.set = listCacheSet2;
        function MapCache2(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear2() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash2(),
            "map": new (Map3 || ListCache2)(),
            "string": new Hash2()
          };
        }
        function mapCacheDelete2(key) {
          var result2 = getMapData2(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet2(key) {
          return getMapData2(this, key).get(key);
        }
        function mapCacheHas2(key) {
          return getMapData2(this, key).has(key);
        }
        function mapCacheSet2(key, value) {
          var data = getMapData2(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache2.prototype.clear = mapCacheClear2;
        MapCache2.prototype["delete"] = mapCacheDelete2;
        MapCache2.prototype.get = mapCacheGet2;
        MapCache2.prototype.has = mapCacheHas2;
        MapCache2.prototype.set = mapCacheSet2;
        function SetCache2(values3) {
          var index = -1, length = values3 == null ? 0 : values3.length;
          this.__data__ = new MapCache2();
          while (++index < length) {
            this.add(values3[index]);
          }
        }
        function setCacheAdd2(value) {
          this.__data__.set(value, HASH_UNDEFINED4);
          return this;
        }
        function setCacheHas2(value) {
          return this.__data__.has(value);
        }
        SetCache2.prototype.add = SetCache2.prototype.push = setCacheAdd2;
        SetCache2.prototype.has = setCacheHas2;
        function Stack2(entries) {
          var data = this.__data__ = new ListCache2(entries);
          this.size = data.size;
        }
        function stackClear2() {
          this.__data__ = new ListCache2();
          this.size = 0;
        }
        function stackDelete2(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet2(key) {
          return this.__data__.get(key);
        }
        function stackHas2(key) {
          return this.__data__.has(key);
        }
        function stackSet2(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache2) {
            var pairs = data.__data__;
            if (!Map3 || pairs.length < LARGE_ARRAY_SIZE4 - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache2(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack2.prototype.clear = stackClear2;
        Stack2.prototype["delete"] = stackDelete2;
        Stack2.prototype.get = stackGet2;
        Stack2.prototype.has = stackHas2;
        Stack2.prototype.set = stackSet2;
        function arrayLikeKeys2(value, inherited) {
          var isArr = isArray2(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes2(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty18.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex2(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray2(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray2(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq2(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue2(object, key, value);
          }
        }
        function assignValue2(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty18.call(object, key) && eq2(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue2(object, key, value);
          }
        }
        function assocIndexOf2(array, key) {
          var length = array.length;
          while (length--) {
            if (eq2(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator2(collection, setter, iteratee2, accumulator) {
          baseEach2(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign2(object, source) {
          return object && copyObject2(source, keys2(source), object);
        }
        function baseAssignIn2(object, source) {
          return object && copyObject2(source, keysIn2(source), object);
        }
        function baseAssignValue2(object, key, value) {
          if (key == "__proto__" && defineProperty2) {
            defineProperty2(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get4(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone2(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG2, isFlat = bitmask & CLONE_FLAT_FLAG2, isFull = bitmask & CLONE_SYMBOLS_FLAG3;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject2(value)) {
            return value;
          }
          var isArr = isArray2(value);
          if (isArr) {
            result2 = initCloneArray2(value);
            if (!isDeep) {
              return copyArray2(value, result2);
            }
          } else {
            var tag = getTag2(value), isFunc = tag == funcTag4 || tag == genTag3;
            if (isBuffer2(value)) {
              return cloneBuffer2(value, isDeep);
            }
            if (tag == objectTag5 || tag == argsTag5 || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject2(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn2(value, baseAssignIn2(result2, value)) : copySymbols2(value, baseAssign2(result2, value));
              }
            } else {
              if (!cloneableTags2[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag2(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack2());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet2(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone2(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap2(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone2(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn2 : getAllKeys2 : isFlat ? keysIn2 : keys2;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach2(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue2(result2, key2, baseClone2(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys2(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT3);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference2(array, values3, iteratee2, comparator) {
          var index = -1, includes3 = arrayIncludes2, isCommon = true, length = array.length, result2 = [], valuesLength = values3.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values3 = arrayMap2(values3, baseUnary2(iteratee2));
          }
          if (comparator) {
            includes3 = arrayIncludesWith2;
            isCommon = false;
          } else if (values3.length >= LARGE_ARRAY_SIZE4) {
            includes3 = cacheHas2;
            isCommon = false;
            values3 = new SetCache2(values3);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values3[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes3(values3, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach2 = createBaseEach2(baseForOwn2);
        var baseEachRight = createBaseEach2(baseForOwnRight, true);
        function baseEvery2(collection, predicate) {
          var result2 = true;
          baseEach2(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol2(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger2(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger2(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter2(collection, predicate) {
          var result2 = [];
          baseEach2(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten2(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable2);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten2(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush2(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor2 = createBaseFor2();
        var baseForRight = createBaseFor2(true);
        function baseForOwn2(object, iteratee2) {
          return object && baseFor2(object, iteratee2, keys2);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys2);
        }
        function baseFunctions(object, props) {
          return arrayFilter2(props, function(key) {
            return isFunction2(object[key]);
          });
        }
        function baseGet2(object, path4) {
          path4 = castPath2(path4, object);
          var index = 0, length = path4.length;
          while (object != null && index < length) {
            object = object[toKey2(path4[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys2(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray2(object) ? result2 : arrayPush2(result2, symbolsFunc(object));
        }
        function baseGetTag2(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag2 : nullTag2;
          }
          return symToStringTag3 && symToStringTag3 in Object2(value) ? getRawTag2(value) : objectToString2(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas2(object, key) {
          return object != null && hasOwnProperty18.call(object, key);
        }
        function baseHasIn2(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax5(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes3 = comparator ? arrayIncludesWith2 : arrayIncludes2, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap2(array, baseUnary2(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache2(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas2(seen, computed) : includes3(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas2(cache, computed) : includes3(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn2(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path4, args) {
          path4 = castPath2(path4, object);
          object = parent(object, path4);
          var func = object == null ? object : object[toKey2(last2(path4))];
          return func == null ? undefined2 : apply2(func, object, args);
        }
        function baseIsArguments2(value) {
          return isObjectLike2(value) && baseGetTag2(value) == argsTag5;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike2(value) && baseGetTag2(value) == arrayBufferTag5;
        }
        function baseIsDate(value) {
          return isObjectLike2(value) && baseGetTag2(value) == dateTag5;
        }
        function baseIsEqual2(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep2(value, other, bitmask, customizer, baseIsEqual2, stack);
        }
        function baseIsEqualDeep2(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag4 : getTag2(object), othTag = othIsArr ? arrayTag4 : getTag2(other);
          objTag = objTag == argsTag5 ? objectTag5 : objTag;
          othTag = othTag == argsTag5 ? objectTag5 : othTag;
          var objIsObj = objTag == objectTag5, othIsObj = othTag == objectTag5, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer2(object)) {
            if (!isBuffer2(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack2());
            return objIsArr || isTypedArray2(object) ? equalArrays2(object, other, bitmask, customizer, equalFunc, stack) : equalByTag2(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG7)) {
            var objIsWrapped = objIsObj && hasOwnProperty18.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty18.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack2());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack2());
          return equalObjects2(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap2(value) {
          return isObjectLike2(value) && getTag2(value) == mapTag8;
        }
        function baseIsMatch2(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack2();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG7 | COMPARE_UNORDERED_FLAG5, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative2(value) {
          if (!isObject2(value) || isMasked2(value)) {
            return false;
          }
          var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
          return pattern.test(toSource2(value));
        }
        function baseIsRegExp2(value) {
          return isObjectLike2(value) && baseGetTag2(value) == regexpTag6;
        }
        function baseIsSet2(value) {
          return isObjectLike2(value) && getTag2(value) == setTag8;
        }
        function baseIsTypedArray2(value) {
          return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags2[baseGetTag2(value)];
        }
        function baseIteratee2(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity2;
          }
          if (typeof value == "object") {
            return isArray2(value) ? baseMatchesProperty2(value[0], value[1]) : baseMatches2(value);
          }
          return property2(value);
        }
        function baseKeys2(object) {
          if (!isPrototype2(object)) {
            return nativeKeys2(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty18.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn2(object) {
          if (!isObject2(object)) {
            return nativeKeysIn2(object);
          }
          var isProto = isPrototype2(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty18.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap2(collection, iteratee2) {
          var index = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
          baseEach2(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches2(source) {
          var matchData = getMatchData2(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable2(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch2(object, source, matchData);
          };
        }
        function baseMatchesProperty2(path4, srcValue) {
          if (isKey2(path4) && isStrictComparable2(srcValue)) {
            return matchesStrictComparable2(toKey2(path4), srcValue);
          }
          return function(object) {
            var objValue = get4(object, path4);
            return objValue === undefined2 && objValue === srcValue ? hasIn2(object, path4) : baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG7 | COMPARE_UNORDERED_FLAG5);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor2(source, function(srcValue, key) {
            stack || (stack = new Stack2());
            if (isObject2(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn2);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray2(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject2(objValue)) {
                newValue = copyArray2(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer2(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray2(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments2(srcValue)) {
              newValue = objValue;
              if (isArguments2(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject2(objValue) || isFunction2(objValue)) {
                newValue = initCloneObject2(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex2(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap2(iteratees, function(iteratee2) {
              if (isArray2(iteratee2)) {
                return function(value) {
                  return baseGet2(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity2];
          }
          var index = -1;
          iteratees = arrayMap2(iteratees, baseUnary2(getIteratee()));
          var result2 = baseMap2(collection, function(value, key, collection2) {
            var criteria = arrayMap2(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy2(object, paths, function(value, path4) {
            return hasIn2(object, path4);
          });
        }
        function basePickBy2(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path4 = paths[index], value = baseGet2(object, path4);
            if (predicate(value, path4)) {
              baseSet2(result2, castPath2(path4, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep2(path4) {
          return function(object) {
            return baseGet2(object, path4);
          };
        }
        function basePullAll(array, values3, iteratee2, comparator) {
          var indexOf3 = comparator ? baseIndexOfWith : baseIndexOf2, index = -1, length = values3.length, seen = array;
          if (array === values3) {
            values3 = copyArray2(values3);
          }
          if (iteratee2) {
            seen = arrayMap2(array, baseUnary2(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values3[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf3(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice2.call(seen, fromIndex, 1);
              }
              splice2.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex2(index)) {
                splice2.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax5(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER3) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest2(func, start) {
          return setToString2(overRest2(func, start, identity2), func + "");
        }
        function baseSample(collection) {
          return arraySample(values2(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values2(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet2(object, path4, value, customizer) {
          if (!isObject2(object)) {
            return object;
          }
          path4 = castPath2(path4, object);
          var index = -1, length = path4.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey2(path4[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject2(objValue) ? objValue : isIndex2(path4[index + 1]) ? [] : {};
              }
            }
            assignValue2(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity2 : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString2 = !defineProperty2 ? identity2 : function(func, string) {
          return defineProperty2(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant2(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values2(collection));
        }
        function baseSlice2(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome2(collection, predicate) {
          var result2;
          baseEach2(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol2(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity2, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol2(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq2(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol2(value)) {
            return NAN2;
          }
          return +value;
        }
        function baseToString2(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray2(value)) {
            return arrayMap2(value, baseToString2) + "";
          }
          if (isSymbol2(value)) {
            return symbolToString2 ? symbolToString2.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY5 ? "-0" : result2;
        }
        function baseUniq2(array, iteratee2, comparator) {
          var index = -1, includes3 = arrayIncludes2, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes3 = arrayIncludesWith2;
          } else if (length >= LARGE_ARRAY_SIZE4) {
            var set2 = iteratee2 ? null : createSet2(array);
            if (set2) {
              return setToArray2(set2);
            }
            isCommon = false;
            includes3 = cacheHas2;
            seen = new SetCache2();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes3(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path4) {
          path4 = castPath2(path4, object);
          object = parent(object, path4);
          return object == null || delete object[toKey2(last2(path4))];
        }
        function baseUpdate(object, path4, updater, customizer) {
          return baseSet2(object, path4, updater(baseGet2(object, path4)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice2(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice2(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce2(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush2([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq2(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference2(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq2(baseFlatten2(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values3, assignFunc) {
          var index = -1, length = props.length, valsLength = values3.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values3[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject2(value) ? value : [];
        }
        function castFunction2(value) {
          return typeof value == "function" ? value : identity2;
        }
        function castPath2(value, object) {
          if (isArray2(value)) {
            return value;
          }
          return isKey2(value, object) ? [value] : stringToPath2(toString2(value));
        }
        var castRest = baseRest2;
        function castSlice2(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice2(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root2.clearTimeout(id);
        };
        function cloneBuffer2(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe2 ? allocUnsafe2(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer2(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array3(result2).set(new Uint8Array3(arrayBuffer));
          return result2;
        }
        function cloneDataView2(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer2(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp2(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags2.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol2(symbol) {
          return symbolValueOf3 ? Object2(symbolValueOf3.call(symbol)) : {};
        }
        function cloneTypedArray2(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer2(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax5(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax5(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray2(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject2(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue2(object, key, newValue);
            } else {
              assignValue2(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols2(source, object) {
          return copyObject2(source, getSymbols2(source), object);
        }
        function copySymbolsIn2(source, object) {
          return copyObject2(source, getSymbolsIn2(source), object);
        }
        function createAggregator2(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray2(collection) ? arrayAggregator2 : baseAggregator2, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner2(assigner) {
          return baseRest2(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach2(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike2(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor2(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst2(methodName) {
          return function(string) {
            string = toString2(string);
            var strSymbols = hasUnicode2(string) ? stringToArray2(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice2(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder2(callback) {
          return function(string) {
            return arrayReduce2(words2(deburr2(string).replace(reApos2, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate2(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject2(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            return apply2(fn, this, args);
          }
          return wrapper;
        }
        function createFind2(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike2(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys2(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT3);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray2(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root2 && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString2(value);
                other = baseToString2(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap2(iteratees, baseUnary2(getIteratee()));
            return baseRest2(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply2(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString2(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode2(chars) ? castSlice2(stringToArray2(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply2(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall2(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite2(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite2(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite2(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber2(value);
              other = toNumber2(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber2(number);
            precision = precision == null ? 0 : nativeMin(toInteger2(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString2(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet2 = !(Set3 && 1 / setToArray2(new Set3([, -0]))[1] == INFINITY5) ? noop2 : function(values3) {
          return new Set3(values3);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag2(object);
            if (tag == mapTag8) {
              return mapToArray2(object);
            }
            if (tag == setTag8) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT3);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax5(toInteger2(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger2(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax5(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq2(objValue, objectProto21[key]) && !hasOwnProperty18.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject2(objValue) && isObject2(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays2(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG7, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG5 ? new SetCache2() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome2(other, function(othValue2, othIndex) {
                if (!cacheHas2(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag2(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag6:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag5:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array3(object), new Uint8Array3(other))) {
                return false;
              }
              return true;
            case boolTag5:
            case dateTag5:
            case numberTag5:
              return eq2(+object, +other);
            case errorTag4:
              return object.name == other.name && object.message == other.message;
            case regexpTag6:
            case stringTag6:
              return object == other + "";
            case mapTag8:
              var convert8 = mapToArray2;
            case setTag8:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG7;
              convert8 || (convert8 = setToArray2);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG5;
              stack.set(object, other);
              var result2 = equalArrays2(convert8(object), convert8(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag5:
              if (symbolValueOf3) {
                return symbolValueOf3.call(object) == symbolValueOf3.call(other);
              }
          }
          return false;
        }
        function equalObjects2(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG7, objProps = getAllKeys2(object), objLength = objProps.length, othProps = getAllKeys2(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty18.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString2(overRest2(func, undefined2, flatten2), func + "");
        }
        function getAllKeys2(object) {
          return baseGetAllKeys2(object, keys2, getSymbols2);
        }
        function getAllKeysIn2(object) {
          return baseGetAllKeys2(object, keysIn2, getSymbolsIn2);
        }
        var getData = !metaMap ? noop2 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty18.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty18.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee2 : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData2(map3, key) {
          var data = map3.__data__;
          return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData2(object) {
          var result2 = keys2(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable2(value)];
          }
          return result2;
        }
        function getNative2(object, key) {
          var value = getValue2(object, key);
          return baseIsNative2(value) ? value : undefined2;
        }
        function getRawTag2(value) {
          var isOwn = hasOwnProperty18.call(value, symToStringTag3), tag = value[symToStringTag3];
          try {
            value[symToStringTag3] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString3.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag3] = tag;
            } else {
              delete value[symToStringTag3];
            }
          }
          return result2;
        }
        var getSymbols2 = !nativeGetSymbols3 ? stubArray2 : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter2(nativeGetSymbols3(object), function(symbol) {
            return propertyIsEnumerable3.call(object, symbol);
          });
        };
        var getSymbolsIn2 = !nativeGetSymbols3 ? stubArray2 : function(object) {
          var result2 = [];
          while (object) {
            arrayPush2(result2, getSymbols2(object));
            object = getPrototype2(object);
          }
          return result2;
        };
        var getTag2 = baseGetTag2;
        if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag6 || Map3 && getTag2(new Map3()) != mapTag8 || Promise3 && getTag2(Promise3.resolve()) != promiseTag2 || Set3 && getTag2(new Set3()) != setTag8 || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag4) {
          getTag2 = function(value) {
            var result2 = baseGetTag2(value), Ctor = result2 == objectTag5 ? value.constructor : undefined2, ctorString = Ctor ? toSource2(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString2:
                  return dataViewTag6;
                case mapCtorString2:
                  return mapTag8;
                case promiseCtorString2:
                  return promiseTag2;
                case setCtorString2:
                  return setTag8;
                case weakMapCtorString2:
                  return weakMapTag4;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax5(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath2(object, path4, hasFunc) {
          path4 = castPath2(path4, object);
          var index = -1, length = path4.length, result2 = false;
          while (++index < length) {
            var key = toKey2(path4[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength2(length) && isIndex2(key, length) && (isArray2(object) || isArguments2(object));
        }
        function initCloneArray2(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty18.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject2(object) {
          return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate2(getPrototype2(object)) : {};
        }
        function initCloneByTag2(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag5:
              return cloneArrayBuffer2(object);
            case boolTag5:
            case dateTag5:
              return new Ctor(+object);
            case dataViewTag6:
              return cloneDataView2(object, isDeep);
            case float32Tag4:
            case float64Tag4:
            case int8Tag4:
            case int16Tag4:
            case int32Tag4:
            case uint8Tag4:
            case uint8ClampedTag4:
            case uint16Tag4:
            case uint32Tag4:
              return cloneTypedArray2(object, isDeep);
            case mapTag8:
              return new Ctor();
            case numberTag5:
            case stringTag6:
              return new Ctor(object);
            case regexpTag6:
              return cloneRegExp2(object);
            case setTag8:
              return new Ctor();
            case symbolTag5:
              return cloneSymbol2(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable2(value) {
          return isArray2(value) || isArguments2(value) || !!(spreadableSymbol2 && value && value[spreadableSymbol2]);
        }
        function isIndex2(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER3 : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall2(value, index, object) {
          if (!isObject2(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike2(object) && isIndex2(index, object.length) : type == "string" && index in object) {
            return eq2(object[index], value);
          }
          return false;
        }
        function isKey2(value, object) {
          if (isArray2(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
            return true;
          }
          return reIsPlainProp2.test(value) || !reIsDeepProp2.test(value) || object != null && value in Object2(object);
        }
        function isKeyable2(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked2(func) {
          return !!maskSrcKey2 && maskSrcKey2 in func;
        }
        var isMaskable = coreJsData2 ? isFunction2 : stubFalse2;
        function isPrototype2(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto21;
          return value === proto;
        }
        function isStrictComparable2(value) {
          return value === value && !isObject2(value);
        }
        function matchesStrictComparable2(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped2(func) {
          var result2 = memoize2(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE2) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn2(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString2(value) {
          return nativeObjectToString3.call(value);
        }
        function overRest2(func, start, transform2) {
          start = nativeMax5(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax5(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply2(func, this, otherArgs);
          };
        }
        function parent(object, path4) {
          return path4.length < 2 ? object : baseGet2(object, baseSlice2(path4, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray2(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex2(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut2(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root2.setTimeout(func, wait);
        };
        var setToString2 = shortOut2(baseSetToString2);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString2(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut2(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow2(), remaining = HOT_SPAN2 - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT2) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath2 = memoizeCapped2(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName2, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar2, "$1") : number || match);
          });
          return result2;
        });
        function toKey2(value) {
          if (typeof value == "string" || isSymbol2(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY5 ? "-0" : result2;
        }
        function toSource2(func) {
          if (func != null) {
            try {
              return funcToString3.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach2(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes2(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray2(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall2(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax5(toInteger2(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice2(array, index, index += size2);
          }
          return result2;
        }
        function compact2(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush2(isArray2(array) ? copyArray2(array) : [array], baseFlatten2(args, 1));
        }
        var difference2 = baseRest2(function(array, values3) {
          return isArrayLikeObject2(array) ? baseDifference2(array, baseFlatten2(values3, 1, isArrayLikeObject2, true)) : [];
        });
        var differenceBy = baseRest2(function(array, values3) {
          var iteratee2 = last2(values3);
          if (isArrayLikeObject2(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject2(array) ? baseDifference2(array, baseFlatten2(values3, 1, isArrayLikeObject2, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest2(function(array, values3) {
          var comparator = last2(values3);
          if (isArrayLikeObject2(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject2(array) ? baseDifference2(array, baseFlatten2(values3, 1, isArrayLikeObject2, true), undefined2, comparator) : [];
        });
        function drop2(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger2(n);
          return baseSlice2(array, n < 0 ? 0 : n, length);
        }
        function dropRight2(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger2(n);
          n = length - n;
          return baseSlice2(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall2(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex2(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger2(fromIndex);
          if (index < 0) {
            index = nativeMax5(length + index, 0);
          }
          return baseFindIndex2(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger2(fromIndex);
            index = fromIndex < 0 ? nativeMax5(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex2(array, getIteratee(predicate, 3), index, true);
        }
        function flatten2(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten2(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten2(array, INFINITY5) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger2(depth);
          return baseFlatten2(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head2(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf2(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger2(fromIndex);
          if (index < 0) {
            index = nativeMax5(length + index, 0);
          }
          return baseIndexOf2(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice2(array, 0, -1) : [];
        }
        var intersection = baseRest2(function(arrays) {
          var mapped = arrayMap2(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest2(function(arrays) {
          var iteratee2 = last2(arrays), mapped = arrayMap2(arrays, castArrayLikeObject);
          if (iteratee2 === last2(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest2(function(arrays) {
          var comparator = last2(arrays), mapped = arrayMap2(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join2(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last2(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger2(fromIndex);
            index = index < 0 ? nativeMax5(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex2(array, baseIsNaN2, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger2(n)) : undefined2;
        }
        var pull = baseRest2(pullAll);
        function pullAll(array, values3) {
          return array && array.length && values3 && values3.length ? basePullAll(array, values3) : array;
        }
        function pullAllBy(array, values3, iteratee2) {
          return array && array.length && values3 && values3.length ? basePullAll(array, values3, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values3, comparator) {
          return array && array.length && values3 && values3.length ? basePullAll(array, values3, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap2(indexes, function(index) {
            return isIndex2(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall2(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger2(start);
            end = end === undefined2 ? length : toInteger2(end);
          }
          return baseSlice2(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq2(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq2(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice2(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger2(n);
          return baseSlice2(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger2(n);
          n = length - n;
          return baseSlice2(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest2(function(arrays) {
          return baseUniq2(baseFlatten2(arrays, 1, isArrayLikeObject2, true));
        });
        var unionBy = baseRest2(function(arrays) {
          var iteratee2 = last2(arrays);
          if (isArrayLikeObject2(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq2(baseFlatten2(arrays, 1, isArrayLikeObject2, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest2(function(arrays) {
          var comparator = last2(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq2(baseFlatten2(arrays, 1, isArrayLikeObject2, true), undefined2, comparator);
        });
        function uniq2(array) {
          return array && array.length ? baseUniq2(array) : [];
        }
        function uniqBy2(array, iteratee2) {
          return array && array.length ? baseUniq2(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq2(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter2(array, function(group) {
            if (isArrayLikeObject2(group)) {
              length = nativeMax5(group.length, length);
              return true;
            }
          });
          return baseTimes2(length, function(index) {
            return arrayMap2(array, baseProperty2(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap2(result2, function(group) {
            return apply2(iteratee2, undefined2, group);
          });
        }
        var without = baseRest2(function(array, values3) {
          return isArrayLikeObject2(array) ? baseDifference2(array, values3) : [];
        });
        var xor = baseRest2(function(arrays) {
          return baseXor(arrayFilter2(arrays, isArrayLikeObject2));
        });
        var xorBy = baseRest2(function(arrays) {
          var iteratee2 = last2(arrays);
          if (isArrayLikeObject2(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter2(arrays, isArrayLikeObject2), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest2(function(arrays) {
          var comparator = last2(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter2(arrays, isArrayLikeObject2), undefined2, comparator);
        });
        var zip = baseRest2(unzip);
        function zipObject(props, values3) {
          return baseZipObject(props || [], values3 || [], assignValue2);
        }
        function zipObjectDeep(props, values3) {
          return baseZipObject(props || [], values3 || [], baseSet2);
        }
        var zipWith = baseRest2(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex2(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone3 = wrapperClone(parent2);
            clone3.__index__ = 0;
            clone3.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone3;
            } else {
              result2 = clone3;
            }
            var previous = clone3;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator2(function(result2, value, key) {
          if (hasOwnProperty18.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue2(result2, key, 1);
          }
        });
        function every2(collection, predicate, guard) {
          var func = isArray2(collection) ? arrayEvery2 : baseEvery2;
          if (guard && isIterateeCall2(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter2(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter2 : baseFilter2;
          return func(collection, getIteratee(predicate, 3));
        }
        var find2 = createFind2(findIndex2);
        var findLast = createFind2(findLastIndex);
        function flatMap2(collection, iteratee2) {
          return baseFlatten2(map2(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten2(map2(collection, iteratee2), INFINITY5);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger2(depth);
          return baseFlatten2(map2(collection, iteratee2), depth);
        }
        function forEach3(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEach2 : baseEach2;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy2 = createAggregator2(function(result2, value, key) {
          if (hasOwnProperty18.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue2(result2, key, [value]);
          }
        });
        function includes2(collection, value, fromIndex, guard) {
          collection = isArrayLike2(collection) ? collection : values2(collection);
          fromIndex = fromIndex && !guard ? toInteger2(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax5(length + fromIndex, 0);
          }
          return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf2(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest2(function(collection, path4, args) {
          var index = -1, isFunc = typeof path4 == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
          baseEach2(collection, function(value) {
            result2[++index] = isFunc ? apply2(path4, value, args) : baseInvoke(value, path4, args);
          });
          return result2;
        });
        var keyBy = createAggregator2(function(result2, value, key) {
          baseAssignValue2(result2, key, value);
        });
        function map2(collection, iteratee2) {
          var func = isArray2(collection) ? arrayMap2 : baseMap2;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray2(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray2(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator2(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce2(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduce2 : baseReduce2, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach2);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduceRight : baseReduce2, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject2(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter2 : baseFilter2;
          return func(collection, negate2(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray2(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall2(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger2(n);
          }
          var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray2(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike2(collection)) {
            return isString2(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag2(collection);
          if (tag == mapTag8 || tag == setTag8) {
            return collection.size;
          }
          return baseKeys2(collection).length;
        }
        function some2(collection, predicate, guard) {
          var func = isArray2(collection) ? arraySome2 : baseSome2;
          if (guard && isIterateeCall2(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest2(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall2(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall2(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten2(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root2.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT3);
          }
          n = toInteger2(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT3);
          }
          n = toInteger2(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest2(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest2(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT3);
          }
          wait = toNumber2(wait) || 0;
          if (isObject2(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax5(toNumber2(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest2(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest2(function(func, wait, args) {
          return baseDelay(func, toNumber2(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize2(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT3);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize2.Cache || MapCache2)();
          return memoized;
        }
        memoize2.Cache = MapCache2;
        function negate2(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT3);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap2(transforms[0], baseUnary2(getIteratee())) : arrayMap2(baseFlatten2(transforms, 1), baseUnary2(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest2(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply2(func, this, args);
          });
        });
        var partial = baseRest2(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest2(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT3);
          }
          start = start === undefined2 ? start : toInteger2(start);
          return baseRest2(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT3);
          }
          start = start == null ? 0 : nativeMax5(toInteger2(start), 0);
          return baseRest2(function(args) {
            var array = args[start], otherArgs = castSlice2(args, 0, start);
            if (array) {
              arrayPush2(otherArgs, array);
            }
            return apply2(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT3);
          }
          if (isObject2(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction2(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray2(value) ? value : [value];
        }
        function clone2(value) {
          return baseClone2(value, CLONE_SYMBOLS_FLAG3);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone2(value, CLONE_SYMBOLS_FLAG3, customizer);
        }
        function cloneDeep(value) {
          return baseClone2(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG3);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone2(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG3, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys2(source));
        }
        function eq2(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments2 = baseIsArguments2(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments2 : function(value) {
          return isObjectLike2(value) && hasOwnProperty18.call(value, "callee") && !propertyIsEnumerable3.call(value, "callee");
        };
        var isArray2 = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary2(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike2(value) {
          return value != null && isLength2(value.length) && !isFunction2(value);
        }
        function isArrayLikeObject2(value) {
          return isObjectLike2(value) && isArrayLike2(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike2(value) && baseGetTag2(value) == boolTag5;
        }
        var isBuffer2 = nativeIsBuffer2 || stubFalse2;
        var isDate = nodeIsDate ? baseUnary2(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike2(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty2(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray2(value) || isArguments2(value))) {
            return !value.length;
          }
          var tag = getTag2(value);
          if (tag == mapTag8 || tag == setTag8) {
            return !value.size;
          }
          if (isPrototype2(value)) {
            return !baseKeys2(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty18.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual2(value, other) {
          return baseIsEqual2(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual2(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike2(value)) {
            return false;
          }
          var tag = baseGetTag2(value);
          return tag == errorTag4 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction2(value) {
          if (!isObject2(value)) {
            return false;
          }
          var tag = baseGetTag2(value);
          return tag == funcTag4 || tag == genTag3 || tag == asyncTag2 || tag == proxyTag2;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger2(value);
        }
        function isLength2(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER3;
        }
        function isObject2(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike2(value) {
          return value != null && typeof value == "object";
        }
        var isMap2 = nodeIsMap2 ? baseUnary2(nodeIsMap2) : baseIsMap2;
        function isMatch(object, source) {
          return object === source || baseIsMatch2(object, source, getMatchData2(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch2(object, source, getMatchData2(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative2(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike2(value) && baseGetTag2(value) == numberTag5;
        }
        function isPlainObject(value) {
          if (!isObjectLike2(value) || baseGetTag2(value) != objectTag5) {
            return false;
          }
          var proto = getPrototype2(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty18.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
        }
        var isRegExp2 = nodeIsRegExp2 ? baseUnary2(nodeIsRegExp2) : baseIsRegExp2;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER3 && value <= MAX_SAFE_INTEGER3;
        }
        var isSet2 = nodeIsSet2 ? baseUnary2(nodeIsSet2) : baseIsSet2;
        function isString2(value) {
          return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag2(value) == stringTag6;
        }
        function isSymbol2(value) {
          return typeof value == "symbol" || isObjectLike2(value) && baseGetTag2(value) == symbolTag5;
        }
        var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
        function isUndefined2(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike2(value) && getTag2(value) == weakMapTag4;
        }
        function isWeakSet(value) {
          return isObjectLike2(value) && baseGetTag2(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike2(value)) {
            return isString2(value) ? stringToArray2(value) : copyArray2(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag2(value), func = tag == mapTag8 ? mapToArray2 : tag == setTag8 ? setToArray2 : values2;
          return func(value);
        }
        function toFinite2(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber2(value);
          if (value === INFINITY5 || value === -INFINITY5) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER2;
          }
          return value === value ? value : 0;
        }
        function toInteger2(value) {
          var result2 = toFinite2(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger2(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber2(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol2(value)) {
            return NAN2;
          }
          if (isObject2(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject2(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim2(value);
          var isBinary = reIsBinary2.test(value);
          return isBinary || reIsOctal2.test(value) ? freeParseInt2(value.slice(2), isBinary ? 2 : 8) : reIsBadHex2.test(value) ? NAN2 : +value;
        }
        function toPlainObject(value) {
          return copyObject2(value, keysIn2(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger2(value), -MAX_SAFE_INTEGER3, MAX_SAFE_INTEGER3) : value === 0 ? value : 0;
        }
        function toString2(value) {
          return value == null ? "" : baseToString2(value);
        }
        var assign2 = createAssigner2(function(object, source) {
          if (isPrototype2(source) || isArrayLike2(source)) {
            copyObject2(source, keys2(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty18.call(source, key)) {
              assignValue2(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner2(function(object, source) {
          copyObject2(source, keysIn2(source), object);
        });
        var assignInWith = createAssigner2(function(object, source, srcIndex, customizer) {
          copyObject2(source, keysIn2(source), object, customizer);
        });
        var assignWith = createAssigner2(function(object, source, srcIndex, customizer) {
          copyObject2(source, keys2(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate2(prototype);
          return properties == null ? result2 : baseAssign2(result2, properties);
        }
        var defaults10 = baseRest2(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn2(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq2(value, objectProto21[key]) && !hasOwnProperty18.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest2(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply2(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn2);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor2(object, getIteratee(iteratee2, 3), keysIn2);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn2);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn2(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys2(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn2(object));
        }
        function get4(object, path4, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet2(object, path4);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has2(object, path4) {
          return object != null && hasPath2(object, path4, baseHas2);
        }
        function hasIn2(object, path4) {
          return object != null && hasPath2(object, path4, baseHasIn2);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString3.call(value);
          }
          result2[value] = key;
        }, constant2(identity2));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString3.call(value);
          }
          if (hasOwnProperty18.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest2(baseInvoke);
        function keys2(object) {
          return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys2(object);
        }
        function keysIn2(object) {
          return isArrayLike2(object) ? arrayLikeKeys2(object, true) : baseKeysIn2(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn2(object, function(value, key, object2) {
            baseAssignValue2(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn2(object, function(value, key, object2) {
            baseAssignValue2(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge2 = createAssigner2(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner2(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap2(paths, function(path4) {
            path4 = castPath2(path4, object);
            isDeep || (isDeep = path4.length > 1);
            return path4;
          });
          copyObject2(object, getAllKeysIn2(object), result2);
          if (isDeep) {
            result2 = baseClone2(result2, CLONE_DEEP_FLAG2 | CLONE_FLAT_FLAG2 | CLONE_SYMBOLS_FLAG3, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy2(object, negate2(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy2(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap2(getAllKeysIn2(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy2(object, props, function(value, path4) {
            return predicate(value, path4[0]);
          });
        }
        function result(object, path4, defaultValue) {
          path4 = castPath2(path4, object);
          var index = -1, length = path4.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey2(path4[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction2(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path4, value) {
          return object == null ? object : baseSet2(object, path4, value);
        }
        function setWith(object, path4, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet2(object, path4, value, customizer);
        }
        var toPairs = createToPairs(keys2);
        var toPairsIn = createToPairs(keysIn2);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray2(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject2(object)) {
              accumulator = isFunction2(Ctor) ? baseCreate2(getPrototype2(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach2 : baseForOwn2)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path4) {
          return object == null ? true : baseUnset(object, path4);
        }
        function update(object, path4, updater) {
          return object == null ? object : baseUpdate(object, path4, castFunction2(updater));
        }
        function updateWith(object, path4, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path4, castFunction2(updater), customizer);
        }
        function values2(object) {
          return object == null ? [] : baseValues2(object, keys2(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues2(object, keysIn2(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber2(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber2(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber2(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite2(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite2(end);
          }
          number = toNumber2(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall2(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite2(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite2(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase3 = createCompounder2(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize2(word) : word);
        });
        function capitalize2(string) {
          return upperFirst5(toString2(string).toLowerCase());
        }
        function deburr2(string) {
          string = toString2(string);
          return string && string.replace(reLatin2, deburrLetter2).replace(reComboMark2, "");
        }
        function endsWith(string, target, position) {
          string = toString2(string);
          target = baseToString2(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger2(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString2(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString2(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar2, "\\$&") : string;
        }
        var kebabCase2 = createCompounder2(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder2(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst3 = createCaseFirst2("toLowerCase");
        function pad(string, length, chars) {
          string = toString2(string);
          length = toInteger2(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString2(string);
          length = toInteger2(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString2(string);
          length = toInteger2(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString2(string).replace(reTrimStart2, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall2(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger2(n);
          }
          return baseRepeat(toString2(string), n);
        }
        function replace() {
          var args = arguments, string = toString2(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase2 = createCompounder2(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall2(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString2(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
            separator = baseToString2(separator);
            if (!separator && hasUnicode2(string)) {
              return castSlice2(stringToArray2(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder2(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst5(word);
        });
        function startsWith(string, target, position) {
          string = toString2(string);
          position = position == null ? 0 : baseClamp(toInteger2(position), 0, string.length);
          target = baseToString2(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall2(string, options, guard)) {
            options = undefined2;
          }
          string = toString2(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues2(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty18.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty18.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString2(value).toLowerCase();
        }
        function toUpper(value) {
          return toString2(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString2(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim2(string);
          }
          if (!string || !(chars = baseToString2(chars))) {
            return string;
          }
          var strSymbols = stringToArray2(string), chrSymbols = stringToArray2(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice2(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString2(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex2(string) + 1);
          }
          if (!string || !(chars = baseToString2(chars))) {
            return string;
          }
          var strSymbols = stringToArray2(string), end = charsEndIndex(strSymbols, stringToArray2(chars)) + 1;
          return castSlice2(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString2(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart2, "");
          }
          if (!string || !(chars = baseToString2(chars))) {
            return string;
          }
          var strSymbols = stringToArray2(string), start = charsStartIndex(strSymbols, stringToArray2(chars));
          return castSlice2(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject2(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger2(options.length) : length;
            omission = "omission" in options ? baseToString2(options.omission) : omission;
          }
          string = toString2(string);
          var strLength = string.length;
          if (hasUnicode2(string)) {
            var strSymbols = stringToArray2(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice2(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp2(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString2(reFlags2.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString2(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString2(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase2 = createCompounder2(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst5 = createCaseFirst2("toUpperCase");
        function words2(string, pattern, guard) {
          string = toString2(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord2(string) ? unicodeWords2(string) : asciiWords2(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest2(function(func, args) {
          try {
            return apply2(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach2(methodNames, function(key) {
            key = toKey2(key);
            baseAssignValue2(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap2(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT3);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest2(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply2(pair[0], this, args)) {
                return apply2(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone2(source, CLONE_DEEP_FLAG2));
        }
        function constant2(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity2(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee2(typeof func == "function" ? func : baseClone2(func, CLONE_DEEP_FLAG2));
        }
        function matches(source) {
          return baseMatches2(baseClone2(source, CLONE_DEEP_FLAG2));
        }
        function matchesProperty(path4, srcValue) {
          return baseMatchesProperty2(path4, baseClone2(srcValue, CLONE_DEEP_FLAG2));
        }
        var method = baseRest2(function(path4, args) {
          return function(object) {
            return baseInvoke(object, path4, args);
          };
        });
        var methodOf = baseRest2(function(object, args) {
          return function(path4) {
            return baseInvoke(object, path4, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys2(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys2(source));
          }
          var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
          arrayEach2(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray2(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush2([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root2._ === this) {
            root2._ = oldDash;
          }
          return this;
        }
        function noop2() {
        }
        function nthArg(n) {
          n = toInteger2(n);
          return baseRest2(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap2);
        var overEvery = createOver(arrayEvery2);
        var overSome = createOver(arraySome2);
        function property2(path4) {
          return isKey2(path4) ? baseProperty2(toKey2(path4)) : basePropertyDeep2(path4);
        }
        function propertyOf(object) {
          return function(path4) {
            return object == null ? undefined2 : baseGet2(object, path4);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray2() {
          return [];
        }
        function stubFalse2() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger2(n);
          if (n < 1 || n > MAX_SAFE_INTEGER3) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes2(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray2(value)) {
            return arrayMap2(value, toKey2);
          }
          return isSymbol2(value) ? [value] : copyArray2(stringToPath2(toString2(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString2(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity2);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity2) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign2;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact2;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant2;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults10;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference2;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop2;
        lodash.dropRight = dropRight2;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter2;
        lodash.flatMap = flatMap2;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten2;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy2;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys2;
        lodash.keysIn = keysIn2;
        lodash.map = map2;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize2;
        lodash.merge = merge2;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate2;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy2;
        lodash.property = property2;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject2;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq2;
        lodash.uniqBy = uniqBy2;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values2;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words2;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase3;
        lodash.capitalize = capitalize2;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone2;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr2;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq2;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every2;
        lodash.find = find2;
        lodash.findIndex = findIndex2;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach3;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get4;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has2;
        lodash.hasIn = hasIn2;
        lodash.head = head2;
        lodash.identity = identity2;
        lodash.includes = includes2;
        lodash.indexOf = indexOf2;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments2;
        lodash.isArray = isArray2;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike2;
        lodash.isArrayLikeObject = isArrayLikeObject2;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer2;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty2;
        lodash.isEqual = isEqual2;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction2;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength2;
        lodash.isMap = isMap2;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject2;
        lodash.isObjectLike = isObjectLike2;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp2;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet2;
        lodash.isString = isString2;
        lodash.isSymbol = isSymbol2;
        lodash.isTypedArray = isTypedArray2;
        lodash.isUndefined = isUndefined2;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join2;
        lodash.kebabCase = kebabCase2;
        lodash.last = last2;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst3;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray2;
        lodash.stubFalse = stubFalse2;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop2;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce2;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase2;
        lodash.some = some2;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite2;
        lodash.toInteger = toInteger2;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber2;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString2;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase2;
        lodash.upperFirst = upperFirst5;
        lodash.each = forEach3;
        lodash.eachRight = forEachRight;
        lodash.first = head2;
        mixin(lodash, function() {
          var source = {};
          baseForOwn2(lodash, function(func, methodName) {
            if (!hasOwnProperty18.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION2;
        arrayEach2(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach2(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax5(toInteger2(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach2(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach2(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach2(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity2);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest2(function(path4, args) {
          if (typeof path4 == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path4, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate2(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger2(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger2(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn2(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush2([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach2(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto2[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray2(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray2(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn2(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty18.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root2._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule4) {
        (freeModule4.exports = _)._ = _;
        freeExports4._ = _;
      } else {
        root2._ = _;
      }
    }).call(exports2);
  }
});

// node_modules/lodash-es/_freeGlobal.js
var freeGlobal, freeGlobal_default;
var init_freeGlobal = __esm({
  "node_modules/lodash-es/_freeGlobal.js"() {
    freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    freeGlobal_default = freeGlobal;
  }
});

// node_modules/lodash-es/_root.js
var freeSelf, root, root_default;
var init_root = __esm({
  "node_modules/lodash-es/_root.js"() {
    init_freeGlobal();
    freeSelf = typeof self == "object" && self && self.Object === Object && self;
    root = freeGlobal_default || freeSelf || Function("return this")();
    root_default = root;
  }
});

// node_modules/lodash-es/_Symbol.js
var Symbol2, Symbol_default;
var init_Symbol = __esm({
  "node_modules/lodash-es/_Symbol.js"() {
    init_root();
    Symbol2 = root_default.Symbol;
    Symbol_default = Symbol2;
  }
});

// node_modules/lodash-es/_getRawTag.js
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var objectProto, hasOwnProperty, nativeObjectToString, symToStringTag, getRawTag_default;
var init_getRawTag = __esm({
  "node_modules/lodash-es/_getRawTag.js"() {
    init_Symbol();
    objectProto = Object.prototype;
    hasOwnProperty = objectProto.hasOwnProperty;
    nativeObjectToString = objectProto.toString;
    symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
    getRawTag_default = getRawTag;
  }
});

// node_modules/lodash-es/_objectToString.js
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectProto2, nativeObjectToString2, objectToString_default;
var init_objectToString = __esm({
  "node_modules/lodash-es/_objectToString.js"() {
    objectProto2 = Object.prototype;
    nativeObjectToString2 = objectProto2.toString;
    objectToString_default = objectToString;
  }
});

// node_modules/lodash-es/_baseGetTag.js
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var nullTag, undefinedTag, symToStringTag2, baseGetTag_default;
var init_baseGetTag = __esm({
  "node_modules/lodash-es/_baseGetTag.js"() {
    init_Symbol();
    init_getRawTag();
    init_objectToString();
    nullTag = "[object Null]";
    undefinedTag = "[object Undefined]";
    symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
    baseGetTag_default = baseGetTag;
  }
});

// node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default;
var init_isObjectLike = __esm({
  "node_modules/lodash-es/isObjectLike.js"() {
    isObjectLike_default = isObjectLike;
  }
});

// node_modules/lodash-es/isSymbol.js
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var symbolTag, isSymbol_default;
var init_isSymbol = __esm({
  "node_modules/lodash-es/isSymbol.js"() {
    init_baseGetTag();
    init_isObjectLike();
    symbolTag = "[object Symbol]";
    isSymbol_default = isSymbol;
  }
});

// node_modules/lodash-es/_arrayMap.js
function arrayMap(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var arrayMap_default;
var init_arrayMap = __esm({
  "node_modules/lodash-es/_arrayMap.js"() {
    arrayMap_default = arrayMap;
  }
});

// node_modules/lodash-es/isArray.js
var isArray, isArray_default;
var init_isArray = __esm({
  "node_modules/lodash-es/isArray.js"() {
    isArray = Array.isArray;
    isArray_default = isArray;
  }
});

// node_modules/lodash-es/_baseToString.js
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var INFINITY, symbolProto, symbolToString, baseToString_default;
var init_baseToString = __esm({
  "node_modules/lodash-es/_baseToString.js"() {
    init_Symbol();
    init_arrayMap();
    init_isArray();
    init_isSymbol();
    INFINITY = 1 / 0;
    symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
    symbolToString = symbolProto ? symbolProto.toString : void 0;
    baseToString_default = baseToString;
  }
});

// node_modules/lodash-es/_trimmedEndIndex.js
function trimmedEndIndex(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
var reWhitespace, trimmedEndIndex_default;
var init_trimmedEndIndex = __esm({
  "node_modules/lodash-es/_trimmedEndIndex.js"() {
    reWhitespace = /\s/;
    trimmedEndIndex_default = trimmedEndIndex;
  }
});

// node_modules/lodash-es/_baseTrim.js
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex_default(string) + 1).replace(reTrimStart, "") : string;
}
var reTrimStart, baseTrim_default;
var init_baseTrim = __esm({
  "node_modules/lodash-es/_baseTrim.js"() {
    init_trimmedEndIndex();
    reTrimStart = /^\s+/;
    baseTrim_default = baseTrim;
  }
});

// node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default;
var init_isObject = __esm({
  "node_modules/lodash-es/isObject.js"() {
    isObject_default = isObject;
  }
});

// node_modules/lodash-es/toNumber.js
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN;
  }
  if (isObject_default(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject_default(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim_default(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var NAN, reIsBadHex, reIsBinary, reIsOctal, freeParseInt, toNumber_default;
var init_toNumber = __esm({
  "node_modules/lodash-es/toNumber.js"() {
    init_baseTrim();
    init_isObject();
    init_isSymbol();
    NAN = 0 / 0;
    reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    reIsBinary = /^0b[01]+$/i;
    reIsOctal = /^0o[0-7]+$/i;
    freeParseInt = parseInt;
    toNumber_default = toNumber;
  }
});

// node_modules/lodash-es/toFinite.js
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber_default(value);
  if (value === INFINITY2 || value === -INFINITY2) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var INFINITY2, MAX_INTEGER, toFinite_default;
var init_toFinite = __esm({
  "node_modules/lodash-es/toFinite.js"() {
    init_toNumber();
    INFINITY2 = 1 / 0;
    MAX_INTEGER = 17976931348623157e292;
    toFinite_default = toFinite;
  }
});

// node_modules/lodash-es/toInteger.js
function toInteger(value) {
  var result = toFinite_default(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_default;
var init_toInteger = __esm({
  "node_modules/lodash-es/toInteger.js"() {
    init_toFinite();
    toInteger_default = toInteger;
  }
});

// node_modules/lodash-es/identity.js
function identity(value) {
  return value;
}
var identity_default;
var init_identity = __esm({
  "node_modules/lodash-es/identity.js"() {
    identity_default = identity;
  }
});

// node_modules/lodash-es/isFunction.js
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var asyncTag, funcTag, genTag, proxyTag, isFunction_default;
var init_isFunction = __esm({
  "node_modules/lodash-es/isFunction.js"() {
    init_baseGetTag();
    init_isObject();
    asyncTag = "[object AsyncFunction]";
    funcTag = "[object Function]";
    genTag = "[object GeneratorFunction]";
    proxyTag = "[object Proxy]";
    isFunction_default = isFunction;
  }
});

// node_modules/lodash-es/_coreJsData.js
var coreJsData, coreJsData_default;
var init_coreJsData = __esm({
  "node_modules/lodash-es/_coreJsData.js"() {
    init_root();
    coreJsData = root_default["__core-js_shared__"];
    coreJsData_default = coreJsData;
  }
});

// node_modules/lodash-es/_isMasked.js
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var maskSrcKey, isMasked_default;
var init_isMasked = __esm({
  "node_modules/lodash-es/_isMasked.js"() {
    init_coreJsData();
    maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    isMasked_default = isMasked;
  }
});

// node_modules/lodash-es/_toSource.js
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var funcProto, funcToString, toSource_default;
var init_toSource = __esm({
  "node_modules/lodash-es/_toSource.js"() {
    funcProto = Function.prototype;
    funcToString = funcProto.toString;
    toSource_default = toSource;
  }
});

// node_modules/lodash-es/_baseIsNative.js
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var reRegExpChar, reIsHostCtor, funcProto2, objectProto3, funcToString2, hasOwnProperty2, reIsNative, baseIsNative_default;
var init_baseIsNative = __esm({
  "node_modules/lodash-es/_baseIsNative.js"() {
    init_isFunction();
    init_isMasked();
    init_isObject();
    init_toSource();
    reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    reIsHostCtor = /^\[object .+?Constructor\]$/;
    funcProto2 = Function.prototype;
    objectProto3 = Object.prototype;
    funcToString2 = funcProto2.toString;
    hasOwnProperty2 = objectProto3.hasOwnProperty;
    reIsNative = RegExp(
      "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    baseIsNative_default = baseIsNative;
  }
});

// node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default;
var init_getValue = __esm({
  "node_modules/lodash-es/_getValue.js"() {
    getValue_default = getValue;
  }
});

// node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default;
var init_getNative = __esm({
  "node_modules/lodash-es/_getNative.js"() {
    init_baseIsNative();
    init_getValue();
    getNative_default = getNative;
  }
});

// node_modules/lodash-es/_WeakMap.js
var WeakMap, WeakMap_default;
var init_WeakMap = __esm({
  "node_modules/lodash-es/_WeakMap.js"() {
    init_getNative();
    init_root();
    WeakMap = getNative_default(root_default, "WeakMap");
    WeakMap_default = WeakMap;
  }
});

// node_modules/lodash-es/_baseCreate.js
var objectCreate, baseCreate, baseCreate_default;
var init_baseCreate = __esm({
  "node_modules/lodash-es/_baseCreate.js"() {
    init_isObject();
    objectCreate = Object.create;
    baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      return function(proto) {
        if (!isObject_default(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    baseCreate_default = baseCreate;
  }
});

// node_modules/lodash-es/_apply.js
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var apply_default;
var init_apply = __esm({
  "node_modules/lodash-es/_apply.js"() {
    apply_default = apply;
  }
});

// node_modules/lodash-es/noop.js
function noop() {
}
var noop_default;
var init_noop = __esm({
  "node_modules/lodash-es/noop.js"() {
    noop_default = noop;
  }
});

// node_modules/lodash-es/_copyArray.js
function copyArray(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var copyArray_default;
var init_copyArray = __esm({
  "node_modules/lodash-es/_copyArray.js"() {
    copyArray_default = copyArray;
  }
});

// node_modules/lodash-es/_shortOut.js
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var HOT_COUNT, HOT_SPAN, nativeNow, shortOut_default;
var init_shortOut = __esm({
  "node_modules/lodash-es/_shortOut.js"() {
    HOT_COUNT = 800;
    HOT_SPAN = 16;
    nativeNow = Date.now;
    shortOut_default = shortOut;
  }
});

// node_modules/lodash-es/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var constant_default;
var init_constant = __esm({
  "node_modules/lodash-es/constant.js"() {
    constant_default = constant;
  }
});

// node_modules/lodash-es/_defineProperty.js
var defineProperty, defineProperty_default;
var init_defineProperty = __esm({
  "node_modules/lodash-es/_defineProperty.js"() {
    init_getNative();
    defineProperty = function() {
      try {
        var func = getNative_default(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    defineProperty_default = defineProperty;
  }
});

// node_modules/lodash-es/_baseSetToString.js
var baseSetToString, baseSetToString_default;
var init_baseSetToString = __esm({
  "node_modules/lodash-es/_baseSetToString.js"() {
    init_constant();
    init_defineProperty();
    init_identity();
    baseSetToString = !defineProperty_default ? identity_default : function(func, string) {
      return defineProperty_default(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant_default(string),
        "writable": true
      });
    };
    baseSetToString_default = baseSetToString;
  }
});

// node_modules/lodash-es/_setToString.js
var setToString, setToString_default;
var init_setToString = __esm({
  "node_modules/lodash-es/_setToString.js"() {
    init_baseSetToString();
    init_shortOut();
    setToString = shortOut_default(baseSetToString_default);
    setToString_default = setToString;
  }
});

// node_modules/lodash-es/_arrayEach.js
function arrayEach(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var arrayEach_default;
var init_arrayEach = __esm({
  "node_modules/lodash-es/_arrayEach.js"() {
    arrayEach_default = arrayEach;
  }
});

// node_modules/lodash-es/_baseFindIndex.js
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}
var baseFindIndex_default;
var init_baseFindIndex = __esm({
  "node_modules/lodash-es/_baseFindIndex.js"() {
    baseFindIndex_default = baseFindIndex;
  }
});

// node_modules/lodash-es/_baseIsNaN.js
function baseIsNaN(value) {
  return value !== value;
}
var baseIsNaN_default;
var init_baseIsNaN = __esm({
  "node_modules/lodash-es/_baseIsNaN.js"() {
    baseIsNaN_default = baseIsNaN;
  }
});

// node_modules/lodash-es/_strictIndexOf.js
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1, length = array.length;
  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}
var strictIndexOf_default;
var init_strictIndexOf = __esm({
  "node_modules/lodash-es/_strictIndexOf.js"() {
    strictIndexOf_default = strictIndexOf;
  }
});

// node_modules/lodash-es/_baseIndexOf.js
function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf_default(array, value, fromIndex) : baseFindIndex_default(array, baseIsNaN_default, fromIndex);
}
var baseIndexOf_default;
var init_baseIndexOf = __esm({
  "node_modules/lodash-es/_baseIndexOf.js"() {
    init_baseFindIndex();
    init_baseIsNaN();
    init_strictIndexOf();
    baseIndexOf_default = baseIndexOf;
  }
});

// node_modules/lodash-es/_arrayIncludes.js
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf_default(array, value, 0) > -1;
}
var arrayIncludes_default;
var init_arrayIncludes = __esm({
  "node_modules/lodash-es/_arrayIncludes.js"() {
    init_baseIndexOf();
    arrayIncludes_default = arrayIncludes;
  }
});

// node_modules/lodash-es/_isIndex.js
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var MAX_SAFE_INTEGER, reIsUint, isIndex_default;
var init_isIndex = __esm({
  "node_modules/lodash-es/_isIndex.js"() {
    MAX_SAFE_INTEGER = 9007199254740991;
    reIsUint = /^(?:0|[1-9]\d*)$/;
    isIndex_default = isIndex;
  }
});

// node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var baseAssignValue_default;
var init_baseAssignValue = __esm({
  "node_modules/lodash-es/_baseAssignValue.js"() {
    init_defineProperty();
    baseAssignValue_default = baseAssignValue;
  }
});

// node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default;
var init_eq = __esm({
  "node_modules/lodash-es/eq.js"() {
    eq_default = eq;
  }
});

// node_modules/lodash-es/_assignValue.js
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty3.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var objectProto4, hasOwnProperty3, assignValue_default;
var init_assignValue = __esm({
  "node_modules/lodash-es/_assignValue.js"() {
    init_baseAssignValue();
    init_eq();
    objectProto4 = Object.prototype;
    hasOwnProperty3 = objectProto4.hasOwnProperty;
    assignValue_default = assignValue;
  }
});

// node_modules/lodash-es/_copyObject.js
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue_default(object, key, newValue);
    } else {
      assignValue_default(object, key, newValue);
    }
  }
  return object;
}
var copyObject_default;
var init_copyObject = __esm({
  "node_modules/lodash-es/_copyObject.js"() {
    init_assignValue();
    init_baseAssignValue();
    copyObject_default = copyObject;
  }
});

// node_modules/lodash-es/_overRest.js
function overRest(func, start, transform) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply_default(func, this, otherArgs);
  };
}
var nativeMax, overRest_default;
var init_overRest = __esm({
  "node_modules/lodash-es/_overRest.js"() {
    init_apply();
    nativeMax = Math.max;
    overRest_default = overRest;
  }
});

// node_modules/lodash-es/_baseRest.js
function baseRest(func, start) {
  return setToString_default(overRest_default(func, start, identity_default), func + "");
}
var baseRest_default;
var init_baseRest = __esm({
  "node_modules/lodash-es/_baseRest.js"() {
    init_identity();
    init_overRest();
    init_setToString();
    baseRest_default = baseRest;
  }
});

// node_modules/lodash-es/isLength.js
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var MAX_SAFE_INTEGER2, isLength_default;
var init_isLength = __esm({
  "node_modules/lodash-es/isLength.js"() {
    MAX_SAFE_INTEGER2 = 9007199254740991;
    isLength_default = isLength;
  }
});

// node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default;
var init_isArrayLike = __esm({
  "node_modules/lodash-es/isArrayLike.js"() {
    init_isFunction();
    init_isLength();
    isArrayLike_default = isArrayLike;
  }
});

// node_modules/lodash-es/_isIterateeCall.js
function isIterateeCall(value, index, object) {
  if (!isObject_default(object)) {
    return false;
  }
  var type = typeof index;
  if (type == "number" ? isArrayLike_default(object) && isIndex_default(index, object.length) : type == "string" && index in object) {
    return eq_default(object[index], value);
  }
  return false;
}
var isIterateeCall_default;
var init_isIterateeCall = __esm({
  "node_modules/lodash-es/_isIterateeCall.js"() {
    init_eq();
    init_isArrayLike();
    init_isIndex();
    init_isObject();
    isIterateeCall_default = isIterateeCall;
  }
});

// node_modules/lodash-es/_createAssigner.js
function createAssigner(assigner) {
  return baseRest_default(function(object, sources) {
    var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}
var createAssigner_default;
var init_createAssigner = __esm({
  "node_modules/lodash-es/_createAssigner.js"() {
    init_baseRest();
    init_isIterateeCall();
    createAssigner_default = createAssigner;
  }
});

// node_modules/lodash-es/_isPrototype.js
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto5;
  return value === proto;
}
var objectProto5, isPrototype_default;
var init_isPrototype = __esm({
  "node_modules/lodash-es/_isPrototype.js"() {
    objectProto5 = Object.prototype;
    isPrototype_default = isPrototype;
  }
});

// node_modules/lodash-es/_baseTimes.js
function baseTimes(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
var baseTimes_default;
var init_baseTimes = __esm({
  "node_modules/lodash-es/_baseTimes.js"() {
    baseTimes_default = baseTimes;
  }
});

// node_modules/lodash-es/_baseIsArguments.js
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var argsTag, baseIsArguments_default;
var init_baseIsArguments = __esm({
  "node_modules/lodash-es/_baseIsArguments.js"() {
    init_baseGetTag();
    init_isObjectLike();
    argsTag = "[object Arguments]";
    baseIsArguments_default = baseIsArguments;
  }
});

// node_modules/lodash-es/isArguments.js
var objectProto6, hasOwnProperty4, propertyIsEnumerable, isArguments, isArguments_default;
var init_isArguments = __esm({
  "node_modules/lodash-es/isArguments.js"() {
    init_baseIsArguments();
    init_isObjectLike();
    objectProto6 = Object.prototype;
    hasOwnProperty4 = objectProto6.hasOwnProperty;
    propertyIsEnumerable = objectProto6.propertyIsEnumerable;
    isArguments = baseIsArguments_default(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments_default : function(value) {
      return isObjectLike_default(value) && hasOwnProperty4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    isArguments_default = isArguments;
  }
});

// node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default;
var init_stubFalse = __esm({
  "node_modules/lodash-es/stubFalse.js"() {
    stubFalse_default = stubFalse;
  }
});

// node_modules/lodash-es/isBuffer.js
var freeExports, freeModule, moduleExports, Buffer2, nativeIsBuffer, isBuffer, isBuffer_default;
var init_isBuffer = __esm({
  "node_modules/lodash-es/isBuffer.js"() {
    init_root();
    init_stubFalse();
    freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    moduleExports = freeModule && freeModule.exports === freeExports;
    Buffer2 = moduleExports ? root_default.Buffer : void 0;
    nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    isBuffer = nativeIsBuffer || stubFalse_default;
    isBuffer_default = isBuffer;
  }
});

// node_modules/lodash-es/_baseIsTypedArray.js
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var argsTag2, arrayTag, boolTag, dateTag, errorTag, funcTag2, mapTag, numberTag, objectTag, regexpTag, setTag, stringTag, weakMapTag, arrayBufferTag, dataViewTag, float32Tag, float64Tag, int8Tag, int16Tag, int32Tag, uint8Tag, uint8ClampedTag, uint16Tag, uint32Tag, typedArrayTags, baseIsTypedArray_default;
var init_baseIsTypedArray = __esm({
  "node_modules/lodash-es/_baseIsTypedArray.js"() {
    init_baseGetTag();
    init_isLength();
    init_isObjectLike();
    argsTag2 = "[object Arguments]";
    arrayTag = "[object Array]";
    boolTag = "[object Boolean]";
    dateTag = "[object Date]";
    errorTag = "[object Error]";
    funcTag2 = "[object Function]";
    mapTag = "[object Map]";
    numberTag = "[object Number]";
    objectTag = "[object Object]";
    regexpTag = "[object RegExp]";
    setTag = "[object Set]";
    stringTag = "[object String]";
    weakMapTag = "[object WeakMap]";
    arrayBufferTag = "[object ArrayBuffer]";
    dataViewTag = "[object DataView]";
    float32Tag = "[object Float32Array]";
    float64Tag = "[object Float64Array]";
    int8Tag = "[object Int8Array]";
    int16Tag = "[object Int16Array]";
    int32Tag = "[object Int32Array]";
    uint8Tag = "[object Uint8Array]";
    uint8ClampedTag = "[object Uint8ClampedArray]";
    uint16Tag = "[object Uint16Array]";
    uint32Tag = "[object Uint32Array]";
    typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    baseIsTypedArray_default = baseIsTypedArray;
  }
});

// node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var baseUnary_default;
var init_baseUnary = __esm({
  "node_modules/lodash-es/_baseUnary.js"() {
    baseUnary_default = baseUnary;
  }
});

// node_modules/lodash-es/_nodeUtil.js
var freeExports2, freeModule2, moduleExports2, freeProcess, nodeUtil, nodeUtil_default;
var init_nodeUtil = __esm({
  "node_modules/lodash-es/_nodeUtil.js"() {
    init_freeGlobal();
    freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
    moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
    freeProcess = moduleExports2 && freeGlobal_default.process;
    nodeUtil = function() {
      try {
        var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    nodeUtil_default = nodeUtil;
  }
});

// node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray, isTypedArray, isTypedArray_default;
var init_isTypedArray = __esm({
  "node_modules/lodash-es/isTypedArray.js"() {
    init_baseIsTypedArray();
    init_baseUnary();
    init_nodeUtil();
    nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
    isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
    isTypedArray_default = isTypedArray;
  }
});

// node_modules/lodash-es/_arrayLikeKeys.js
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty5.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var objectProto7, hasOwnProperty5, arrayLikeKeys_default;
var init_arrayLikeKeys = __esm({
  "node_modules/lodash-es/_arrayLikeKeys.js"() {
    init_baseTimes();
    init_isArguments();
    init_isArray();
    init_isBuffer();
    init_isIndex();
    init_isTypedArray();
    objectProto7 = Object.prototype;
    hasOwnProperty5 = objectProto7.hasOwnProperty;
    arrayLikeKeys_default = arrayLikeKeys;
  }
});

// node_modules/lodash-es/_overArg.js
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var overArg_default;
var init_overArg = __esm({
  "node_modules/lodash-es/_overArg.js"() {
    overArg_default = overArg;
  }
});

// node_modules/lodash-es/_nativeKeys.js
var nativeKeys, nativeKeys_default;
var init_nativeKeys = __esm({
  "node_modules/lodash-es/_nativeKeys.js"() {
    init_overArg();
    nativeKeys = overArg_default(Object.keys, Object);
    nativeKeys_default = nativeKeys;
  }
});

// node_modules/lodash-es/_baseKeys.js
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty6.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var objectProto8, hasOwnProperty6, baseKeys_default;
var init_baseKeys = __esm({
  "node_modules/lodash-es/_baseKeys.js"() {
    init_isPrototype();
    init_nativeKeys();
    objectProto8 = Object.prototype;
    hasOwnProperty6 = objectProto8.hasOwnProperty;
    baseKeys_default = baseKeys;
  }
});

// node_modules/lodash-es/keys.js
function keys(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
var keys_default;
var init_keys = __esm({
  "node_modules/lodash-es/keys.js"() {
    init_arrayLikeKeys();
    init_baseKeys();
    init_isArrayLike();
    keys_default = keys;
  }
});

// node_modules/lodash-es/assign.js
var objectProto9, hasOwnProperty7, assign, assign_default;
var init_assign = __esm({
  "node_modules/lodash-es/assign.js"() {
    init_assignValue();
    init_copyObject();
    init_createAssigner();
    init_isArrayLike();
    init_isPrototype();
    init_keys();
    objectProto9 = Object.prototype;
    hasOwnProperty7 = objectProto9.hasOwnProperty;
    assign = createAssigner_default(function(object, source) {
      if (isPrototype_default(source) || isArrayLike_default(source)) {
        copyObject_default(source, keys_default(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty7.call(source, key)) {
          assignValue_default(object, key, source[key]);
        }
      }
    });
    assign_default = assign;
  }
});

// node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var nativeKeysIn_default;
var init_nativeKeysIn = __esm({
  "node_modules/lodash-es/_nativeKeysIn.js"() {
    nativeKeysIn_default = nativeKeysIn;
  }
});

// node_modules/lodash-es/_baseKeysIn.js
function baseKeysIn(object) {
  if (!isObject_default(object)) {
    return nativeKeysIn_default(object);
  }
  var isProto = isPrototype_default(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty8.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var objectProto10, hasOwnProperty8, baseKeysIn_default;
var init_baseKeysIn = __esm({
  "node_modules/lodash-es/_baseKeysIn.js"() {
    init_isObject();
    init_isPrototype();
    init_nativeKeysIn();
    objectProto10 = Object.prototype;
    hasOwnProperty8 = objectProto10.hasOwnProperty;
    baseKeysIn_default = baseKeysIn;
  }
});

// node_modules/lodash-es/keysIn.js
function keysIn(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
}
var keysIn_default;
var init_keysIn = __esm({
  "node_modules/lodash-es/keysIn.js"() {
    init_arrayLikeKeys();
    init_baseKeysIn();
    init_isArrayLike();
    keysIn_default = keysIn;
  }
});

// node_modules/lodash-es/_isKey.js
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var reIsDeepProp, reIsPlainProp, isKey_default;
var init_isKey = __esm({
  "node_modules/lodash-es/_isKey.js"() {
    init_isArray();
    init_isSymbol();
    reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    reIsPlainProp = /^\w*$/;
    isKey_default = isKey;
  }
});

// node_modules/lodash-es/_nativeCreate.js
var nativeCreate, nativeCreate_default;
var init_nativeCreate = __esm({
  "node_modules/lodash-es/_nativeCreate.js"() {
    init_getNative();
    nativeCreate = getNative_default(Object, "create");
    nativeCreate_default = nativeCreate;
  }
});

// node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default;
var init_hashClear = __esm({
  "node_modules/lodash-es/_hashClear.js"() {
    init_nativeCreate();
    hashClear_default = hashClear;
  }
});

// node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var hashDelete_default;
var init_hashDelete = __esm({
  "node_modules/lodash-es/_hashDelete.js"() {
    hashDelete_default = hashDelete;
  }
});

// node_modules/lodash-es/_hashGet.js
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty9.call(data, key) ? data[key] : void 0;
}
var HASH_UNDEFINED, objectProto11, hasOwnProperty9, hashGet_default;
var init_hashGet = __esm({
  "node_modules/lodash-es/_hashGet.js"() {
    init_nativeCreate();
    HASH_UNDEFINED = "__lodash_hash_undefined__";
    objectProto11 = Object.prototype;
    hasOwnProperty9 = objectProto11.hasOwnProperty;
    hashGet_default = hashGet;
  }
});

// node_modules/lodash-es/_hashHas.js
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty10.call(data, key);
}
var objectProto12, hasOwnProperty10, hashHas_default;
var init_hashHas = __esm({
  "node_modules/lodash-es/_hashHas.js"() {
    init_nativeCreate();
    objectProto12 = Object.prototype;
    hasOwnProperty10 = objectProto12.hasOwnProperty;
    hashHas_default = hashHas;
  }
});

// node_modules/lodash-es/_hashSet.js
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var HASH_UNDEFINED2, hashSet_default;
var init_hashSet = __esm({
  "node_modules/lodash-es/_hashSet.js"() {
    init_nativeCreate();
    HASH_UNDEFINED2 = "__lodash_hash_undefined__";
    hashSet_default = hashSet;
  }
});

// node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
var Hash_default;
var init_Hash = __esm({
  "node_modules/lodash-es/_Hash.js"() {
    init_hashClear();
    init_hashDelete();
    init_hashGet();
    init_hashHas();
    init_hashSet();
    Hash.prototype.clear = hashClear_default;
    Hash.prototype["delete"] = hashDelete_default;
    Hash.prototype.get = hashGet_default;
    Hash.prototype.has = hashHas_default;
    Hash.prototype.set = hashSet_default;
    Hash_default = Hash;
  }
});

// node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default;
var init_listCacheClear = __esm({
  "node_modules/lodash-es/_listCacheClear.js"() {
    listCacheClear_default = listCacheClear;
  }
});

// node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_default(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default;
var init_assocIndexOf = __esm({
  "node_modules/lodash-es/_assocIndexOf.js"() {
    init_eq();
    assocIndexOf_default = assocIndexOf;
  }
});

// node_modules/lodash-es/_listCacheDelete.js
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var arrayProto, splice, listCacheDelete_default;
var init_listCacheDelete = __esm({
  "node_modules/lodash-es/_listCacheDelete.js"() {
    init_assocIndexOf();
    arrayProto = Array.prototype;
    splice = arrayProto.splice;
    listCacheDelete_default = listCacheDelete;
  }
});

// node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var listCacheGet_default;
var init_listCacheGet = __esm({
  "node_modules/lodash-es/_listCacheGet.js"() {
    init_assocIndexOf();
    listCacheGet_default = listCacheGet;
  }
});

// node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default;
var init_listCacheHas = __esm({
  "node_modules/lodash-es/_listCacheHas.js"() {
    init_assocIndexOf();
    listCacheHas_default = listCacheHas;
  }
});

// node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var listCacheSet_default;
var init_listCacheSet = __esm({
  "node_modules/lodash-es/_listCacheSet.js"() {
    init_assocIndexOf();
    listCacheSet_default = listCacheSet;
  }
});

// node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
var ListCache_default;
var init_ListCache = __esm({
  "node_modules/lodash-es/_ListCache.js"() {
    init_listCacheClear();
    init_listCacheDelete();
    init_listCacheGet();
    init_listCacheHas();
    init_listCacheSet();
    ListCache.prototype.clear = listCacheClear_default;
    ListCache.prototype["delete"] = listCacheDelete_default;
    ListCache.prototype.get = listCacheGet_default;
    ListCache.prototype.has = listCacheHas_default;
    ListCache.prototype.set = listCacheSet_default;
    ListCache_default = ListCache;
  }
});

// node_modules/lodash-es/_Map.js
var Map2, Map_default;
var init_Map = __esm({
  "node_modules/lodash-es/_Map.js"() {
    init_getNative();
    init_root();
    Map2 = getNative_default(root_default, "Map");
    Map_default = Map2;
  }
});

// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default;
var init_mapCacheClear = __esm({
  "node_modules/lodash-es/_mapCacheClear.js"() {
    init_Hash();
    init_ListCache();
    init_Map();
    mapCacheClear_default = mapCacheClear;
  }
});

// node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default;
var init_isKeyable = __esm({
  "node_modules/lodash-es/_isKeyable.js"() {
    isKeyable_default = isKeyable;
  }
});

// node_modules/lodash-es/_getMapData.js
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default;
var init_getMapData = __esm({
  "node_modules/lodash-es/_getMapData.js"() {
    init_isKeyable();
    getMapData_default = getMapData;
  }
});

// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var mapCacheDelete_default;
var init_mapCacheDelete = __esm({
  "node_modules/lodash-es/_mapCacheDelete.js"() {
    init_getMapData();
    mapCacheDelete_default = mapCacheDelete;
  }
});

// node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default;
var init_mapCacheGet = __esm({
  "node_modules/lodash-es/_mapCacheGet.js"() {
    init_getMapData();
    mapCacheGet_default = mapCacheGet;
  }
});

// node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default;
var init_mapCacheHas = __esm({
  "node_modules/lodash-es/_mapCacheHas.js"() {
    init_getMapData();
    mapCacheHas_default = mapCacheHas;
  }
});

// node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var mapCacheSet_default;
var init_mapCacheSet = __esm({
  "node_modules/lodash-es/_mapCacheSet.js"() {
    init_getMapData();
    mapCacheSet_default = mapCacheSet;
  }
});

// node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
var MapCache_default;
var init_MapCache = __esm({
  "node_modules/lodash-es/_MapCache.js"() {
    init_mapCacheClear();
    init_mapCacheDelete();
    init_mapCacheGet();
    init_mapCacheHas();
    init_mapCacheSet();
    MapCache.prototype.clear = mapCacheClear_default;
    MapCache.prototype["delete"] = mapCacheDelete_default;
    MapCache.prototype.get = mapCacheGet_default;
    MapCache.prototype.has = mapCacheHas_default;
    MapCache.prototype.set = mapCacheSet_default;
    MapCache_default = MapCache;
  }
});

// node_modules/lodash-es/memoize.js
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
var FUNC_ERROR_TEXT, memoize_default;
var init_memoize = __esm({
  "node_modules/lodash-es/memoize.js"() {
    init_MapCache();
    FUNC_ERROR_TEXT = "Expected a function";
    memoize.Cache = MapCache_default;
    memoize_default = memoize;
  }
});

// node_modules/lodash-es/_memoizeCapped.js
function memoizeCapped(func) {
  var result = memoize_default(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var MAX_MEMOIZE_SIZE, memoizeCapped_default;
var init_memoizeCapped = __esm({
  "node_modules/lodash-es/_memoizeCapped.js"() {
    init_memoize();
    MAX_MEMOIZE_SIZE = 500;
    memoizeCapped_default = memoizeCapped;
  }
});

// node_modules/lodash-es/_stringToPath.js
var rePropName, reEscapeChar, stringToPath, stringToPath_default;
var init_stringToPath = __esm({
  "node_modules/lodash-es/_stringToPath.js"() {
    init_memoizeCapped();
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    reEscapeChar = /\\(\\)?/g;
    stringToPath = memoizeCapped_default(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    stringToPath_default = stringToPath;
  }
});

// node_modules/lodash-es/toString.js
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default;
var init_toString = __esm({
  "node_modules/lodash-es/toString.js"() {
    init_baseToString();
    toString_default = toString;
  }
});

// node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default;
var init_castPath = __esm({
  "node_modules/lodash-es/_castPath.js"() {
    init_isArray();
    init_isKey();
    init_stringToPath();
    init_toString();
    castPath_default = castPath;
  }
});

// node_modules/lodash-es/_toKey.js
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY3 ? "-0" : result;
}
var INFINITY3, toKey_default;
var init_toKey = __esm({
  "node_modules/lodash-es/_toKey.js"() {
    init_isSymbol();
    INFINITY3 = 1 / 0;
    toKey_default = toKey;
  }
});

// node_modules/lodash-es/_baseGet.js
function baseGet(object, path4) {
  path4 = castPath_default(path4, object);
  var index = 0, length = path4.length;
  while (object != null && index < length) {
    object = object[toKey_default(path4[index++])];
  }
  return index && index == length ? object : void 0;
}
var baseGet_default;
var init_baseGet = __esm({
  "node_modules/lodash-es/_baseGet.js"() {
    init_castPath();
    init_toKey();
    baseGet_default = baseGet;
  }
});

// node_modules/lodash-es/get.js
function get2(object, path4, defaultValue) {
  var result = object == null ? void 0 : baseGet_default(object, path4);
  return result === void 0 ? defaultValue : result;
}
var get_default;
var init_get = __esm({
  "node_modules/lodash-es/get.js"() {
    init_baseGet();
    get_default = get2;
  }
});

// node_modules/lodash-es/_arrayPush.js
function arrayPush(array, values2) {
  var index = -1, length = values2.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values2[index];
  }
  return array;
}
var arrayPush_default;
var init_arrayPush = __esm({
  "node_modules/lodash-es/_arrayPush.js"() {
    arrayPush_default = arrayPush;
  }
});

// node_modules/lodash-es/_isFlattenable.js
function isFlattenable(value) {
  return isArray_default(value) || isArguments_default(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var spreadableSymbol, isFlattenable_default;
var init_isFlattenable = __esm({
  "node_modules/lodash-es/_isFlattenable.js"() {
    init_Symbol();
    init_isArguments();
    init_isArray();
    spreadableSymbol = Symbol_default ? Symbol_default.isConcatSpreadable : void 0;
    isFlattenable_default = isFlattenable;
  }
});

// node_modules/lodash-es/_baseFlatten.js
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1, length = array.length;
  predicate || (predicate = isFlattenable_default);
  result || (result = []);
  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush_default(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var baseFlatten_default;
var init_baseFlatten = __esm({
  "node_modules/lodash-es/_baseFlatten.js"() {
    init_arrayPush();
    init_isFlattenable();
    baseFlatten_default = baseFlatten;
  }
});

// node_modules/lodash-es/flatten.js
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten_default(array, 1) : [];
}
var flatten_default;
var init_flatten = __esm({
  "node_modules/lodash-es/flatten.js"() {
    init_baseFlatten();
    flatten_default = flatten;
  }
});

// node_modules/lodash-es/_getPrototype.js
var getPrototype, getPrototype_default;
var init_getPrototype = __esm({
  "node_modules/lodash-es/_getPrototype.js"() {
    init_overArg();
    getPrototype = overArg_default(Object.getPrototypeOf, Object);
    getPrototype_default = getPrototype;
  }
});

// node_modules/lodash-es/_baseSlice.js
function baseSlice(array, start, end) {
  var index = -1, length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}
var baseSlice_default;
var init_baseSlice = __esm({
  "node_modules/lodash-es/_baseSlice.js"() {
    baseSlice_default = baseSlice;
  }
});

// node_modules/lodash-es/_castSlice.js
function castSlice(array, start, end) {
  var length = array.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array : baseSlice_default(array, start, end);
}
var castSlice_default;
var init_castSlice = __esm({
  "node_modules/lodash-es/_castSlice.js"() {
    init_baseSlice();
    castSlice_default = castSlice;
  }
});

// node_modules/lodash-es/_hasUnicode.js
function hasUnicode(string) {
  return reHasUnicode.test(string);
}
var rsAstralRange, rsComboMarksRange, reComboHalfMarksRange, rsComboSymbolsRange, rsComboRange, rsVarRange, rsZWJ, reHasUnicode, hasUnicode_default;
var init_hasUnicode = __esm({
  "node_modules/lodash-es/_hasUnicode.js"() {
    rsAstralRange = "\\ud800-\\udfff";
    rsComboMarksRange = "\\u0300-\\u036f";
    reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    rsComboSymbolsRange = "\\u20d0-\\u20ff";
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    rsVarRange = "\\ufe0e\\ufe0f";
    rsZWJ = "\\u200d";
    reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    hasUnicode_default = hasUnicode;
  }
});

// node_modules/lodash-es/_asciiToArray.js
function asciiToArray(string) {
  return string.split("");
}
var asciiToArray_default;
var init_asciiToArray = __esm({
  "node_modules/lodash-es/_asciiToArray.js"() {
    asciiToArray_default = asciiToArray;
  }
});

// node_modules/lodash-es/_unicodeToArray.js
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}
var rsAstralRange2, rsComboMarksRange2, reComboHalfMarksRange2, rsComboSymbolsRange2, rsComboRange2, rsVarRange2, rsAstral, rsCombo, rsFitz, rsModifier, rsNonAstral, rsRegional, rsSurrPair, rsZWJ2, reOptMod, rsOptVar, rsOptJoin, rsSeq, rsSymbol, reUnicode, unicodeToArray_default;
var init_unicodeToArray = __esm({
  "node_modules/lodash-es/_unicodeToArray.js"() {
    rsAstralRange2 = "\\ud800-\\udfff";
    rsComboMarksRange2 = "\\u0300-\\u036f";
    reComboHalfMarksRange2 = "\\ufe20-\\ufe2f";
    rsComboSymbolsRange2 = "\\u20d0-\\u20ff";
    rsComboRange2 = rsComboMarksRange2 + reComboHalfMarksRange2 + rsComboSymbolsRange2;
    rsVarRange2 = "\\ufe0e\\ufe0f";
    rsAstral = "[" + rsAstralRange2 + "]";
    rsCombo = "[" + rsComboRange2 + "]";
    rsFitz = "\\ud83c[\\udffb-\\udfff]";
    rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    rsNonAstral = "[^" + rsAstralRange2 + "]";
    rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    rsZWJ2 = "\\u200d";
    reOptMod = rsModifier + "?";
    rsOptVar = "[" + rsVarRange2 + "]?";
    rsOptJoin = "(?:" + rsZWJ2 + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    rsSeq = rsOptVar + reOptMod + rsOptJoin;
    rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    unicodeToArray_default = unicodeToArray;
  }
});

// node_modules/lodash-es/_stringToArray.js
function stringToArray(string) {
  return hasUnicode_default(string) ? unicodeToArray_default(string) : asciiToArray_default(string);
}
var stringToArray_default;
var init_stringToArray = __esm({
  "node_modules/lodash-es/_stringToArray.js"() {
    init_asciiToArray();
    init_hasUnicode();
    init_unicodeToArray();
    stringToArray_default = stringToArray;
  }
});

// node_modules/lodash-es/_createCaseFirst.js
function createCaseFirst(methodName) {
  return function(string) {
    string = toString_default(string);
    var strSymbols = hasUnicode_default(string) ? stringToArray_default(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice_default(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
var createCaseFirst_default;
var init_createCaseFirst = __esm({
  "node_modules/lodash-es/_createCaseFirst.js"() {
    init_castSlice();
    init_hasUnicode();
    init_stringToArray();
    init_toString();
    createCaseFirst_default = createCaseFirst;
  }
});

// node_modules/lodash-es/upperFirst.js
var upperFirst, upperFirst_default;
var init_upperFirst = __esm({
  "node_modules/lodash-es/upperFirst.js"() {
    init_createCaseFirst();
    upperFirst = createCaseFirst_default("toUpperCase");
    upperFirst_default = upperFirst;
  }
});

// node_modules/lodash-es/capitalize.js
function capitalize(string) {
  return upperFirst_default(toString_default(string).toLowerCase());
}
var capitalize_default;
var init_capitalize = __esm({
  "node_modules/lodash-es/capitalize.js"() {
    init_toString();
    init_upperFirst();
    capitalize_default = capitalize;
  }
});

// node_modules/lodash-es/_arrayReduce.js
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1, length = array == null ? 0 : array.length;
  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}
var arrayReduce_default;
var init_arrayReduce = __esm({
  "node_modules/lodash-es/_arrayReduce.js"() {
    arrayReduce_default = arrayReduce;
  }
});

// node_modules/lodash-es/_basePropertyOf.js
function basePropertyOf(object) {
  return function(key) {
    return object == null ? void 0 : object[key];
  };
}
var basePropertyOf_default;
var init_basePropertyOf = __esm({
  "node_modules/lodash-es/_basePropertyOf.js"() {
    basePropertyOf_default = basePropertyOf;
  }
});

// node_modules/lodash-es/_deburrLetter.js
var deburredLetters, deburrLetter, deburrLetter_default;
var init_deburrLetter = __esm({
  "node_modules/lodash-es/_deburrLetter.js"() {
    init_basePropertyOf();
    deburredLetters = {
      // Latin-1 Supplement block.
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      // Latin Extended-A block.
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    deburrLetter = basePropertyOf_default(deburredLetters);
    deburrLetter_default = deburrLetter;
  }
});

// node_modules/lodash-es/deburr.js
function deburr(string) {
  string = toString_default(string);
  return string && string.replace(reLatin, deburrLetter_default).replace(reComboMark, "");
}
var reLatin, rsComboMarksRange3, reComboHalfMarksRange3, rsComboSymbolsRange3, rsComboRange3, rsCombo2, reComboMark, deburr_default;
var init_deburr = __esm({
  "node_modules/lodash-es/deburr.js"() {
    init_deburrLetter();
    init_toString();
    reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    rsComboMarksRange3 = "\\u0300-\\u036f";
    reComboHalfMarksRange3 = "\\ufe20-\\ufe2f";
    rsComboSymbolsRange3 = "\\u20d0-\\u20ff";
    rsComboRange3 = rsComboMarksRange3 + reComboHalfMarksRange3 + rsComboSymbolsRange3;
    rsCombo2 = "[" + rsComboRange3 + "]";
    reComboMark = RegExp(rsCombo2, "g");
    deburr_default = deburr;
  }
});

// node_modules/lodash-es/_asciiWords.js
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}
var reAsciiWord, asciiWords_default;
var init_asciiWords = __esm({
  "node_modules/lodash-es/_asciiWords.js"() {
    reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    asciiWords_default = asciiWords;
  }
});

// node_modules/lodash-es/_hasUnicodeWord.js
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}
var reHasUnicodeWord, hasUnicodeWord_default;
var init_hasUnicodeWord = __esm({
  "node_modules/lodash-es/_hasUnicodeWord.js"() {
    reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    hasUnicodeWord_default = hasUnicodeWord;
  }
});

// node_modules/lodash-es/_unicodeWords.js
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}
var rsAstralRange3, rsComboMarksRange4, reComboHalfMarksRange4, rsComboSymbolsRange4, rsComboRange4, rsDingbatRange, rsLowerRange, rsMathOpRange, rsNonCharRange, rsPunctuationRange, rsSpaceRange, rsUpperRange, rsVarRange3, rsBreakRange, rsApos, rsBreak, rsCombo3, rsDigits, rsDingbat, rsLower, rsMisc, rsFitz2, rsModifier2, rsNonAstral2, rsRegional2, rsSurrPair2, rsUpper, rsZWJ3, rsMiscLower, rsMiscUpper, rsOptContrLower, rsOptContrUpper, reOptMod2, rsOptVar2, rsOptJoin2, rsOrdLower, rsOrdUpper, rsSeq2, rsEmoji, reUnicodeWord, unicodeWords_default;
var init_unicodeWords = __esm({
  "node_modules/lodash-es/_unicodeWords.js"() {
    rsAstralRange3 = "\\ud800-\\udfff";
    rsComboMarksRange4 = "\\u0300-\\u036f";
    reComboHalfMarksRange4 = "\\ufe20-\\ufe2f";
    rsComboSymbolsRange4 = "\\u20d0-\\u20ff";
    rsComboRange4 = rsComboMarksRange4 + reComboHalfMarksRange4 + rsComboSymbolsRange4;
    rsDingbatRange = "\\u2700-\\u27bf";
    rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    rsPunctuationRange = "\\u2000-\\u206f";
    rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    rsVarRange3 = "\\ufe0e\\ufe0f";
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    rsApos = "['\u2019]";
    rsBreak = "[" + rsBreakRange + "]";
    rsCombo3 = "[" + rsComboRange4 + "]";
    rsDigits = "\\d+";
    rsDingbat = "[" + rsDingbatRange + "]";
    rsLower = "[" + rsLowerRange + "]";
    rsMisc = "[^" + rsAstralRange3 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    rsFitz2 = "\\ud83c[\\udffb-\\udfff]";
    rsModifier2 = "(?:" + rsCombo3 + "|" + rsFitz2 + ")";
    rsNonAstral2 = "[^" + rsAstralRange3 + "]";
    rsRegional2 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    rsSurrPair2 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    rsUpper = "[" + rsUpperRange + "]";
    rsZWJ3 = "\\u200d";
    rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
    rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
    rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    reOptMod2 = rsModifier2 + "?";
    rsOptVar2 = "[" + rsVarRange3 + "]?";
    rsOptJoin2 = "(?:" + rsZWJ3 + "(?:" + [rsNonAstral2, rsRegional2, rsSurrPair2].join("|") + ")" + rsOptVar2 + reOptMod2 + ")*";
    rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
    rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
    rsSeq2 = rsOptVar2 + reOptMod2 + rsOptJoin2;
    rsEmoji = "(?:" + [rsDingbat, rsRegional2, rsSurrPair2].join("|") + ")" + rsSeq2;
    reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    unicodeWords_default = unicodeWords;
  }
});

// node_modules/lodash-es/words.js
function words(string, pattern, guard) {
  string = toString_default(string);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord_default(string) ? unicodeWords_default(string) : asciiWords_default(string);
  }
  return string.match(pattern) || [];
}
var words_default;
var init_words = __esm({
  "node_modules/lodash-es/words.js"() {
    init_asciiWords();
    init_hasUnicodeWord();
    init_toString();
    init_unicodeWords();
    words_default = words;
  }
});

// node_modules/lodash-es/_createCompounder.js
function createCompounder(callback) {
  return function(string) {
    return arrayReduce_default(words_default(deburr_default(string).replace(reApos, "")), callback, "");
  };
}
var rsApos2, reApos, createCompounder_default;
var init_createCompounder = __esm({
  "node_modules/lodash-es/_createCompounder.js"() {
    init_arrayReduce();
    init_deburr();
    init_words();
    rsApos2 = "['\u2019]";
    reApos = RegExp(rsApos2, "g");
    createCompounder_default = createCompounder;
  }
});

// node_modules/lodash-es/camelCase.js
var camelCase, camelCase_default;
var init_camelCase = __esm({
  "node_modules/lodash-es/camelCase.js"() {
    init_capitalize();
    init_createCompounder();
    camelCase = createCompounder_default(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize_default(word) : word);
    });
    camelCase_default = camelCase;
  }
});

// node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default;
var init_stackClear = __esm({
  "node_modules/lodash-es/_stackClear.js"() {
    init_ListCache();
    stackClear_default = stackClear;
  }
});

// node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var stackDelete_default;
var init_stackDelete = __esm({
  "node_modules/lodash-es/_stackDelete.js"() {
    stackDelete_default = stackDelete;
  }
});

// node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
var stackGet_default;
var init_stackGet = __esm({
  "node_modules/lodash-es/_stackGet.js"() {
    stackGet_default = stackGet;
  }
});

// node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
var stackHas_default;
var init_stackHas = __esm({
  "node_modules/lodash-es/_stackHas.js"() {
    stackHas_default = stackHas;
  }
});

// node_modules/lodash-es/_stackSet.js
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs = data.__data__;
    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var LARGE_ARRAY_SIZE, stackSet_default;
var init_stackSet = __esm({
  "node_modules/lodash-es/_stackSet.js"() {
    init_ListCache();
    init_Map();
    init_MapCache();
    LARGE_ARRAY_SIZE = 200;
    stackSet_default = stackSet;
  }
});

// node_modules/lodash-es/_Stack.js
function Stack(entries) {
  var data = this.__data__ = new ListCache_default(entries);
  this.size = data.size;
}
var Stack_default;
var init_Stack = __esm({
  "node_modules/lodash-es/_Stack.js"() {
    init_ListCache();
    init_stackClear();
    init_stackDelete();
    init_stackGet();
    init_stackHas();
    init_stackSet();
    Stack.prototype.clear = stackClear_default;
    Stack.prototype["delete"] = stackDelete_default;
    Stack.prototype.get = stackGet_default;
    Stack.prototype.has = stackHas_default;
    Stack.prototype.set = stackSet_default;
    Stack_default = Stack;
  }
});

// node_modules/lodash-es/_baseAssign.js
function baseAssign(object, source) {
  return object && copyObject_default(source, keys_default(source), object);
}
var baseAssign_default;
var init_baseAssign = __esm({
  "node_modules/lodash-es/_baseAssign.js"() {
    init_copyObject();
    init_keys();
    baseAssign_default = baseAssign;
  }
});

// node_modules/lodash-es/_baseAssignIn.js
function baseAssignIn(object, source) {
  return object && copyObject_default(source, keysIn_default(source), object);
}
var baseAssignIn_default;
var init_baseAssignIn = __esm({
  "node_modules/lodash-es/_baseAssignIn.js"() {
    init_copyObject();
    init_keysIn();
    baseAssignIn_default = baseAssignIn;
  }
});

// node_modules/lodash-es/_cloneBuffer.js
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
var freeExports3, freeModule3, moduleExports3, Buffer3, allocUnsafe, cloneBuffer_default;
var init_cloneBuffer = __esm({
  "node_modules/lodash-es/_cloneBuffer.js"() {
    init_root();
    freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
    freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
    moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
    Buffer3 = moduleExports3 ? root_default.Buffer : void 0;
    allocUnsafe = Buffer3 ? Buffer3.allocUnsafe : void 0;
    cloneBuffer_default = cloneBuffer;
  }
});

// node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var arrayFilter_default;
var init_arrayFilter = __esm({
  "node_modules/lodash-es/_arrayFilter.js"() {
    arrayFilter_default = arrayFilter;
  }
});

// node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
var stubArray_default;
var init_stubArray = __esm({
  "node_modules/lodash-es/stubArray.js"() {
    stubArray_default = stubArray;
  }
});

// node_modules/lodash-es/_getSymbols.js
var objectProto13, propertyIsEnumerable2, nativeGetSymbols, getSymbols, getSymbols_default;
var init_getSymbols = __esm({
  "node_modules/lodash-es/_getSymbols.js"() {
    init_arrayFilter();
    init_stubArray();
    objectProto13 = Object.prototype;
    propertyIsEnumerable2 = objectProto13.propertyIsEnumerable;
    nativeGetSymbols = Object.getOwnPropertySymbols;
    getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable2.call(object, symbol);
      });
    };
    getSymbols_default = getSymbols;
  }
});

// node_modules/lodash-es/_copySymbols.js
function copySymbols(source, object) {
  return copyObject_default(source, getSymbols_default(source), object);
}
var copySymbols_default;
var init_copySymbols = __esm({
  "node_modules/lodash-es/_copySymbols.js"() {
    init_copyObject();
    init_getSymbols();
    copySymbols_default = copySymbols;
  }
});

// node_modules/lodash-es/_getSymbolsIn.js
var nativeGetSymbols2, getSymbolsIn, getSymbolsIn_default;
var init_getSymbolsIn = __esm({
  "node_modules/lodash-es/_getSymbolsIn.js"() {
    init_arrayPush();
    init_getPrototype();
    init_getSymbols();
    init_stubArray();
    nativeGetSymbols2 = Object.getOwnPropertySymbols;
    getSymbolsIn = !nativeGetSymbols2 ? stubArray_default : function(object) {
      var result = [];
      while (object) {
        arrayPush_default(result, getSymbols_default(object));
        object = getPrototype_default(object);
      }
      return result;
    };
    getSymbolsIn_default = getSymbolsIn;
  }
});

// node_modules/lodash-es/_copySymbolsIn.js
function copySymbolsIn(source, object) {
  return copyObject_default(source, getSymbolsIn_default(source), object);
}
var copySymbolsIn_default;
var init_copySymbolsIn = __esm({
  "node_modules/lodash-es/_copySymbolsIn.js"() {
    init_copyObject();
    init_getSymbolsIn();
    copySymbolsIn_default = copySymbolsIn;
  }
});

// node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_default(object) ? result : arrayPush_default(result, symbolsFunc(object));
}
var baseGetAllKeys_default;
var init_baseGetAllKeys = __esm({
  "node_modules/lodash-es/_baseGetAllKeys.js"() {
    init_arrayPush();
    init_isArray();
    baseGetAllKeys_default = baseGetAllKeys;
  }
});

// node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object) {
  return baseGetAllKeys_default(object, keys_default, getSymbols_default);
}
var getAllKeys_default;
var init_getAllKeys = __esm({
  "node_modules/lodash-es/_getAllKeys.js"() {
    init_baseGetAllKeys();
    init_getSymbols();
    init_keys();
    getAllKeys_default = getAllKeys;
  }
});

// node_modules/lodash-es/_getAllKeysIn.js
function getAllKeysIn(object) {
  return baseGetAllKeys_default(object, keysIn_default, getSymbolsIn_default);
}
var getAllKeysIn_default;
var init_getAllKeysIn = __esm({
  "node_modules/lodash-es/_getAllKeysIn.js"() {
    init_baseGetAllKeys();
    init_getSymbolsIn();
    init_keysIn();
    getAllKeysIn_default = getAllKeysIn;
  }
});

// node_modules/lodash-es/_DataView.js
var DataView, DataView_default;
var init_DataView = __esm({
  "node_modules/lodash-es/_DataView.js"() {
    init_getNative();
    init_root();
    DataView = getNative_default(root_default, "DataView");
    DataView_default = DataView;
  }
});

// node_modules/lodash-es/_Promise.js
var Promise2, Promise_default;
var init_Promise = __esm({
  "node_modules/lodash-es/_Promise.js"() {
    init_getNative();
    init_root();
    Promise2 = getNative_default(root_default, "Promise");
    Promise_default = Promise2;
  }
});

// node_modules/lodash-es/_Set.js
var Set2, Set_default;
var init_Set = __esm({
  "node_modules/lodash-es/_Set.js"() {
    init_getNative();
    init_root();
    Set2 = getNative_default(root_default, "Set");
    Set_default = Set2;
  }
});

// node_modules/lodash-es/_getTag.js
var mapTag2, objectTag2, promiseTag, setTag2, weakMapTag2, dataViewTag2, dataViewCtorString, mapCtorString, promiseCtorString, setCtorString, weakMapCtorString, getTag, getTag_default;
var init_getTag = __esm({
  "node_modules/lodash-es/_getTag.js"() {
    init_DataView();
    init_Map();
    init_Promise();
    init_Set();
    init_WeakMap();
    init_baseGetTag();
    init_toSource();
    mapTag2 = "[object Map]";
    objectTag2 = "[object Object]";
    promiseTag = "[object Promise]";
    setTag2 = "[object Set]";
    weakMapTag2 = "[object WeakMap]";
    dataViewTag2 = "[object DataView]";
    dataViewCtorString = toSource_default(DataView_default);
    mapCtorString = toSource_default(Map_default);
    promiseCtorString = toSource_default(Promise_default);
    setCtorString = toSource_default(Set_default);
    weakMapCtorString = toSource_default(WeakMap_default);
    getTag = baseGetTag_default;
    if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
      getTag = function(value) {
        var result = baseGetTag_default(value), Ctor = result == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag2;
            case mapCtorString:
              return mapTag2;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag2;
            case weakMapCtorString:
              return weakMapTag2;
          }
        }
        return result;
      };
    }
    getTag_default = getTag;
  }
});

// node_modules/lodash-es/_initCloneArray.js
function initCloneArray(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty11.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var objectProto14, hasOwnProperty11, initCloneArray_default;
var init_initCloneArray = __esm({
  "node_modules/lodash-es/_initCloneArray.js"() {
    objectProto14 = Object.prototype;
    hasOwnProperty11 = objectProto14.hasOwnProperty;
    initCloneArray_default = initCloneArray;
  }
});

// node_modules/lodash-es/_Uint8Array.js
var Uint8Array2, Uint8Array_default;
var init_Uint8Array = __esm({
  "node_modules/lodash-es/_Uint8Array.js"() {
    init_root();
    Uint8Array2 = root_default.Uint8Array;
    Uint8Array_default = Uint8Array2;
  }
});

// node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array_default(result).set(new Uint8Array_default(arrayBuffer));
  return result;
}
var cloneArrayBuffer_default;
var init_cloneArrayBuffer = __esm({
  "node_modules/lodash-es/_cloneArrayBuffer.js"() {
    init_Uint8Array();
    cloneArrayBuffer_default = cloneArrayBuffer;
  }
});

// node_modules/lodash-es/_cloneDataView.js
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var cloneDataView_default;
var init_cloneDataView = __esm({
  "node_modules/lodash-es/_cloneDataView.js"() {
    init_cloneArrayBuffer();
    cloneDataView_default = cloneDataView;
  }
});

// node_modules/lodash-es/_cloneRegExp.js
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var reFlags, cloneRegExp_default;
var init_cloneRegExp = __esm({
  "node_modules/lodash-es/_cloneRegExp.js"() {
    reFlags = /\w*$/;
    cloneRegExp_default = cloneRegExp;
  }
});

// node_modules/lodash-es/_cloneSymbol.js
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var symbolProto2, symbolValueOf, cloneSymbol_default;
var init_cloneSymbol = __esm({
  "node_modules/lodash-es/_cloneSymbol.js"() {
    init_Symbol();
    symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
    symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
    cloneSymbol_default = cloneSymbol;
  }
});

// node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var cloneTypedArray_default;
var init_cloneTypedArray = __esm({
  "node_modules/lodash-es/_cloneTypedArray.js"() {
    init_cloneArrayBuffer();
    cloneTypedArray_default = cloneTypedArray;
  }
});

// node_modules/lodash-es/_initCloneByTag.js
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag2:
      return cloneArrayBuffer_default(object);
    case boolTag2:
    case dateTag2:
      return new Ctor(+object);
    case dataViewTag3:
      return cloneDataView_default(object, isDeep);
    case float32Tag2:
    case float64Tag2:
    case int8Tag2:
    case int16Tag2:
    case int32Tag2:
    case uint8Tag2:
    case uint8ClampedTag2:
    case uint16Tag2:
    case uint32Tag2:
      return cloneTypedArray_default(object, isDeep);
    case mapTag3:
      return new Ctor();
    case numberTag2:
    case stringTag2:
      return new Ctor(object);
    case regexpTag2:
      return cloneRegExp_default(object);
    case setTag3:
      return new Ctor();
    case symbolTag2:
      return cloneSymbol_default(object);
  }
}
var boolTag2, dateTag2, mapTag3, numberTag2, regexpTag2, setTag3, stringTag2, symbolTag2, arrayBufferTag2, dataViewTag3, float32Tag2, float64Tag2, int8Tag2, int16Tag2, int32Tag2, uint8Tag2, uint8ClampedTag2, uint16Tag2, uint32Tag2, initCloneByTag_default;
var init_initCloneByTag = __esm({
  "node_modules/lodash-es/_initCloneByTag.js"() {
    init_cloneArrayBuffer();
    init_cloneDataView();
    init_cloneRegExp();
    init_cloneSymbol();
    init_cloneTypedArray();
    boolTag2 = "[object Boolean]";
    dateTag2 = "[object Date]";
    mapTag3 = "[object Map]";
    numberTag2 = "[object Number]";
    regexpTag2 = "[object RegExp]";
    setTag3 = "[object Set]";
    stringTag2 = "[object String]";
    symbolTag2 = "[object Symbol]";
    arrayBufferTag2 = "[object ArrayBuffer]";
    dataViewTag3 = "[object DataView]";
    float32Tag2 = "[object Float32Array]";
    float64Tag2 = "[object Float64Array]";
    int8Tag2 = "[object Int8Array]";
    int16Tag2 = "[object Int16Array]";
    int32Tag2 = "[object Int32Array]";
    uint8Tag2 = "[object Uint8Array]";
    uint8ClampedTag2 = "[object Uint8ClampedArray]";
    uint16Tag2 = "[object Uint16Array]";
    uint32Tag2 = "[object Uint32Array]";
    initCloneByTag_default = initCloneByTag;
  }
});

// node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};
}
var initCloneObject_default;
var init_initCloneObject = __esm({
  "node_modules/lodash-es/_initCloneObject.js"() {
    init_baseCreate();
    init_getPrototype();
    init_isPrototype();
    initCloneObject_default = initCloneObject;
  }
});

// node_modules/lodash-es/_baseIsMap.js
function baseIsMap(value) {
  return isObjectLike_default(value) && getTag_default(value) == mapTag4;
}
var mapTag4, baseIsMap_default;
var init_baseIsMap = __esm({
  "node_modules/lodash-es/_baseIsMap.js"() {
    init_getTag();
    init_isObjectLike();
    mapTag4 = "[object Map]";
    baseIsMap_default = baseIsMap;
  }
});

// node_modules/lodash-es/isMap.js
var nodeIsMap, isMap, isMap_default;
var init_isMap = __esm({
  "node_modules/lodash-es/isMap.js"() {
    init_baseIsMap();
    init_baseUnary();
    init_nodeUtil();
    nodeIsMap = nodeUtil_default && nodeUtil_default.isMap;
    isMap = nodeIsMap ? baseUnary_default(nodeIsMap) : baseIsMap_default;
    isMap_default = isMap;
  }
});

// node_modules/lodash-es/_baseIsSet.js
function baseIsSet(value) {
  return isObjectLike_default(value) && getTag_default(value) == setTag4;
}
var setTag4, baseIsSet_default;
var init_baseIsSet = __esm({
  "node_modules/lodash-es/_baseIsSet.js"() {
    init_getTag();
    init_isObjectLike();
    setTag4 = "[object Set]";
    baseIsSet_default = baseIsSet;
  }
});

// node_modules/lodash-es/isSet.js
var nodeIsSet, isSet, isSet_default;
var init_isSet = __esm({
  "node_modules/lodash-es/isSet.js"() {
    init_baseIsSet();
    init_baseUnary();
    init_nodeUtil();
    nodeIsSet = nodeUtil_default && nodeUtil_default.isSet;
    isSet = nodeIsSet ? baseUnary_default(nodeIsSet) : baseIsSet_default;
    isSet_default = isSet;
  }
});

// node_modules/lodash-es/_baseClone.js
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject_default(value)) {
    return value;
  }
  var isArr = isArray_default(value);
  if (isArr) {
    result = initCloneArray_default(value);
    if (!isDeep) {
      return copyArray_default(value, result);
    }
  } else {
    var tag = getTag_default(value), isFunc = tag == funcTag3 || tag == genTag2;
    if (isBuffer_default(value)) {
      return cloneBuffer_default(value, isDeep);
    }
    if (tag == objectTag3 || tag == argsTag3 || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject_default(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn_default(value, baseAssignIn_default(result, value)) : copySymbols_default(value, baseAssign_default(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag_default(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack_default());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet_default(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap_default(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn_default : getAllKeys_default : isFlat ? keysIn_default : keys_default;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach_default(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue_default(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var CLONE_DEEP_FLAG, CLONE_FLAT_FLAG, CLONE_SYMBOLS_FLAG, argsTag3, arrayTag2, boolTag3, dateTag3, errorTag2, funcTag3, genTag2, mapTag5, numberTag3, objectTag3, regexpTag3, setTag5, stringTag3, symbolTag3, weakMapTag3, arrayBufferTag3, dataViewTag4, float32Tag3, float64Tag3, int8Tag3, int16Tag3, int32Tag3, uint8Tag3, uint8ClampedTag3, uint16Tag3, uint32Tag3, cloneableTags, baseClone_default;
var init_baseClone = __esm({
  "node_modules/lodash-es/_baseClone.js"() {
    init_Stack();
    init_arrayEach();
    init_assignValue();
    init_baseAssign();
    init_baseAssignIn();
    init_cloneBuffer();
    init_copyArray();
    init_copySymbols();
    init_copySymbolsIn();
    init_getAllKeys();
    init_getAllKeysIn();
    init_getTag();
    init_initCloneArray();
    init_initCloneByTag();
    init_initCloneObject();
    init_isArray();
    init_isBuffer();
    init_isMap();
    init_isObject();
    init_isSet();
    init_keys();
    init_keysIn();
    CLONE_DEEP_FLAG = 1;
    CLONE_FLAT_FLAG = 2;
    CLONE_SYMBOLS_FLAG = 4;
    argsTag3 = "[object Arguments]";
    arrayTag2 = "[object Array]";
    boolTag3 = "[object Boolean]";
    dateTag3 = "[object Date]";
    errorTag2 = "[object Error]";
    funcTag3 = "[object Function]";
    genTag2 = "[object GeneratorFunction]";
    mapTag5 = "[object Map]";
    numberTag3 = "[object Number]";
    objectTag3 = "[object Object]";
    regexpTag3 = "[object RegExp]";
    setTag5 = "[object Set]";
    stringTag3 = "[object String]";
    symbolTag3 = "[object Symbol]";
    weakMapTag3 = "[object WeakMap]";
    arrayBufferTag3 = "[object ArrayBuffer]";
    dataViewTag4 = "[object DataView]";
    float32Tag3 = "[object Float32Array]";
    float64Tag3 = "[object Float64Array]";
    int8Tag3 = "[object Int8Array]";
    int16Tag3 = "[object Int16Array]";
    int32Tag3 = "[object Int32Array]";
    uint8Tag3 = "[object Uint8Array]";
    uint8ClampedTag3 = "[object Uint8ClampedArray]";
    uint16Tag3 = "[object Uint16Array]";
    uint32Tag3 = "[object Uint32Array]";
    cloneableTags = {};
    cloneableTags[argsTag3] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag3] = cloneableTags[dataViewTag4] = cloneableTags[boolTag3] = cloneableTags[dateTag3] = cloneableTags[float32Tag3] = cloneableTags[float64Tag3] = cloneableTags[int8Tag3] = cloneableTags[int16Tag3] = cloneableTags[int32Tag3] = cloneableTags[mapTag5] = cloneableTags[numberTag3] = cloneableTags[objectTag3] = cloneableTags[regexpTag3] = cloneableTags[setTag5] = cloneableTags[stringTag3] = cloneableTags[symbolTag3] = cloneableTags[uint8Tag3] = cloneableTags[uint8ClampedTag3] = cloneableTags[uint16Tag3] = cloneableTags[uint32Tag3] = true;
    cloneableTags[errorTag2] = cloneableTags[funcTag3] = cloneableTags[weakMapTag3] = false;
    baseClone_default = baseClone;
  }
});

// node_modules/lodash-es/clone.js
function clone(value) {
  return baseClone_default(value, CLONE_SYMBOLS_FLAG2);
}
var CLONE_SYMBOLS_FLAG2, clone_default;
var init_clone = __esm({
  "node_modules/lodash-es/clone.js"() {
    init_baseClone();
    CLONE_SYMBOLS_FLAG2 = 4;
    clone_default = clone;
  }
});

// node_modules/lodash-es/compact.js
function compact(array) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (value) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var compact_default;
var init_compact = __esm({
  "node_modules/lodash-es/compact.js"() {
    compact_default = compact;
  }
});

// node_modules/lodash-es/_setCacheAdd.js
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED3);
  return this;
}
var HASH_UNDEFINED3, setCacheAdd_default;
var init_setCacheAdd = __esm({
  "node_modules/lodash-es/_setCacheAdd.js"() {
    HASH_UNDEFINED3 = "__lodash_hash_undefined__";
    setCacheAdd_default = setCacheAdd;
  }
});

// node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value) {
  return this.__data__.has(value);
}
var setCacheHas_default;
var init_setCacheHas = __esm({
  "node_modules/lodash-es/_setCacheHas.js"() {
    setCacheHas_default = setCacheHas;
  }
});

// node_modules/lodash-es/_SetCache.js
function SetCache(values2) {
  var index = -1, length = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache_default();
  while (++index < length) {
    this.add(values2[index]);
  }
}
var SetCache_default;
var init_SetCache = __esm({
  "node_modules/lodash-es/_SetCache.js"() {
    init_MapCache();
    init_setCacheAdd();
    init_setCacheHas();
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
    SetCache.prototype.has = setCacheHas_default;
    SetCache_default = SetCache;
  }
});

// node_modules/lodash-es/_arraySome.js
function arraySome(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
var arraySome_default;
var init_arraySome = __esm({
  "node_modules/lodash-es/_arraySome.js"() {
    arraySome_default = arraySome;
  }
});

// node_modules/lodash-es/_cacheHas.js
function cacheHas(cache, key) {
  return cache.has(key);
}
var cacheHas_default;
var init_cacheHas = __esm({
  "node_modules/lodash-es/_cacheHas.js"() {
    cacheHas_default = cacheHas;
  }
});

// node_modules/lodash-es/_equalArrays.js
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index < arrLength) {
    var arrValue = array[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other, function(othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var COMPARE_PARTIAL_FLAG, COMPARE_UNORDERED_FLAG, equalArrays_default;
var init_equalArrays = __esm({
  "node_modules/lodash-es/_equalArrays.js"() {
    init_SetCache();
    init_arraySome();
    init_cacheHas();
    COMPARE_PARTIAL_FLAG = 1;
    COMPARE_UNORDERED_FLAG = 2;
    equalArrays_default = equalArrays;
  }
});

// node_modules/lodash-es/_mapToArray.js
function mapToArray(map2) {
  var index = -1, result = Array(map2.size);
  map2.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}
var mapToArray_default;
var init_mapToArray = __esm({
  "node_modules/lodash-es/_mapToArray.js"() {
    mapToArray_default = mapToArray;
  }
});

// node_modules/lodash-es/_setToArray.js
function setToArray(set) {
  var index = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
var setToArray_default;
var init_setToArray = __esm({
  "node_modules/lodash-es/_setToArray.js"() {
    setToArray_default = setToArray;
  }
});

// node_modules/lodash-es/_equalByTag.js
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag5:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag4:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
        return false;
      }
      return true;
    case boolTag4:
    case dateTag4:
    case numberTag4:
      return eq_default(+object, +other);
    case errorTag3:
      return object.name == other.name && object.message == other.message;
    case regexpTag4:
    case stringTag4:
      return object == other + "";
    case mapTag6:
      var convert8 = mapToArray_default;
    case setTag6:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
      convert8 || (convert8 = setToArray_default);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG2;
      stack.set(object, other);
      var result = equalArrays_default(convert8(object), convert8(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag4:
      if (symbolValueOf2) {
        return symbolValueOf2.call(object) == symbolValueOf2.call(other);
      }
  }
  return false;
}
var COMPARE_PARTIAL_FLAG2, COMPARE_UNORDERED_FLAG2, boolTag4, dateTag4, errorTag3, mapTag6, numberTag4, regexpTag4, setTag6, stringTag4, symbolTag4, arrayBufferTag4, dataViewTag5, symbolProto3, symbolValueOf2, equalByTag_default;
var init_equalByTag = __esm({
  "node_modules/lodash-es/_equalByTag.js"() {
    init_Symbol();
    init_Uint8Array();
    init_eq();
    init_equalArrays();
    init_mapToArray();
    init_setToArray();
    COMPARE_PARTIAL_FLAG2 = 1;
    COMPARE_UNORDERED_FLAG2 = 2;
    boolTag4 = "[object Boolean]";
    dateTag4 = "[object Date]";
    errorTag3 = "[object Error]";
    mapTag6 = "[object Map]";
    numberTag4 = "[object Number]";
    regexpTag4 = "[object RegExp]";
    setTag6 = "[object Set]";
    stringTag4 = "[object String]";
    symbolTag4 = "[object Symbol]";
    arrayBufferTag4 = "[object ArrayBuffer]";
    dataViewTag5 = "[object DataView]";
    symbolProto3 = Symbol_default ? Symbol_default.prototype : void 0;
    symbolValueOf2 = symbolProto3 ? symbolProto3.valueOf : void 0;
    equalByTag_default = equalByTag;
  }
});

// node_modules/lodash-es/_equalObjects.js
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty12.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var COMPARE_PARTIAL_FLAG3, objectProto15, hasOwnProperty12, equalObjects_default;
var init_equalObjects = __esm({
  "node_modules/lodash-es/_equalObjects.js"() {
    init_getAllKeys();
    COMPARE_PARTIAL_FLAG3 = 1;
    objectProto15 = Object.prototype;
    hasOwnProperty12 = objectProto15.hasOwnProperty;
    equalObjects_default = equalObjects;
  }
});

// node_modules/lodash-es/_baseIsEqualDeep.js
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag3 : getTag_default(object), othTag = othIsArr ? arrayTag3 : getTag_default(other);
  objTag = objTag == argsTag4 ? objectTag4 : objTag;
  othTag = othTag == argsTag4 ? objectTag4 : othTag;
  var objIsObj = objTag == objectTag4, othIsObj = othTag == objectTag4, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_default(object)) {
    if (!isBuffer_default(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack_default());
    return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
    var objIsWrapped = objIsObj && hasOwnProperty13.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty13.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack_default());
  return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
}
var COMPARE_PARTIAL_FLAG4, argsTag4, arrayTag3, objectTag4, objectProto16, hasOwnProperty13, baseIsEqualDeep_default;
var init_baseIsEqualDeep = __esm({
  "node_modules/lodash-es/_baseIsEqualDeep.js"() {
    init_Stack();
    init_equalArrays();
    init_equalByTag();
    init_equalObjects();
    init_getTag();
    init_isArray();
    init_isBuffer();
    init_isTypedArray();
    COMPARE_PARTIAL_FLAG4 = 1;
    argsTag4 = "[object Arguments]";
    arrayTag3 = "[object Array]";
    objectTag4 = "[object Object]";
    objectProto16 = Object.prototype;
    hasOwnProperty13 = objectProto16.hasOwnProperty;
    baseIsEqualDeep_default = baseIsEqualDeep;
  }
});

// node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
}
var baseIsEqual_default;
var init_baseIsEqual = __esm({
  "node_modules/lodash-es/_baseIsEqual.js"() {
    init_baseIsEqualDeep();
    init_isObjectLike();
    baseIsEqual_default = baseIsEqual;
  }
});

// node_modules/lodash-es/_baseIsMatch.js
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length, length = index, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack_default();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var COMPARE_PARTIAL_FLAG5, COMPARE_UNORDERED_FLAG3, baseIsMatch_default;
var init_baseIsMatch = __esm({
  "node_modules/lodash-es/_baseIsMatch.js"() {
    init_Stack();
    init_baseIsEqual();
    COMPARE_PARTIAL_FLAG5 = 1;
    COMPARE_UNORDERED_FLAG3 = 2;
    baseIsMatch_default = baseIsMatch;
  }
});

// node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable(value) {
  return value === value && !isObject_default(value);
}
var isStrictComparable_default;
var init_isStrictComparable = __esm({
  "node_modules/lodash-es/_isStrictComparable.js"() {
    init_isObject();
    isStrictComparable_default = isStrictComparable;
  }
});

// node_modules/lodash-es/_getMatchData.js
function getMatchData(object) {
  var result = keys_default(object), length = result.length;
  while (length--) {
    var key = result[length], value = object[key];
    result[length] = [key, value, isStrictComparable_default(value)];
  }
  return result;
}
var getMatchData_default;
var init_getMatchData = __esm({
  "node_modules/lodash-es/_getMatchData.js"() {
    init_isStrictComparable();
    init_keys();
    getMatchData_default = getMatchData;
  }
});

// node_modules/lodash-es/_matchesStrictComparable.js
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var matchesStrictComparable_default;
var init_matchesStrictComparable = __esm({
  "node_modules/lodash-es/_matchesStrictComparable.js"() {
    matchesStrictComparable_default = matchesStrictComparable;
  }
});

// node_modules/lodash-es/_baseMatches.js
function baseMatches(source) {
  var matchData = getMatchData_default(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch_default(object, source, matchData);
  };
}
var baseMatches_default;
var init_baseMatches = __esm({
  "node_modules/lodash-es/_baseMatches.js"() {
    init_baseIsMatch();
    init_getMatchData();
    init_matchesStrictComparable();
    baseMatches_default = baseMatches;
  }
});

// node_modules/lodash-es/_baseHasIn.js
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
var baseHasIn_default;
var init_baseHasIn = __esm({
  "node_modules/lodash-es/_baseHasIn.js"() {
    baseHasIn_default = baseHasIn;
  }
});

// node_modules/lodash-es/_hasPath.js
function hasPath(object, path4, hasFunc) {
  path4 = castPath_default(path4, object);
  var index = -1, length = path4.length, result = false;
  while (++index < length) {
    var key = toKey_default(path4[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength_default(length) && isIndex_default(key, length) && (isArray_default(object) || isArguments_default(object));
}
var hasPath_default;
var init_hasPath = __esm({
  "node_modules/lodash-es/_hasPath.js"() {
    init_castPath();
    init_isArguments();
    init_isArray();
    init_isIndex();
    init_isLength();
    init_toKey();
    hasPath_default = hasPath;
  }
});

// node_modules/lodash-es/hasIn.js
function hasIn(object, path4) {
  return object != null && hasPath_default(object, path4, baseHasIn_default);
}
var hasIn_default;
var init_hasIn = __esm({
  "node_modules/lodash-es/hasIn.js"() {
    init_baseHasIn();
    init_hasPath();
    hasIn_default = hasIn;
  }
});

// node_modules/lodash-es/_baseMatchesProperty.js
function baseMatchesProperty(path4, srcValue) {
  if (isKey_default(path4) && isStrictComparable_default(srcValue)) {
    return matchesStrictComparable_default(toKey_default(path4), srcValue);
  }
  return function(object) {
    var objValue = get_default(object, path4);
    return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path4) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
  };
}
var COMPARE_PARTIAL_FLAG6, COMPARE_UNORDERED_FLAG4, baseMatchesProperty_default;
var init_baseMatchesProperty = __esm({
  "node_modules/lodash-es/_baseMatchesProperty.js"() {
    init_baseIsEqual();
    init_get();
    init_hasIn();
    init_isKey();
    init_isStrictComparable();
    init_matchesStrictComparable();
    init_toKey();
    COMPARE_PARTIAL_FLAG6 = 1;
    COMPARE_UNORDERED_FLAG4 = 2;
    baseMatchesProperty_default = baseMatchesProperty;
  }
});

// node_modules/lodash-es/_baseProperty.js
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var baseProperty_default;
var init_baseProperty = __esm({
  "node_modules/lodash-es/_baseProperty.js"() {
    baseProperty_default = baseProperty;
  }
});

// node_modules/lodash-es/_basePropertyDeep.js
function basePropertyDeep(path4) {
  return function(object) {
    return baseGet_default(object, path4);
  };
}
var basePropertyDeep_default;
var init_basePropertyDeep = __esm({
  "node_modules/lodash-es/_basePropertyDeep.js"() {
    init_baseGet();
    basePropertyDeep_default = basePropertyDeep;
  }
});

// node_modules/lodash-es/property.js
function property(path4) {
  return isKey_default(path4) ? baseProperty_default(toKey_default(path4)) : basePropertyDeep_default(path4);
}
var property_default;
var init_property = __esm({
  "node_modules/lodash-es/property.js"() {
    init_baseProperty();
    init_basePropertyDeep();
    init_isKey();
    init_toKey();
    property_default = property;
  }
});

// node_modules/lodash-es/_baseIteratee.js
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity_default;
  }
  if (typeof value == "object") {
    return isArray_default(value) ? baseMatchesProperty_default(value[0], value[1]) : baseMatches_default(value);
  }
  return property_default(value);
}
var baseIteratee_default;
var init_baseIteratee = __esm({
  "node_modules/lodash-es/_baseIteratee.js"() {
    init_baseMatches();
    init_baseMatchesProperty();
    init_identity();
    init_isArray();
    init_property();
    baseIteratee_default = baseIteratee;
  }
});

// node_modules/lodash-es/_arrayAggregator.js
function arrayAggregator(array, setter, iteratee, accumulator) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    var value = array[index];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}
var arrayAggregator_default;
var init_arrayAggregator = __esm({
  "node_modules/lodash-es/_arrayAggregator.js"() {
    arrayAggregator_default = arrayAggregator;
  }
});

// node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var createBaseFor_default;
var init_createBaseFor = __esm({
  "node_modules/lodash-es/_createBaseFor.js"() {
    createBaseFor_default = createBaseFor;
  }
});

// node_modules/lodash-es/_baseFor.js
var baseFor, baseFor_default;
var init_baseFor = __esm({
  "node_modules/lodash-es/_baseFor.js"() {
    init_createBaseFor();
    baseFor = createBaseFor_default();
    baseFor_default = baseFor;
  }
});

// node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object, iteratee) {
  return object && baseFor_default(object, iteratee, keys_default);
}
var baseForOwn_default;
var init_baseForOwn = __esm({
  "node_modules/lodash-es/_baseForOwn.js"() {
    init_baseFor();
    init_keys();
    baseForOwn_default = baseForOwn;
  }
});

// node_modules/lodash-es/_createBaseEach.js
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_default(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var createBaseEach_default;
var init_createBaseEach = __esm({
  "node_modules/lodash-es/_createBaseEach.js"() {
    init_isArrayLike();
    createBaseEach_default = createBaseEach;
  }
});

// node_modules/lodash-es/_baseEach.js
var baseEach, baseEach_default;
var init_baseEach = __esm({
  "node_modules/lodash-es/_baseEach.js"() {
    init_baseForOwn();
    init_createBaseEach();
    baseEach = createBaseEach_default(baseForOwn_default);
    baseEach_default = baseEach;
  }
});

// node_modules/lodash-es/_baseAggregator.js
function baseAggregator(collection, setter, iteratee, accumulator) {
  baseEach_default(collection, function(value, key, collection2) {
    setter(accumulator, value, iteratee(value), collection2);
  });
  return accumulator;
}
var baseAggregator_default;
var init_baseAggregator = __esm({
  "node_modules/lodash-es/_baseAggregator.js"() {
    init_baseEach();
    baseAggregator_default = baseAggregator;
  }
});

// node_modules/lodash-es/_createAggregator.js
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray_default(collection) ? arrayAggregator_default : baseAggregator_default, accumulator = initializer ? initializer() : {};
    return func(collection, setter, baseIteratee_default(iteratee, 2), accumulator);
  };
}
var createAggregator_default;
var init_createAggregator = __esm({
  "node_modules/lodash-es/_createAggregator.js"() {
    init_arrayAggregator();
    init_baseAggregator();
    init_baseIteratee();
    init_isArray();
    createAggregator_default = createAggregator;
  }
});

// node_modules/lodash-es/defaults.js
var objectProto17, hasOwnProperty14, defaults, defaults_default;
var init_defaults = __esm({
  "node_modules/lodash-es/defaults.js"() {
    init_baseRest();
    init_eq();
    init_isIterateeCall();
    init_keysIn();
    objectProto17 = Object.prototype;
    hasOwnProperty14 = objectProto17.hasOwnProperty;
    defaults = baseRest_default(function(object, sources) {
      object = Object(object);
      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : void 0;
      if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
        length = 1;
      }
      while (++index < length) {
        var source = sources[index];
        var props = keysIn_default(source);
        var propsIndex = -1;
        var propsLength = props.length;
        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];
          if (value === void 0 || eq_default(value, objectProto17[key]) && !hasOwnProperty14.call(object, key)) {
            object[key] = source[key];
          }
        }
      }
      return object;
    });
    defaults_default = defaults;
  }
});

// node_modules/lodash-es/isArrayLikeObject.js
function isArrayLikeObject(value) {
  return isObjectLike_default(value) && isArrayLike_default(value);
}
var isArrayLikeObject_default;
var init_isArrayLikeObject = __esm({
  "node_modules/lodash-es/isArrayLikeObject.js"() {
    init_isArrayLike();
    init_isObjectLike();
    isArrayLikeObject_default = isArrayLikeObject;
  }
});

// node_modules/lodash-es/_arrayIncludesWith.js
function arrayIncludesWith(array, value, comparator) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}
var arrayIncludesWith_default;
var init_arrayIncludesWith = __esm({
  "node_modules/lodash-es/_arrayIncludesWith.js"() {
    arrayIncludesWith_default = arrayIncludesWith;
  }
});

// node_modules/lodash-es/_baseDifference.js
function baseDifference(array, values2, iteratee, comparator) {
  var index = -1, includes2 = arrayIncludes_default, isCommon = true, length = array.length, result = [], valuesLength = values2.length;
  if (!length) {
    return result;
  }
  if (iteratee) {
    values2 = arrayMap_default(values2, baseUnary_default(iteratee));
  }
  if (comparator) {
    includes2 = arrayIncludesWith_default;
    isCommon = false;
  } else if (values2.length >= LARGE_ARRAY_SIZE2) {
    includes2 = cacheHas_default;
    isCommon = false;
    values2 = new SetCache_default(values2);
  }
  outer:
    while (++index < length) {
      var value = array[index], computed = iteratee == null ? value : iteratee(value);
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var valuesIndex = valuesLength;
        while (valuesIndex--) {
          if (values2[valuesIndex] === computed) {
            continue outer;
          }
        }
        result.push(value);
      } else if (!includes2(values2, computed, comparator)) {
        result.push(value);
      }
    }
  return result;
}
var LARGE_ARRAY_SIZE2, baseDifference_default;
var init_baseDifference = __esm({
  "node_modules/lodash-es/_baseDifference.js"() {
    init_SetCache();
    init_arrayIncludes();
    init_arrayIncludesWith();
    init_arrayMap();
    init_baseUnary();
    init_cacheHas();
    LARGE_ARRAY_SIZE2 = 200;
    baseDifference_default = baseDifference;
  }
});

// node_modules/lodash-es/difference.js
var difference, difference_default;
var init_difference = __esm({
  "node_modules/lodash-es/difference.js"() {
    init_baseDifference();
    init_baseFlatten();
    init_baseRest();
    init_isArrayLikeObject();
    difference = baseRest_default(function(array, values2) {
      return isArrayLikeObject_default(array) ? baseDifference_default(array, baseFlatten_default(values2, 1, isArrayLikeObject_default, true)) : [];
    });
    difference_default = difference;
  }
});

// node_modules/lodash-es/last.js
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
var last_default;
var init_last = __esm({
  "node_modules/lodash-es/last.js"() {
    last_default = last;
  }
});

// node_modules/lodash-es/drop.js
function drop(array, n, guard) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  return baseSlice_default(array, n < 0 ? 0 : n, length);
}
var drop_default;
var init_drop = __esm({
  "node_modules/lodash-es/drop.js"() {
    init_baseSlice();
    init_toInteger();
    drop_default = drop;
  }
});

// node_modules/lodash-es/dropRight.js
function dropRight(array, n, guard) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  n = length - n;
  return baseSlice_default(array, 0, n < 0 ? 0 : n);
}
var dropRight_default;
var init_dropRight = __esm({
  "node_modules/lodash-es/dropRight.js"() {
    init_baseSlice();
    init_toInteger();
    dropRight_default = dropRight;
  }
});

// node_modules/lodash-es/_castFunction.js
function castFunction(value) {
  return typeof value == "function" ? value : identity_default;
}
var castFunction_default;
var init_castFunction = __esm({
  "node_modules/lodash-es/_castFunction.js"() {
    init_identity();
    castFunction_default = castFunction;
  }
});

// node_modules/lodash-es/forEach.js
function forEach(collection, iteratee) {
  var func = isArray_default(collection) ? arrayEach_default : baseEach_default;
  return func(collection, castFunction_default(iteratee));
}
var forEach_default;
var init_forEach = __esm({
  "node_modules/lodash-es/forEach.js"() {
    init_arrayEach();
    init_baseEach();
    init_castFunction();
    init_isArray();
    forEach_default = forEach;
  }
});

// node_modules/lodash-es/_arrayEvery.js
function arrayEvery(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (!predicate(array[index], index, array)) {
      return false;
    }
  }
  return true;
}
var arrayEvery_default;
var init_arrayEvery = __esm({
  "node_modules/lodash-es/_arrayEvery.js"() {
    arrayEvery_default = arrayEvery;
  }
});

// node_modules/lodash-es/_baseEvery.js
function baseEvery(collection, predicate) {
  var result = true;
  baseEach_default(collection, function(value, index, collection2) {
    result = !!predicate(value, index, collection2);
    return result;
  });
  return result;
}
var baseEvery_default;
var init_baseEvery = __esm({
  "node_modules/lodash-es/_baseEvery.js"() {
    init_baseEach();
    baseEvery_default = baseEvery;
  }
});

// node_modules/lodash-es/every.js
function every(collection, predicate, guard) {
  var func = isArray_default(collection) ? arrayEvery_default : baseEvery_default;
  if (guard && isIterateeCall_default(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee_default(predicate, 3));
}
var every_default;
var init_every = __esm({
  "node_modules/lodash-es/every.js"() {
    init_arrayEvery();
    init_baseEvery();
    init_baseIteratee();
    init_isArray();
    init_isIterateeCall();
    every_default = every;
  }
});

// node_modules/lodash-es/_baseFilter.js
function baseFilter(collection, predicate) {
  var result = [];
  baseEach_default(collection, function(value, index, collection2) {
    if (predicate(value, index, collection2)) {
      result.push(value);
    }
  });
  return result;
}
var baseFilter_default;
var init_baseFilter = __esm({
  "node_modules/lodash-es/_baseFilter.js"() {
    init_baseEach();
    baseFilter_default = baseFilter;
  }
});

// node_modules/lodash-es/filter.js
function filter(collection, predicate) {
  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
  return func(collection, baseIteratee_default(predicate, 3));
}
var filter_default;
var init_filter = __esm({
  "node_modules/lodash-es/filter.js"() {
    init_arrayFilter();
    init_baseFilter();
    init_baseIteratee();
    init_isArray();
    filter_default = filter;
  }
});

// node_modules/lodash-es/_createFind.js
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike_default(collection)) {
      var iteratee = baseIteratee_default(predicate, 3);
      collection = keys_default(collection);
      predicate = function(key) {
        return iteratee(iterable[key], key, iterable);
      };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;
  };
}
var createFind_default;
var init_createFind = __esm({
  "node_modules/lodash-es/_createFind.js"() {
    init_baseIteratee();
    init_isArrayLike();
    init_keys();
    createFind_default = createFind;
  }
});

// node_modules/lodash-es/findIndex.js
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger_default(fromIndex);
  if (index < 0) {
    index = nativeMax2(length + index, 0);
  }
  return baseFindIndex_default(array, baseIteratee_default(predicate, 3), index);
}
var nativeMax2, findIndex_default;
var init_findIndex = __esm({
  "node_modules/lodash-es/findIndex.js"() {
    init_baseFindIndex();
    init_baseIteratee();
    init_toInteger();
    nativeMax2 = Math.max;
    findIndex_default = findIndex;
  }
});

// node_modules/lodash-es/find.js
var find, find_default;
var init_find = __esm({
  "node_modules/lodash-es/find.js"() {
    init_createFind();
    init_findIndex();
    find = createFind_default(findIndex_default);
    find_default = find;
  }
});

// node_modules/lodash-es/head.js
function head(array) {
  return array && array.length ? array[0] : void 0;
}
var head_default;
var init_head = __esm({
  "node_modules/lodash-es/head.js"() {
    head_default = head;
  }
});

// node_modules/lodash-es/first.js
var init_first = __esm({
  "node_modules/lodash-es/first.js"() {
    init_head();
  }
});

// node_modules/lodash-es/_baseMap.js
function baseMap(collection, iteratee) {
  var index = -1, result = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value, key, collection2) {
    result[++index] = iteratee(value, key, collection2);
  });
  return result;
}
var baseMap_default;
var init_baseMap = __esm({
  "node_modules/lodash-es/_baseMap.js"() {
    init_baseEach();
    init_isArrayLike();
    baseMap_default = baseMap;
  }
});

// node_modules/lodash-es/map.js
function map(collection, iteratee) {
  var func = isArray_default(collection) ? arrayMap_default : baseMap_default;
  return func(collection, baseIteratee_default(iteratee, 3));
}
var map_default;
var init_map = __esm({
  "node_modules/lodash-es/map.js"() {
    init_arrayMap();
    init_baseIteratee();
    init_baseMap();
    init_isArray();
    map_default = map;
  }
});

// node_modules/lodash-es/flatMap.js
function flatMap(collection, iteratee) {
  return baseFlatten_default(map_default(collection, iteratee), 1);
}
var flatMap_default;
var init_flatMap = __esm({
  "node_modules/lodash-es/flatMap.js"() {
    init_baseFlatten();
    init_map();
    flatMap_default = flatMap;
  }
});

// node_modules/lodash-es/groupBy.js
var objectProto18, hasOwnProperty15, groupBy, groupBy_default;
var init_groupBy = __esm({
  "node_modules/lodash-es/groupBy.js"() {
    init_baseAssignValue();
    init_createAggregator();
    objectProto18 = Object.prototype;
    hasOwnProperty15 = objectProto18.hasOwnProperty;
    groupBy = createAggregator_default(function(result, value, key) {
      if (hasOwnProperty15.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue_default(result, key, [value]);
      }
    });
    groupBy_default = groupBy;
  }
});

// node_modules/lodash-es/_baseHas.js
function baseHas(object, key) {
  return object != null && hasOwnProperty16.call(object, key);
}
var objectProto19, hasOwnProperty16, baseHas_default;
var init_baseHas = __esm({
  "node_modules/lodash-es/_baseHas.js"() {
    objectProto19 = Object.prototype;
    hasOwnProperty16 = objectProto19.hasOwnProperty;
    baseHas_default = baseHas;
  }
});

// node_modules/lodash-es/has.js
function has(object, path4) {
  return object != null && hasPath_default(object, path4, baseHas_default);
}
var has_default;
var init_has = __esm({
  "node_modules/lodash-es/has.js"() {
    init_baseHas();
    init_hasPath();
    has_default = has;
  }
});

// node_modules/lodash-es/isString.js
function isString(value) {
  return typeof value == "string" || !isArray_default(value) && isObjectLike_default(value) && baseGetTag_default(value) == stringTag5;
}
var stringTag5, isString_default;
var init_isString = __esm({
  "node_modules/lodash-es/isString.js"() {
    init_baseGetTag();
    init_isArray();
    init_isObjectLike();
    stringTag5 = "[object String]";
    isString_default = isString;
  }
});

// node_modules/lodash-es/_baseValues.js
function baseValues(object, props) {
  return arrayMap_default(props, function(key) {
    return object[key];
  });
}
var baseValues_default;
var init_baseValues = __esm({
  "node_modules/lodash-es/_baseValues.js"() {
    init_arrayMap();
    baseValues_default = baseValues;
  }
});

// node_modules/lodash-es/values.js
function values(object) {
  return object == null ? [] : baseValues_default(object, keys_default(object));
}
var values_default;
var init_values = __esm({
  "node_modules/lodash-es/values.js"() {
    init_baseValues();
    init_keys();
    values_default = values;
  }
});

// node_modules/lodash-es/includes.js
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike_default(collection) ? collection : values_default(collection);
  fromIndex = fromIndex && !guard ? toInteger_default(fromIndex) : 0;
  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax3(length + fromIndex, 0);
  }
  return isString_default(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf_default(collection, value, fromIndex) > -1;
}
var nativeMax3, includes_default;
var init_includes = __esm({
  "node_modules/lodash-es/includes.js"() {
    init_baseIndexOf();
    init_isArrayLike();
    init_isString();
    init_toInteger();
    init_values();
    nativeMax3 = Math.max;
    includes_default = includes;
  }
});

// node_modules/lodash-es/indexOf.js
function indexOf(array, value, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger_default(fromIndex);
  if (index < 0) {
    index = nativeMax4(length + index, 0);
  }
  return baseIndexOf_default(array, value, index);
}
var nativeMax4, indexOf_default;
var init_indexOf = __esm({
  "node_modules/lodash-es/indexOf.js"() {
    init_baseIndexOf();
    init_toInteger();
    nativeMax4 = Math.max;
    indexOf_default = indexOf;
  }
});

// node_modules/lodash-es/isEmpty.js
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike_default(value) && (isArray_default(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer_default(value) || isTypedArray_default(value) || isArguments_default(value))) {
    return !value.length;
  }
  var tag = getTag_default(value);
  if (tag == mapTag7 || tag == setTag7) {
    return !value.size;
  }
  if (isPrototype_default(value)) {
    return !baseKeys_default(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty17.call(value, key)) {
      return false;
    }
  }
  return true;
}
var mapTag7, setTag7, objectProto20, hasOwnProperty17, isEmpty_default;
var init_isEmpty = __esm({
  "node_modules/lodash-es/isEmpty.js"() {
    init_baseKeys();
    init_getTag();
    init_isArguments();
    init_isArray();
    init_isArrayLike();
    init_isBuffer();
    init_isPrototype();
    init_isTypedArray();
    mapTag7 = "[object Map]";
    setTag7 = "[object Set]";
    objectProto20 = Object.prototype;
    hasOwnProperty17 = objectProto20.hasOwnProperty;
    isEmpty_default = isEmpty;
  }
});

// node_modules/lodash-es/isEqual.js
function isEqual(value, other) {
  return baseIsEqual_default(value, other);
}
var isEqual_default;
var init_isEqual = __esm({
  "node_modules/lodash-es/isEqual.js"() {
    init_baseIsEqual();
    isEqual_default = isEqual;
  }
});

// node_modules/lodash-es/_baseIsRegExp.js
function baseIsRegExp(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == regexpTag5;
}
var regexpTag5, baseIsRegExp_default;
var init_baseIsRegExp = __esm({
  "node_modules/lodash-es/_baseIsRegExp.js"() {
    init_baseGetTag();
    init_isObjectLike();
    regexpTag5 = "[object RegExp]";
    baseIsRegExp_default = baseIsRegExp;
  }
});

// node_modules/lodash-es/isRegExp.js
var nodeIsRegExp, isRegExp, isRegExp_default;
var init_isRegExp = __esm({
  "node_modules/lodash-es/isRegExp.js"() {
    init_baseIsRegExp();
    init_baseUnary();
    init_nodeUtil();
    nodeIsRegExp = nodeUtil_default && nodeUtil_default.isRegExp;
    isRegExp = nodeIsRegExp ? baseUnary_default(nodeIsRegExp) : baseIsRegExp_default;
    isRegExp_default = isRegExp;
  }
});

// node_modules/lodash-es/isUndefined.js
function isUndefined(value) {
  return value === void 0;
}
var isUndefined_default;
var init_isUndefined = __esm({
  "node_modules/lodash-es/isUndefined.js"() {
    isUndefined_default = isUndefined;
  }
});

// node_modules/lodash-es/kebabCase.js
var kebabCase, kebabCase_default;
var init_kebabCase = __esm({
  "node_modules/lodash-es/kebabCase.js"() {
    init_createCompounder();
    kebabCase = createCompounder_default(function(result, word, index) {
      return result + (index ? "-" : "") + word.toLowerCase();
    });
    kebabCase_default = kebabCase;
  }
});

// node_modules/lodash-es/lowerFirst.js
var lowerFirst, lowerFirst_default;
var init_lowerFirst = __esm({
  "node_modules/lodash-es/lowerFirst.js"() {
    init_createCaseFirst();
    lowerFirst = createCaseFirst_default("toLowerCase");
    lowerFirst_default = lowerFirst;
  }
});

// node_modules/lodash-es/negate.js
function negate(predicate) {
  if (typeof predicate != "function") {
    throw new TypeError(FUNC_ERROR_TEXT2);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return !predicate.call(this);
      case 1:
        return !predicate.call(this, args[0]);
      case 2:
        return !predicate.call(this, args[0], args[1]);
      case 3:
        return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}
var FUNC_ERROR_TEXT2, negate_default;
var init_negate = __esm({
  "node_modules/lodash-es/negate.js"() {
    FUNC_ERROR_TEXT2 = "Expected a function";
    negate_default = negate;
  }
});

// node_modules/lodash-es/_baseSet.js
function baseSet(object, path4, value, customizer) {
  if (!isObject_default(object)) {
    return object;
  }
  path4 = castPath_default(path4, object);
  var index = -1, length = path4.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index < length) {
    var key = toKey_default(path4[index]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject_default(objValue) ? objValue : isIndex_default(path4[index + 1]) ? [] : {};
      }
    }
    assignValue_default(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var baseSet_default;
var init_baseSet = __esm({
  "node_modules/lodash-es/_baseSet.js"() {
    init_assignValue();
    init_castPath();
    init_isIndex();
    init_isObject();
    init_toKey();
    baseSet_default = baseSet;
  }
});

// node_modules/lodash-es/_basePickBy.js
function basePickBy(object, paths, predicate) {
  var index = -1, length = paths.length, result = {};
  while (++index < length) {
    var path4 = paths[index], value = baseGet_default(object, path4);
    if (predicate(value, path4)) {
      baseSet_default(result, castPath_default(path4, object), value);
    }
  }
  return result;
}
var basePickBy_default;
var init_basePickBy = __esm({
  "node_modules/lodash-es/_basePickBy.js"() {
    init_baseGet();
    init_baseSet();
    init_castPath();
    basePickBy_default = basePickBy;
  }
});

// node_modules/lodash-es/pickBy.js
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap_default(getAllKeysIn_default(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee_default(predicate);
  return basePickBy_default(object, props, function(value, path4) {
    return predicate(value, path4[0]);
  });
}
var pickBy_default;
var init_pickBy = __esm({
  "node_modules/lodash-es/pickBy.js"() {
    init_arrayMap();
    init_baseIteratee();
    init_basePickBy();
    init_getAllKeysIn();
    pickBy_default = pickBy;
  }
});

// node_modules/lodash-es/_baseReduce.js
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index, collection2) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
  });
  return accumulator;
}
var baseReduce_default;
var init_baseReduce = __esm({
  "node_modules/lodash-es/_baseReduce.js"() {
    baseReduce_default = baseReduce;
  }
});

// node_modules/lodash-es/reduce.js
function reduce(collection, iteratee, accumulator) {
  var func = isArray_default(collection) ? arrayReduce_default : baseReduce_default, initAccum = arguments.length < 3;
  return func(collection, baseIteratee_default(iteratee, 4), accumulator, initAccum, baseEach_default);
}
var reduce_default;
var init_reduce = __esm({
  "node_modules/lodash-es/reduce.js"() {
    init_arrayReduce();
    init_baseEach();
    init_baseIteratee();
    init_baseReduce();
    init_isArray();
    reduce_default = reduce;
  }
});

// node_modules/lodash-es/reject.js
function reject(collection, predicate) {
  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
  return func(collection, negate_default(baseIteratee_default(predicate, 3)));
}
var reject_default;
var init_reject = __esm({
  "node_modules/lodash-es/reject.js"() {
    init_arrayFilter();
    init_baseFilter();
    init_baseIteratee();
    init_isArray();
    init_negate();
    reject_default = reject;
  }
});

// node_modules/lodash-es/snakeCase.js
var snakeCase, snakeCase_default;
var init_snakeCase = __esm({
  "node_modules/lodash-es/snakeCase.js"() {
    init_createCompounder();
    snakeCase = createCompounder_default(function(result, word, index) {
      return result + (index ? "_" : "") + word.toLowerCase();
    });
    snakeCase_default = snakeCase;
  }
});

// node_modules/lodash-es/_baseSome.js
function baseSome(collection, predicate) {
  var result;
  baseEach_default(collection, function(value, index, collection2) {
    result = predicate(value, index, collection2);
    return !result;
  });
  return !!result;
}
var baseSome_default;
var init_baseSome = __esm({
  "node_modules/lodash-es/_baseSome.js"() {
    init_baseEach();
    baseSome_default = baseSome;
  }
});

// node_modules/lodash-es/some.js
function some(collection, predicate, guard) {
  var func = isArray_default(collection) ? arraySome_default : baseSome_default;
  if (guard && isIterateeCall_default(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee_default(predicate, 3));
}
var some_default;
var init_some = __esm({
  "node_modules/lodash-es/some.js"() {
    init_arraySome();
    init_baseIteratee();
    init_baseSome();
    init_isArray();
    init_isIterateeCall();
    some_default = some;
  }
});

// node_modules/lodash-es/_createSet.js
var INFINITY4, createSet, createSet_default;
var init_createSet = __esm({
  "node_modules/lodash-es/_createSet.js"() {
    init_Set();
    init_noop();
    init_setToArray();
    INFINITY4 = 1 / 0;
    createSet = !(Set_default && 1 / setToArray_default(new Set_default([, -0]))[1] == INFINITY4) ? noop_default : function(values2) {
      return new Set_default(values2);
    };
    createSet_default = createSet;
  }
});

// node_modules/lodash-es/_baseUniq.js
function baseUniq(array, iteratee, comparator) {
  var index = -1, includes2 = arrayIncludes_default, length = array.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes2 = arrayIncludesWith_default;
  } else if (length >= LARGE_ARRAY_SIZE3) {
    var set = iteratee ? null : createSet_default(array);
    if (set) {
      return setToArray_default(set);
    }
    isCommon = false;
    includes2 = cacheHas_default;
    seen = new SetCache_default();
  } else {
    seen = iteratee ? [] : result;
  }
  outer:
    while (++index < length) {
      var value = array[index], computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed);
        }
        result.push(value);
      } else if (!includes2(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
  return result;
}
var LARGE_ARRAY_SIZE3, baseUniq_default;
var init_baseUniq = __esm({
  "node_modules/lodash-es/_baseUniq.js"() {
    init_SetCache();
    init_arrayIncludes();
    init_arrayIncludesWith();
    init_cacheHas();
    init_createSet();
    init_setToArray();
    LARGE_ARRAY_SIZE3 = 200;
    baseUniq_default = baseUniq;
  }
});

// node_modules/lodash-es/uniq.js
function uniq(array) {
  return array && array.length ? baseUniq_default(array) : [];
}
var uniq_default;
var init_uniq = __esm({
  "node_modules/lodash-es/uniq.js"() {
    init_baseUniq();
    uniq_default = uniq;
  }
});

// node_modules/lodash-es/uniqBy.js
function uniqBy(array, iteratee) {
  return array && array.length ? baseUniq_default(array, baseIteratee_default(iteratee, 2)) : [];
}
var uniqBy_default;
var init_uniqBy = __esm({
  "node_modules/lodash-es/uniqBy.js"() {
    init_baseIteratee();
    init_baseUniq();
    uniqBy_default = uniqBy;
  }
});

// node_modules/lodash-es/upperCase.js
var upperCase, upperCase_default;
var init_upperCase = __esm({
  "node_modules/lodash-es/upperCase.js"() {
    init_createCompounder();
    upperCase = createCompounder_default(function(result, word, index) {
      return result + (index ? " " : "") + word.toUpperCase();
    });
    upperCase_default = upperCase;
  }
});

// node_modules/lodash-es/lodash.js
var init_lodash = __esm({
  "node_modules/lodash-es/lodash.js"() {
    init_assign();
    init_camelCase();
    init_capitalize();
    init_clone();
    init_compact();
    init_defaults();
    init_difference();
    init_drop();
    init_dropRight();
    init_every();
    init_filter();
    init_find();
    init_first();
    init_flatMap();
    init_flatten();
    init_forEach();
    init_groupBy();
    init_has();
    init_identity();
    init_includes();
    init_indexOf();
    init_isArray();
    init_isEmpty();
    init_isEqual();
    init_isFunction();
    init_isObject();
    init_isRegExp();
    init_isString();
    init_isUndefined();
    init_kebabCase();
    init_keys();
    init_last();
    init_lowerFirst();
    init_map();
    init_noop();
    init_pickBy();
    init_reduce();
    init_reject();
    init_snakeCase();
    init_some();
    init_uniq();
    init_uniqBy();
    init_upperCase();
    init_upperFirst();
    init_values();
  }
});

// node_modules/logform/format.js
var require_format = __commonJS({
  "node_modules/logform/format.js"(exports2, module2) {
    "use strict";
    var InvalidFormatError = class _InvalidFormatError extends Error {
      constructor(formatFn) {
        super(`Format functions must be synchronous taking a two arguments: (info, opts)
Found: ${formatFn.toString().split("\n")[0]}
`);
        Error.captureStackTrace(this, _InvalidFormatError);
      }
    };
    module2.exports = (formatFn) => {
      if (formatFn.length > 2) {
        throw new InvalidFormatError(formatFn);
      }
      function Format(options = {}) {
        this.options = options;
      }
      Format.prototype.transform = formatFn;
      function createFormatWrap(opts) {
        return new Format(opts);
      }
      createFormatWrap.Format = Format;
      return createFormatWrap;
    };
  }
});

// node_modules/@colors/colors/lib/styles.js
var require_styles = __commonJS({
  "node_modules/@colors/colors/lib/styles.js"(exports2, module2) {
    var styles = {};
    module2["exports"] = styles;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      brightRed: [91, 39],
      brightGreen: [92, 39],
      brightYellow: [93, 39],
      brightBlue: [94, 39],
      brightMagenta: [95, 39],
      brightCyan: [96, 39],
      brightWhite: [97, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      bgGray: [100, 49],
      bgGrey: [100, 49],
      bgBrightRed: [101, 49],
      bgBrightGreen: [102, 49],
      bgBrightYellow: [103, 49],
      bgBrightBlue: [104, 49],
      bgBrightMagenta: [105, 49],
      bgBrightCyan: [106, 49],
      bgBrightWhite: [107, 49],
      // legacy styles for colors pre v1.0.0
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles[key] = [];
      style.open = "\x1B[" + val[0] + "m";
      style.close = "\x1B[" + val[1] + "m";
    });
  }
});

// node_modules/@colors/colors/lib/system/has-flag.js
var require_has_flag = __commonJS({
  "node_modules/@colors/colors/lib/system/has-flag.js"(exports2, module2) {
    "use strict";
    module2.exports = function(flag, argv) {
      argv = argv || process.argv || [];
      var terminatorPos = argv.indexOf("--");
      var prefix = /^-{1,2}/.test(flag) ? "" : "--";
      var pos = argv.indexOf(prefix + flag);
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/@colors/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS({
  "node_modules/@colors/colors/lib/system/supports-colors.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor = void 0;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      var min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        var osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
          return sign in env;
        }) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if ("TERM_PROGRAM" in env) {
        var version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Hyper":
            return 3;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      var level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/@colors/colors/lib/custom/trap.js
var require_trap = __commonJS({
  "node_modules/@colors/colors/lib/custom/trap.js"(exports2, module2) {
    module2["exports"] = function runTheTrap(text, options) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: [
          "\xCB",
          "\u0115",
          "\u018E",
          "\u0258",
          "\u03A3",
          "\u03BE",
          "\u04BC",
          "\u0A6C"
        ],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: [
          "\xD8",
          "\xF5",
          "\xF8",
          "\u01FE",
          "\u0298",
          "\u047A",
          "\u05DD",
          "\u06DD",
          "\u0E4F"
        ],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    };
  }
});

// node_modules/@colors/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS({
  "node_modules/@colors/colors/lib/custom/zalgo.js"(exports2, module2) {
    module2["exports"] = function zalgo(text, options) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      };
      var all = [].concat(soul.up, soul.down, soul.mid);
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
      function isChar(character) {
        var bool = false;
        all.filter(function(i) {
          bool = i === character;
        });
        return bool;
      }
      function heComes(text2, options2) {
        var result = "";
        var counts;
        var l;
        options2 = options2 || {};
        options2["up"] = typeof options2["up"] !== "undefined" ? options2["up"] : true;
        options2["mid"] = typeof options2["mid"] !== "undefined" ? options2["mid"] : true;
        options2["down"] = typeof options2["down"] !== "undefined" ? options2["down"] : true;
        options2["size"] = typeof options2["size"] !== "undefined" ? options2["size"] : "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (isChar(l)) {
            continue;
          }
          result = result + text2[l];
          counts = { "up": 0, "down": 0, "mid": 0 };
          switch (options2.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.mid = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.mid = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index = arr[d];
            for (var i = 0; i <= counts[index]; i++) {
              if (options2[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      return heComes(text, options);
    };
  }
});

// node_modules/@colors/colors/lib/maps/america.js
var require_america = __commonJS({
  "node_modules/@colors/colors/lib/maps/america.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        if (letter === " ")
          return letter;
        switch (i % 3) {
          case 0:
            return colors.red(letter);
          case 1:
            return colors.white(letter);
          case 2:
            return colors.blue(letter);
        }
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/zebra.js
var require_zebra = __commonJS({
  "node_modules/@colors/colors/lib/maps/zebra.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        return i % 2 === 0 ? letter : colors.inverse(letter);
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS({
  "node_modules/@colors/colors/lib/maps/rainbow.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter, i, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i++ % rainbowColors.length]](letter);
        }
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/random.js
var require_random = __commonJS({
  "node_modules/@colors/colors/lib/maps/random.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      var available = [
        "underline",
        "inverse",
        "grey",
        "yellow",
        "red",
        "green",
        "blue",
        "white",
        "cyan",
        "magenta",
        "brightYellow",
        "brightRed",
        "brightGreen",
        "brightBlue",
        "brightWhite",
        "brightCyan",
        "brightMagenta"
      ];
      return function(letter, i, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
      };
    };
  }
});

// node_modules/@colors/colors/lib/colors.js
var require_colors = __commonJS({
  "node_modules/@colors/colors/lib/colors.js"(exports2, module2) {
    var colors = {};
    module2["exports"] = colors;
    colors.themes = {};
    var util = require("util");
    var ansiStyles = colors.styles = require_styles();
    var defineProps = Object.defineProperties;
    var newLineRegex = new RegExp(/[\r\n]+/g);
    colors.supportsColor = require_supports_colors().supportsColor;
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor() !== false;
    }
    colors.enable = function() {
      colors.enabled = true;
    };
    colors.disable = function() {
      colors.enabled = false;
    };
    colors.stripColors = colors.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    var stylize = colors.stylize = function stylize2(str, style) {
      if (!colors.enabled) {
        return str + "";
      }
      var styleMap = ansiStyles[style];
      if (!styleMap && style in colors) {
        return colors[style](str);
      }
      return styleMap.open + str + styleMap.close;
    };
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
    function build(_styles) {
      var builder = function builder2() {
        return applyStyle.apply(builder2, arguments);
      };
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    var styles = function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    }();
    var proto = defineProps(function colors2() {
    }, styles);
    function applyStyle() {
      var args = Array.prototype.slice.call(arguments);
      var str = args.map(function(arg) {
        if (arg != null && arg.constructor === String) {
          return arg;
        } else {
          return util.inspect(arg);
        }
      }).join(" ");
      if (!colors.enabled || !str) {
        return str;
      }
      var newLinesPresent = str.indexOf("\n") != -1;
      var nestedStyles = this._styles;
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        if (newLinesPresent) {
          str = str.replace(newLineRegex, function(match) {
            return code.close + match + code.open;
          });
        }
      }
      return str;
    }
    colors.setTheme = function(theme) {
      if (typeof theme === "string") {
        console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
        return;
      }
      for (var style in theme) {
        (function(style2) {
          colors[style2] = function(str) {
            if (typeof theme[style2] === "object") {
              var out = str;
              for (var i in theme[style2]) {
                out = colors[theme[style2][i]](out);
              }
              return out;
            }
            return colors[theme[style2]](str);
          };
        })(style);
      }
    };
    function init5() {
      var ret = {};
      Object.keys(styles).forEach(function(name) {
        ret[name] = {
          get: function() {
            return build([name]);
          }
        };
      });
      return ret;
    }
    var sequencer = function sequencer2(map3, str) {
      var exploded = str.split("");
      exploded = exploded.map(map3);
      return exploded.join("");
    };
    colors.trap = require_trap();
    colors.zalgo = require_zalgo();
    colors.maps = {};
    colors.maps.america = require_america()(colors);
    colors.maps.zebra = require_zebra()(colors);
    colors.maps.rainbow = require_rainbow()(colors);
    colors.maps.random = require_random()(colors);
    for (map2 in colors.maps) {
      (function(map3) {
        colors[map3] = function(str) {
          return sequencer(colors.maps[map3], str);
        };
      })(map2);
    }
    var map2;
    defineProps(colors, init5());
  }
});

// node_modules/@colors/colors/safe.js
var require_safe = __commonJS({
  "node_modules/@colors/colors/safe.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = colors;
  }
});

// node_modules/triple-beam/config/cli.js
var require_cli = __commonJS({
  "node_modules/triple-beam/config/cli.js"(exports2) {
    "use strict";
    exports2.levels = {
      error: 0,
      warn: 1,
      help: 2,
      data: 3,
      info: 4,
      debug: 5,
      prompt: 6,
      verbose: 7,
      input: 8,
      silly: 9
    };
    exports2.colors = {
      error: "red",
      warn: "yellow",
      help: "cyan",
      data: "grey",
      info: "green",
      debug: "blue",
      prompt: "grey",
      verbose: "cyan",
      input: "grey",
      silly: "magenta"
    };
  }
});

// node_modules/triple-beam/config/npm.js
var require_npm = __commonJS({
  "node_modules/triple-beam/config/npm.js"(exports2) {
    "use strict";
    exports2.levels = {
      error: 0,
      warn: 1,
      info: 2,
      http: 3,
      verbose: 4,
      debug: 5,
      silly: 6
    };
    exports2.colors = {
      error: "red",
      warn: "yellow",
      info: "green",
      http: "green",
      verbose: "cyan",
      debug: "blue",
      silly: "magenta"
    };
  }
});

// node_modules/triple-beam/config/syslog.js
var require_syslog = __commonJS({
  "node_modules/triple-beam/config/syslog.js"(exports2) {
    "use strict";
    exports2.levels = {
      emerg: 0,
      alert: 1,
      crit: 2,
      error: 3,
      warning: 4,
      notice: 5,
      info: 6,
      debug: 7
    };
    exports2.colors = {
      emerg: "red",
      alert: "yellow",
      crit: "red",
      error: "red",
      warning: "red",
      notice: "yellow",
      info: "green",
      debug: "blue"
    };
  }
});

// node_modules/triple-beam/config/index.js
var require_config = __commonJS({
  "node_modules/triple-beam/config/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "cli", {
      value: require_cli()
    });
    Object.defineProperty(exports2, "npm", {
      value: require_npm()
    });
    Object.defineProperty(exports2, "syslog", {
      value: require_syslog()
    });
  }
});

// node_modules/triple-beam/index.js
var require_triple_beam = __commonJS({
  "node_modules/triple-beam/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "LEVEL", {
      value: Symbol.for("level")
    });
    Object.defineProperty(exports2, "MESSAGE", {
      value: Symbol.for("message")
    });
    Object.defineProperty(exports2, "SPLAT", {
      value: Symbol.for("splat")
    });
    Object.defineProperty(exports2, "configs", {
      value: require_config()
    });
  }
});

// node_modules/logform/colorize.js
var require_colorize = __commonJS({
  "node_modules/logform/colorize.js"(exports2, module2) {
    "use strict";
    var colors = require_safe();
    var { LEVEL, MESSAGE } = require_triple_beam();
    colors.enabled = true;
    var hasSpace = /\s+/;
    var Colorizer = class _Colorizer {
      constructor(opts = {}) {
        if (opts.colors) {
          this.addColors(opts.colors);
        }
        this.options = opts;
      }
      /*
       * Adds the colors Object to the set of allColors
       * known by the Colorizer
       *
       * @param {Object} colors Set of color mappings to add.
       */
      static addColors(clrs) {
        const nextColors = Object.keys(clrs).reduce((acc, level) => {
          acc[level] = hasSpace.test(clrs[level]) ? clrs[level].split(hasSpace) : clrs[level];
          return acc;
        }, {});
        _Colorizer.allColors = Object.assign({}, _Colorizer.allColors || {}, nextColors);
        return _Colorizer.allColors;
      }
      /*
       * Adds the colors Object to the set of allColors
       * known by the Colorizer
       *
       * @param {Object} colors Set of color mappings to add.
       */
      addColors(clrs) {
        return _Colorizer.addColors(clrs);
      }
      /*
       * function colorize (lookup, level, message)
       * Performs multi-step colorization using @colors/colors/safe
       */
      colorize(lookup, level, message) {
        if (typeof message === "undefined") {
          message = level;
        }
        if (!Array.isArray(_Colorizer.allColors[lookup])) {
          return colors[_Colorizer.allColors[lookup]](message);
        }
        for (let i = 0, len = _Colorizer.allColors[lookup].length; i < len; i++) {
          message = colors[_Colorizer.allColors[lookup][i]](message);
        }
        return message;
      }
      /*
       * function transform (info, opts)
       * Attempts to colorize the { level, message } of the given
       * `logform` info object.
       */
      transform(info, opts) {
        if (opts.all && typeof info[MESSAGE] === "string") {
          info[MESSAGE] = this.colorize(info[LEVEL], info.level, info[MESSAGE]);
        }
        if (opts.level || opts.all || !opts.message) {
          info.level = this.colorize(info[LEVEL], info.level);
        }
        if (opts.all || opts.message) {
          info.message = this.colorize(info[LEVEL], info.level, info.message);
        }
        return info;
      }
    };
    module2.exports = (opts) => new Colorizer(opts);
    module2.exports.Colorizer = module2.exports.Format = Colorizer;
  }
});

// node_modules/logform/levels.js
var require_levels = __commonJS({
  "node_modules/logform/levels.js"(exports2, module2) {
    "use strict";
    var { Colorizer } = require_colorize();
    module2.exports = (config) => {
      Colorizer.addColors(config.colors || config);
      return config;
    };
  }
});

// node_modules/logform/align.js
var require_align = __commonJS({
  "node_modules/logform/align.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    module2.exports = format2((info) => {
      info.message = `	${info.message}`;
      return info;
    });
  }
});

// node_modules/logform/errors.js
var require_errors = __commonJS({
  "node_modules/logform/errors.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    var { LEVEL, MESSAGE } = require_triple_beam();
    module2.exports = format2((einfo, { stack, cause }) => {
      if (einfo instanceof Error) {
        const info = Object.assign({}, einfo, {
          level: einfo.level,
          [LEVEL]: einfo[LEVEL] || einfo.level,
          message: einfo.message,
          [MESSAGE]: einfo[MESSAGE] || einfo.message
        });
        if (stack)
          info.stack = einfo.stack;
        if (cause)
          info.cause = einfo.cause;
        return info;
      }
      if (!(einfo.message instanceof Error))
        return einfo;
      const err = einfo.message;
      Object.assign(einfo, err);
      einfo.message = err.message;
      einfo[MESSAGE] = err.message;
      if (stack)
        einfo.stack = err.stack;
      if (cause)
        einfo.cause = err.cause;
      return einfo;
    });
  }
});

// node_modules/logform/pad-levels.js
var require_pad_levels = __commonJS({
  "node_modules/logform/pad-levels.js"(exports2, module2) {
    "use strict";
    var { configs, LEVEL, MESSAGE } = require_triple_beam();
    var Padder = class _Padder {
      constructor(opts = { levels: configs.npm.levels }) {
        this.paddings = _Padder.paddingForLevels(opts.levels, opts.filler);
        this.options = opts;
      }
      /**
       * Returns the maximum length of keys in the specified `levels` Object.
       * @param  {Object} levels Set of all levels to calculate longest level against.
       * @returns {Number} Maximum length of the longest level string.
       */
      static getLongestLevel(levels) {
        const lvls = Object.keys(levels).map((level) => level.length);
        return Math.max(...lvls);
      }
      /**
       * Returns the padding for the specified `level` assuming that the
       * maximum length of all levels it's associated with is `maxLength`.
       * @param  {String} level Level to calculate padding for.
       * @param  {String} filler Repeatable text to use for padding.
       * @param  {Number} maxLength Length of the longest level
       * @returns {String} Padding string for the `level`
       */
      static paddingForLevel(level, filler, maxLength) {
        const targetLen = maxLength + 1 - level.length;
        const rep = Math.floor(targetLen / filler.length);
        const padding = `${filler}${filler.repeat(rep)}`;
        return padding.slice(0, targetLen);
      }
      /**
       * Returns an object with the string paddings for the given `levels`
       * using the specified `filler`.
       * @param  {Object} levels Set of all levels to calculate padding for.
       * @param  {String} filler Repeatable text to use for padding.
       * @returns {Object} Mapping of level to desired padding.
       */
      static paddingForLevels(levels, filler = " ") {
        const maxLength = _Padder.getLongestLevel(levels);
        return Object.keys(levels).reduce((acc, level) => {
          acc[level] = _Padder.paddingForLevel(level, filler, maxLength);
          return acc;
        }, {});
      }
      /**
       * Prepends the padding onto the `message` based on the `LEVEL` of
       * the `info`. This is based on the behavior of `winston@2` which also
       * prepended the level onto the message.
       *
       * See: https://github.com/winstonjs/winston/blob/2.x/lib/winston/logger.js#L198-L201
       *
       * @param  {Info} info Logform info object
       * @param  {Object} opts Options passed along to this instance.
       * @returns {Info} Modified logform info object.
       */
      transform(info, opts) {
        info.message = `${this.paddings[info[LEVEL]]}${info.message}`;
        if (info[MESSAGE]) {
          info[MESSAGE] = `${this.paddings[info[LEVEL]]}${info[MESSAGE]}`;
        }
        return info;
      }
    };
    module2.exports = (opts) => new Padder(opts);
    module2.exports.Padder = module2.exports.Format = Padder;
  }
});

// node_modules/logform/cli.js
var require_cli2 = __commonJS({
  "node_modules/logform/cli.js"(exports2, module2) {
    "use strict";
    var { Colorizer } = require_colorize();
    var { Padder } = require_pad_levels();
    var { configs, MESSAGE } = require_triple_beam();
    var CliFormat = class {
      constructor(opts = {}) {
        if (!opts.levels) {
          opts.levels = configs.cli.levels;
        }
        this.colorizer = new Colorizer(opts);
        this.padder = new Padder(opts);
        this.options = opts;
      }
      /*
       * function transform (info, opts)
       * Attempts to both:
       * 1. Pad the { level }
       * 2. Colorize the { level, message }
       * of the given `logform` info object depending on the `opts`.
       */
      transform(info, opts) {
        this.colorizer.transform(
          this.padder.transform(info, opts),
          opts
        );
        info[MESSAGE] = `${info.level}:${info.message}`;
        return info;
      }
    };
    module2.exports = (opts) => new CliFormat(opts);
    module2.exports.Format = CliFormat;
  }
});

// node_modules/logform/combine.js
var require_combine = __commonJS({
  "node_modules/logform/combine.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    function cascade(formats) {
      if (!formats.every(isValidFormat)) {
        return;
      }
      return (info) => {
        let obj = info;
        for (let i = 0; i < formats.length; i++) {
          obj = formats[i].transform(obj, formats[i].options);
          if (!obj) {
            return false;
          }
        }
        return obj;
      };
    }
    function isValidFormat(fmt) {
      if (typeof fmt.transform !== "function") {
        throw new Error([
          "No transform function found on format. Did you create a format instance?",
          "const myFormat = format(formatFn);",
          "const instance = myFormat();"
        ].join("\n"));
      }
      return true;
    }
    module2.exports = (...formats) => {
      const combinedFormat = format2(cascade(formats));
      const instance2 = combinedFormat();
      instance2.Format = combinedFormat.Format;
      return instance2;
    };
    module2.exports.cascade = cascade;
  }
});

// node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS({
  "node_modules/safe-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    var { hasOwnProperty: hasOwnProperty18 } = Object.prototype;
    var stringify = configure();
    stringify.configure = configure;
    stringify.stringify = stringify;
    stringify.default = stringify;
    exports2.stringify = stringify;
    exports2.configure = configure;
    module2.exports = stringify;
    var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function insertSort(array) {
      if (array.length > 200) {
        return array.sort();
      }
      for (let i = 1; i < array.length; i++) {
        const currentValue = array[i];
        let position = i;
        while (position !== 0 && array[position - 1] > currentValue) {
          array[position] = array[position - 1];
          position--;
        }
        array[position] = currentValue;
      }
      return array;
    }
    var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array, separator, maximumBreadth) {
      if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res = `"0":${whitespace}${array[0]}`;
      for (let i = 1; i < maximumBreadth; i++) {
        res += `${separator}"${i}":${whitespace}${array[i]}`;
      }
      return res;
    }
    function getCircularValueOption(options) {
      if (hasOwnProperty18.call(options, "circularValue")) {
        const circularValue = options.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getBooleanOption(options, key) {
      let value;
      if (hasOwnProperty18.call(options, key)) {
        value = options[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options, key) {
      let value;
      if (hasOwnProperty18.call(options, key)) {
        value = options[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number) {
      if (number === 1) {
        return "1 item";
      }
      return `${number} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options) {
      if (hasOwnProperty18.call(options, "strict")) {
        const value = options.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function")
              message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options) {
      options = { ...options };
      const fail = getStrictOption(options);
      if (fail) {
        if (options.bigint === void 0) {
          options.bigint = false;
        }
        if (!("circularValue" in options)) {
          options.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options);
      const bigint = getBooleanOption(options, "bigint");
      const deterministic = getBooleanOption(options, "deterministic");
      const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            let join2 = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join2 = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join2;
              }
              const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys2 = Object.keys(value);
            const keyLength = keys2.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join2 = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys2 = insertSort(keys2);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys2[i];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join2;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join2;
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = "";
            let join2 = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join2 = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join2;
              }
              const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join2 = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join2;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join3 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join3;
              }
              const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join3}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack.pop();
              return `[${res2}]`;
            }
            let keys2 = Object.keys(value);
            const keyLength = keys2.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join2 = `,
${indentation}`;
            let res = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join2, maximumBreadth);
              keys2 = keys2.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join2;
            }
            if (deterministic) {
              keys2 = insertSort(keys2);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys2[i];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join2;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join2;
            }
            if (separator !== "") {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifySimple(String(i), value[i], stack);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += ",";
              }
              const tmp = stringifySimple(String(i), value[i], stack);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys2 = Object.keys(value);
            const keyLength = keys2.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, ",", maximumBreadth);
              keys2 = keys2.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys2 = insertSort(keys2);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys2[i];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringify2(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify2;
    }
  }
});

// node_modules/logform/json.js
var require_json = __commonJS({
  "node_modules/logform/json.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    var { MESSAGE } = require_triple_beam();
    var stringify = require_safe_stable_stringify();
    function replacer(key, value) {
      if (typeof value === "bigint")
        return value.toString();
      return value;
    }
    module2.exports = format2((info, opts) => {
      const jsonStringify = stringify.configure(opts);
      info[MESSAGE] = jsonStringify(info, opts.replacer || replacer, opts.space);
      return info;
    });
  }
});

// node_modules/logform/label.js
var require_label = __commonJS({
  "node_modules/logform/label.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    module2.exports = format2((info, opts) => {
      if (opts.message) {
        info.message = `[${opts.label}] ${info.message}`;
        return info;
      }
      info.label = opts.label;
      return info;
    });
  }
});

// node_modules/logform/logstash.js
var require_logstash = __commonJS({
  "node_modules/logform/logstash.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    var { MESSAGE } = require_triple_beam();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = format2((info) => {
      const logstash = {};
      if (info.message) {
        logstash["@message"] = info.message;
        delete info.message;
      }
      if (info.timestamp) {
        logstash["@timestamp"] = info.timestamp;
        delete info.timestamp;
      }
      logstash["@fields"] = info;
      info[MESSAGE] = jsonStringify(logstash);
      return info;
    });
  }
});

// node_modules/logform/metadata.js
var require_metadata = __commonJS({
  "node_modules/logform/metadata.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    function fillExcept(info, fillExceptKeys, metadataKey) {
      const savedKeys = fillExceptKeys.reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      const metadata = Object.keys(info).reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      Object.assign(info, savedKeys, {
        [metadataKey]: metadata
      });
      return info;
    }
    function fillWith(info, fillWithKeys, metadataKey) {
      info[metadataKey] = fillWithKeys.reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      return info;
    }
    module2.exports = format2((info, opts = {}) => {
      let metadataKey = "metadata";
      if (opts.key) {
        metadataKey = opts.key;
      }
      let fillExceptKeys = [];
      if (!opts.fillExcept && !opts.fillWith) {
        fillExceptKeys.push("level");
        fillExceptKeys.push("message");
      }
      if (opts.fillExcept) {
        fillExceptKeys = opts.fillExcept;
      }
      if (fillExceptKeys.length > 0) {
        return fillExcept(info, fillExceptKeys, metadataKey);
      }
      if (opts.fillWith) {
        return fillWith(info, opts.fillWith, metadataKey);
      }
      return info;
    });
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse3(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse3(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/logform/ms.js
var require_ms2 = __commonJS({
  "node_modules/logform/ms.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    var ms = require_ms();
    module2.exports = format2((info) => {
      const curr = +/* @__PURE__ */ new Date();
      exports2.diff = curr - (exports2.prevTime || curr);
      exports2.prevTime = curr;
      info.ms = `+${ms(exports2.diff)}`;
      return info;
    });
  }
});

// node_modules/logform/pretty-print.js
var require_pretty_print = __commonJS({
  "node_modules/logform/pretty-print.js"(exports2, module2) {
    "use strict";
    var inspect = require("util").inspect;
    var format2 = require_format();
    var { LEVEL, MESSAGE, SPLAT } = require_triple_beam();
    module2.exports = format2((info, opts = {}) => {
      const stripped = Object.assign({}, info);
      delete stripped[LEVEL];
      delete stripped[MESSAGE];
      delete stripped[SPLAT];
      info[MESSAGE] = inspect(stripped, false, opts.depth || null, opts.colorize);
      return info;
    });
  }
});

// node_modules/logform/printf.js
var require_printf = __commonJS({
  "node_modules/logform/printf.js"(exports2, module2) {
    "use strict";
    var { MESSAGE } = require_triple_beam();
    var Printf = class {
      constructor(templateFn) {
        this.template = templateFn;
      }
      transform(info) {
        info[MESSAGE] = this.template(info);
        return info;
      }
    };
    module2.exports = (opts) => new Printf(opts);
    module2.exports.Printf = module2.exports.Format = Printf;
  }
});

// node_modules/logform/simple.js
var require_simple = __commonJS({
  "node_modules/logform/simple.js"(exports2, module2) {
    "use strict";
    var format2 = require_format();
    var { MESSAGE } = require_triple_beam();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = format2((info) => {
      const stringifiedRest = jsonStringify(Object.assign({}, info, {
        level: void 0,
        message: void 0,
        splat: void 0
      }));
      const padding = info.padding && info.padding[info.level] || "";
      if (stringifiedRest !== "{}") {
        info[MESSAGE] = `${info.level}:${padding} ${info.message} ${stringifiedRest}`;
      } else {
        info[MESSAGE] = `${info.level}:${padding} ${info.message}`;
      }
      return info;
    });
  }
});

// node_modules/logform/splat.js
var require_splat = __commonJS({
  "node_modules/logform/splat.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var { SPLAT } = require_triple_beam();
    var formatRegExp = /%[scdjifoO%]/g;
    var escapedPercent = /%%/g;
    var Splatter = class {
      constructor(opts) {
        this.options = opts;
      }
      /**
         * Check to see if tokens <= splat.length, assign { splat, meta } into the
         * `info` accordingly, and write to this instance.
         *
         * @param  {Info} info Logform info message.
         * @param  {String[]} tokens Set of string interpolation tokens.
         * @returns {Info} Modified info message
         * @private
         */
      _splat(info, tokens3) {
        const msg = info.message;
        const splat = info[SPLAT] || info.splat || [];
        const percents = msg.match(escapedPercent);
        const escapes = percents && percents.length || 0;
        const expectedSplat = tokens3.length - escapes;
        const extraSplat = expectedSplat - splat.length;
        const metas = extraSplat < 0 ? splat.splice(extraSplat, -1 * extraSplat) : [];
        const metalen = metas.length;
        if (metalen) {
          for (let i = 0; i < metalen; i++) {
            Object.assign(info, metas[i]);
          }
        }
        info.message = util.format(msg, ...splat);
        return info;
      }
      /**
        * Transforms the `info` message by using `util.format` to complete
        * any `info.message` provided it has string interpolation tokens.
        * If no tokens exist then `info` is immutable.
        *
        * @param  {Info} info Logform info message.
        * @param  {Object} opts Options for this instance.
        * @returns {Info} Modified info message
        */
      transform(info) {
        const msg = info.message;
        const splat = info[SPLAT] || info.splat;
        if (!splat || !splat.length) {
          return info;
        }
        const tokens3 = msg && msg.match && msg.match(formatRegExp);
        if (!tokens3 && (splat || splat.length)) {
          const metas = splat.length > 1 ? splat.splice(0) : splat;
          const metalen = metas.length;
          if (metalen) {
            for (let i = 0; i < metalen; i++) {
              Object.assign(info, metas[i]);
            }
          }
          return info;
        }
        if (tokens3) {
          return this._splat(info, tokens3);
        }
        return info;
      }
    };
    module2.exports = (opts) => new Splatter(opts);
  }
});

// node_modules/fecha/lib/fecha.umd.js
var require_fecha_umd = __commonJS({
  "node_modules/fecha/lib/fecha.umd.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.fecha = {});
    })(exports2, function(exports3) {
      "use strict";
      var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
      var twoDigitsOptional = "\\d\\d?";
      var twoDigits = "\\d\\d";
      var threeDigits = "\\d{3}";
      var fourDigits = "\\d{4}";
      var word = "[^\\s]+";
      var literal = /\[([^]*?)\]/gm;
      function shorten(arr, sLen) {
        var newArr = [];
        for (var i = 0, len = arr.length; i < len; i++) {
          newArr.push(arr[i].substr(0, sLen));
        }
        return newArr;
      }
      var monthUpdate = function(arrName) {
        return function(v, i18n) {
          var lowerCaseArr = i18n[arrName].map(function(v2) {
            return v2.toLowerCase();
          });
          var index = lowerCaseArr.indexOf(v.toLowerCase());
          if (index > -1) {
            return index;
          }
          return null;
        };
      };
      function assign2(origObj) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
          var obj = args_1[_a];
          for (var key in obj) {
            origObj[key] = obj[key];
          }
        }
        return origObj;
      }
      var dayNames = [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ];
      var monthNames = [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ];
      var monthNamesShort = shorten(monthNames, 3);
      var dayNamesShort = shorten(dayNames, 3);
      var defaultI18n = {
        dayNamesShort,
        dayNames,
        monthNamesShort,
        monthNames,
        amPm: ["am", "pm"],
        DoFn: function(dayOfMonth) {
          return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
        }
      };
      var globalI18n = assign2({}, defaultI18n);
      var setGlobalDateI18n = function(i18n) {
        return globalI18n = assign2(globalI18n, i18n);
      };
      var regexEscape = function(str) {
        return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
      };
      var pad = function(val, len) {
        if (len === void 0) {
          len = 2;
        }
        val = String(val);
        while (val.length < len) {
          val = "0" + val;
        }
        return val;
      };
      var formatFlags = {
        D: function(dateObj) {
          return String(dateObj.getDate());
        },
        DD: function(dateObj) {
          return pad(dateObj.getDate());
        },
        Do: function(dateObj, i18n) {
          return i18n.DoFn(dateObj.getDate());
        },
        d: function(dateObj) {
          return String(dateObj.getDay());
        },
        dd: function(dateObj) {
          return pad(dateObj.getDay());
        },
        ddd: function(dateObj, i18n) {
          return i18n.dayNamesShort[dateObj.getDay()];
        },
        dddd: function(dateObj, i18n) {
          return i18n.dayNames[dateObj.getDay()];
        },
        M: function(dateObj) {
          return String(dateObj.getMonth() + 1);
        },
        MM: function(dateObj) {
          return pad(dateObj.getMonth() + 1);
        },
        MMM: function(dateObj, i18n) {
          return i18n.monthNamesShort[dateObj.getMonth()];
        },
        MMMM: function(dateObj, i18n) {
          return i18n.monthNames[dateObj.getMonth()];
        },
        YY: function(dateObj) {
          return pad(String(dateObj.getFullYear()), 4).substr(2);
        },
        YYYY: function(dateObj) {
          return pad(dateObj.getFullYear(), 4);
        },
        h: function(dateObj) {
          return String(dateObj.getHours() % 12 || 12);
        },
        hh: function(dateObj) {
          return pad(dateObj.getHours() % 12 || 12);
        },
        H: function(dateObj) {
          return String(dateObj.getHours());
        },
        HH: function(dateObj) {
          return pad(dateObj.getHours());
        },
        m: function(dateObj) {
          return String(dateObj.getMinutes());
        },
        mm: function(dateObj) {
          return pad(dateObj.getMinutes());
        },
        s: function(dateObj) {
          return String(dateObj.getSeconds());
        },
        ss: function(dateObj) {
          return pad(dateObj.getSeconds());
        },
        S: function(dateObj) {
          return String(Math.round(dateObj.getMilliseconds() / 100));
        },
        SS: function(dateObj) {
          return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
        },
        SSS: function(dateObj) {
          return pad(dateObj.getMilliseconds(), 3);
        },
        a: function(dateObj, i18n) {
          return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
        },
        A: function(dateObj, i18n) {
          return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
        },
        ZZ: function(dateObj) {
          var offset = dateObj.getTimezoneOffset();
          return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
        },
        Z: function(dateObj) {
          var offset = dateObj.getTimezoneOffset();
          return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
        }
      };
      var monthParse = function(v) {
        return +v - 1;
      };
      var emptyDigits = [null, twoDigitsOptional];
      var emptyWord = [null, word];
      var amPm = [
        "isPm",
        word,
        function(v, i18n) {
          var val = v.toLowerCase();
          if (val === i18n.amPm[0]) {
            return 0;
          } else if (val === i18n.amPm[1]) {
            return 1;
          }
          return null;
        }
      ];
      var timezoneOffset = [
        "timezoneOffset",
        "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
        function(v) {
          var parts = (v + "").match(/([+-]|\d\d)/gi);
          if (parts) {
            var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
            return parts[0] === "+" ? minutes : -minutes;
          }
          return 0;
        }
      ];
      var parseFlags = {
        D: ["day", twoDigitsOptional],
        DD: ["day", twoDigits],
        Do: ["day", twoDigitsOptional + word, function(v) {
          return parseInt(v, 10);
        }],
        M: ["month", twoDigitsOptional, monthParse],
        MM: ["month", twoDigits, monthParse],
        YY: [
          "year",
          twoDigits,
          function(v) {
            var now = /* @__PURE__ */ new Date();
            var cent = +("" + now.getFullYear()).substr(0, 2);
            return +("" + (+v > 68 ? cent - 1 : cent) + v);
          }
        ],
        h: ["hour", twoDigitsOptional, void 0, "isPm"],
        hh: ["hour", twoDigits, void 0, "isPm"],
        H: ["hour", twoDigitsOptional],
        HH: ["hour", twoDigits],
        m: ["minute", twoDigitsOptional],
        mm: ["minute", twoDigits],
        s: ["second", twoDigitsOptional],
        ss: ["second", twoDigits],
        YYYY: ["year", fourDigits],
        S: ["millisecond", "\\d", function(v) {
          return +v * 100;
        }],
        SS: ["millisecond", twoDigits, function(v) {
          return +v * 10;
        }],
        SSS: ["millisecond", threeDigits],
        d: emptyDigits,
        dd: emptyDigits,
        ddd: emptyWord,
        dddd: emptyWord,
        MMM: ["month", word, monthUpdate("monthNamesShort")],
        MMMM: ["month", word, monthUpdate("monthNames")],
        a: amPm,
        A: amPm,
        ZZ: timezoneOffset,
        Z: timezoneOffset
      };
      var globalMasks = {
        default: "ddd MMM DD YYYY HH:mm:ss",
        shortDate: "M/D/YY",
        mediumDate: "MMM D, YYYY",
        longDate: "MMMM D, YYYY",
        fullDate: "dddd, MMMM D, YYYY",
        isoDate: "YYYY-MM-DD",
        isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
        shortTime: "HH:mm",
        mediumTime: "HH:mm:ss",
        longTime: "HH:mm:ss.SSS"
      };
      var setGlobalDateMasks = function(masks) {
        return assign2(globalMasks, masks);
      };
      var format2 = function(dateObj, mask, i18n) {
        if (mask === void 0) {
          mask = globalMasks["default"];
        }
        if (i18n === void 0) {
          i18n = {};
        }
        if (typeof dateObj === "number") {
          dateObj = new Date(dateObj);
        }
        if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
          throw new Error("Invalid Date pass to format");
        }
        mask = globalMasks[mask] || mask;
        var literals = [];
        mask = mask.replace(literal, function($0, $1) {
          literals.push($1);
          return "@@@";
        });
        var combinedI18nSettings = assign2(assign2({}, globalI18n), i18n);
        mask = mask.replace(token, function($0) {
          return formatFlags[$0](dateObj, combinedI18nSettings);
        });
        return mask.replace(/@@@/g, function() {
          return literals.shift();
        });
      };
      function parse3(dateStr, format3, i18n) {
        if (i18n === void 0) {
          i18n = {};
        }
        if (typeof format3 !== "string") {
          throw new Error("Invalid format in fecha parse");
        }
        format3 = globalMasks[format3] || format3;
        if (dateStr.length > 1e3) {
          return null;
        }
        var today = /* @__PURE__ */ new Date();
        var dateInfo = {
          year: today.getFullYear(),
          month: 0,
          day: 1,
          hour: 0,
          minute: 0,
          second: 0,
          millisecond: 0,
          isPm: null,
          timezoneOffset: null
        };
        var parseInfo = [];
        var literals = [];
        var newFormat = format3.replace(literal, function($0, $1) {
          literals.push(regexEscape($1));
          return "@@@";
        });
        var specifiedFields = {};
        var requiredFields = {};
        newFormat = regexEscape(newFormat).replace(token, function($0) {
          var info = parseFlags[$0];
          var field2 = info[0], regex = info[1], requiredField = info[3];
          if (specifiedFields[field2]) {
            throw new Error("Invalid format. " + field2 + " specified twice in format");
          }
          specifiedFields[field2] = true;
          if (requiredField) {
            requiredFields[requiredField] = true;
          }
          parseInfo.push(info);
          return "(" + regex + ")";
        });
        Object.keys(requiredFields).forEach(function(field2) {
          if (!specifiedFields[field2]) {
            throw new Error("Invalid format. " + field2 + " is required in specified format");
          }
        });
        newFormat = newFormat.replace(/@@@/g, function() {
          return literals.shift();
        });
        var matches = dateStr.match(new RegExp(newFormat, "i"));
        if (!matches) {
          return null;
        }
        var combinedI18nSettings = assign2(assign2({}, globalI18n), i18n);
        for (var i = 1; i < matches.length; i++) {
          var _a = parseInfo[i - 1], field = _a[0], parser3 = _a[2];
          var value = parser3 ? parser3(matches[i], combinedI18nSettings) : +matches[i];
          if (value == null) {
            return null;
          }
          dateInfo[field] = value;
        }
        if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
          dateInfo.hour = +dateInfo.hour + 12;
        } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
          dateInfo.hour = 0;
        }
        var dateTZ;
        if (dateInfo.timezoneOffset == null) {
          dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
          var validateFields = [
            ["month", "getMonth"],
            ["day", "getDate"],
            ["hour", "getHours"],
            ["minute", "getMinutes"],
            ["second", "getSeconds"]
          ];
          for (var i = 0, len = validateFields.length; i < len; i++) {
            if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) {
              return null;
            }
          }
        } else {
          dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
          if (dateInfo.month > 11 || dateInfo.month < 0 || dateInfo.day > 31 || dateInfo.day < 1 || dateInfo.hour > 23 || dateInfo.hour < 0 || dateInfo.minute > 59 || dateInfo.minute < 0 || dateInfo.second > 59 || dateInfo.second < 0) {
            return null;
          }
        }
        return dateTZ;
      }
      var fecha = {
        format: format2,
        parse: parse3,
        defaultI18n,
        setGlobalDateI18n,
        setGlobalDateMasks
      };
      exports3.assign = assign2;
      exports3.default = fecha;
      exports3.format = format2;
      exports3.parse = parse3;
      exports3.defaultI18n = defaultI18n;
      exports3.setGlobalDateI18n = setGlobalDateI18n;
      exports3.setGlobalDateMasks = setGlobalDateMasks;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/logform/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/logform/timestamp.js"(exports2, module2) {
    "use strict";
    var fecha = require_fecha_umd();
    var format2 = require_format();
    module2.exports = format2((info, opts = {}) => {
      if (opts.format) {
        info.timestamp = typeof opts.format === "function" ? opts.format() : fecha.format(/* @__PURE__ */ new Date(), opts.format);
      }
      if (!info.timestamp) {
        info.timestamp = (/* @__PURE__ */ new Date()).toISOString();
      }
      if (opts.alias) {
        info[opts.alias] = info.timestamp;
      }
      return info;
    });
  }
});

// node_modules/logform/uncolorize.js
var require_uncolorize = __commonJS({
  "node_modules/logform/uncolorize.js"(exports2, module2) {
    "use strict";
    var colors = require_safe();
    var format2 = require_format();
    var { MESSAGE } = require_triple_beam();
    module2.exports = format2((info, opts) => {
      if (opts.level !== false) {
        info.level = colors.strip(info.level);
      }
      if (opts.message !== false) {
        info.message = colors.strip(String(info.message));
      }
      if (opts.raw !== false && info[MESSAGE]) {
        info[MESSAGE] = colors.strip(String(info[MESSAGE]));
      }
      return info;
    });
  }
});

// node_modules/logform/index.js
var require_logform = __commonJS({
  "node_modules/logform/index.js"(exports2) {
    "use strict";
    var format2 = exports2.format = require_format();
    exports2.levels = require_levels();
    function exposeFormat(name, requireFormat) {
      Object.defineProperty(format2, name, {
        get() {
          return requireFormat();
        },
        configurable: true
      });
    }
    exposeFormat("align", function() {
      return require_align();
    });
    exposeFormat("errors", function() {
      return require_errors();
    });
    exposeFormat("cli", function() {
      return require_cli2();
    });
    exposeFormat("combine", function() {
      return require_combine();
    });
    exposeFormat("colorize", function() {
      return require_colorize();
    });
    exposeFormat("json", function() {
      return require_json();
    });
    exposeFormat("label", function() {
      return require_label();
    });
    exposeFormat("logstash", function() {
      return require_logstash();
    });
    exposeFormat("metadata", function() {
      return require_metadata();
    });
    exposeFormat("ms", function() {
      return require_ms2();
    });
    exposeFormat("padLevels", function() {
      return require_pad_levels();
    });
    exposeFormat("prettyPrint", function() {
      return require_pretty_print();
    });
    exposeFormat("printf", function() {
      return require_printf();
    });
    exposeFormat("simple", function() {
      return require_simple();
    });
    exposeFormat("splat", function() {
      return require_splat();
    });
    exposeFormat("timestamp", function() {
      return require_timestamp();
    });
    exposeFormat("uncolorize", function() {
      return require_uncolorize();
    });
  }
});

// node_modules/winston/lib/winston/common.js
var require_common = __commonJS({
  "node_modules/winston/lib/winston/common.js"(exports2) {
    "use strict";
    var { format: format2 } = require("util");
    exports2.warn = {
      deprecated(prop) {
        return () => {
          throw new Error(format2("{ %s } was removed in winston@3.0.0.", prop));
        };
      },
      useFormat(prop) {
        return () => {
          throw new Error([
            format2("{ %s } was removed in winston@3.0.0.", prop),
            "Use a custom winston.format = winston.format(function) instead."
          ].join("\n"));
        };
      },
      forFunctions(obj, type, props) {
        props.forEach((prop) => {
          obj[prop] = exports2.warn[type](prop);
        });
      },
      forProperties(obj, type, props) {
        props.forEach((prop) => {
          const notice = exports2.warn[type](prop);
          Object.defineProperty(obj, prop, {
            get: notice,
            set: notice
          });
        });
      }
    };
  }
});

// node_modules/winston/package.json
var require_package = __commonJS({
  "node_modules/winston/package.json"(exports2, module2) {
    module2.exports = {
      name: "winston",
      description: "A logger for just about everything.",
      version: "3.13.0",
      author: "Charlie Robbins <charlie.robbins@gmail.com>",
      maintainers: [
        "David Hyde <dabh@alumni.stanford.edu>"
      ],
      repository: {
        type: "git",
        url: "https://github.com/winstonjs/winston.git"
      },
      keywords: [
        "winston",
        "logger",
        "logging",
        "logs",
        "sysadmin",
        "bunyan",
        "pino",
        "loglevel",
        "tools",
        "json",
        "stream"
      ],
      dependencies: {
        "@dabh/diagnostics": "^2.0.2",
        "@colors/colors": "^1.6.0",
        async: "^3.2.3",
        "is-stream": "^2.0.0",
        logform: "^2.4.0",
        "one-time": "^1.0.0",
        "readable-stream": "^3.4.0",
        "safe-stable-stringify": "^2.3.1",
        "stack-trace": "0.0.x",
        "triple-beam": "^1.3.0",
        "winston-transport": "^4.7.0"
      },
      devDependencies: {
        "@babel/cli": "^7.23.9",
        "@babel/core": "^7.24.0",
        "@babel/preset-env": "^7.24.0",
        "@dabh/eslint-config-populist": "^5.0.0",
        "@types/node": "^20.11.24",
        "abstract-winston-transport": "^0.5.1",
        assume: "^2.2.0",
        "cross-spawn-async": "^2.2.5",
        eslint: "^8.57.0",
        hock: "^1.4.1",
        mocha: "^10.3.0",
        nyc: "^15.1.0",
        rimraf: "^5.0.5",
        split2: "^4.1.0",
        "std-mocks": "^2.0.0",
        through2: "^4.0.2",
        "winston-compat": "^0.1.5"
      },
      main: "./lib/winston.js",
      browser: "./dist/winston",
      types: "./index.d.ts",
      scripts: {
        lint: "eslint lib/*.js lib/winston/*.js lib/winston/**/*.js --resolve-plugins-relative-to ./node_modules/@dabh/eslint-config-populist",
        test: "rimraf test/fixtures/logs/* && mocha",
        "test:coverage": "nyc npm run test:unit",
        "test:unit": "mocha test/unit",
        "test:integration": "mocha test/integration",
        build: "rimraf dist && babel lib -d dist",
        prepublishOnly: "npm run build"
      },
      engines: {
        node: ">= 12.0.0"
      },
      license: "MIT"
    };
  }
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/winston-transport/node_modules/readable-stream/errors.js
var require_errors2 = __commonJS({
  "node_modules/winston-transport/node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes2(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes2(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors2().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance2, Constructor) {
      if (!(instance2 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require("buffer");
    var Buffer4 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer4.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join2(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next)
            ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer4.alloc(0);
          var ret = Buffer4.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first2() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer4.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer4 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer4.from && Buffer4.alloc && Buffer4.allocUnsafe && Buffer4.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer4(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer4.prototype);
    copyProps(Buffer4, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer4(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer4(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer4(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer4 = require_safe_buffer().Buffer;
    var isEncoding = Buffer4.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer4.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer4.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors2().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop2() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop2);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject2) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject2);
        }, reject2);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject2) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject2(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject2) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject2(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject2) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject2;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject2 = iterator[kLastReject];
          if (reject2 !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject2(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject2, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject2(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject2) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject2, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject2, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE = require_errors2().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// node_modules/winston-transport/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/winston-transport/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer4 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer4.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors2().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer4.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer4.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf2(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf2(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf2(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/winston-transport/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/winston-transport/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys3 = [];
      for (var key in obj)
        keys3.push(key);
      return keys3;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits()(Duplex, Readable);
    {
      keys2 = objectKeys(Writable.prototype);
      for (v = 0; v < keys2.length; v++) {
        method = keys2[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys2;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream();
    var Buffer4 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer4.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors2().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer4.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer4.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last2 = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last2) {
          last2.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/winston-transport/modern.js
var require_modern = __commonJS({
  "node_modules/winston-transport/modern.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Writable = require_stream_writable();
    var { LEVEL } = require_triple_beam();
    var TransportStream = module2.exports = function TransportStream2(options = {}) {
      Writable.call(this, { objectMode: true, highWaterMark: options.highWaterMark });
      this.format = options.format;
      this.level = options.level;
      this.handleExceptions = options.handleExceptions;
      this.handleRejections = options.handleRejections;
      this.silent = options.silent;
      if (options.log)
        this.log = options.log;
      if (options.logv)
        this.logv = options.logv;
      if (options.close)
        this.close = options.close;
      this.once("pipe", (logger) => {
        this.levels = logger.levels;
        this.parent = logger;
      });
      this.once("unpipe", (src) => {
        if (src === this.parent) {
          this.parent = null;
          if (this.close) {
            this.close();
          }
        }
      });
    };
    util.inherits(TransportStream, Writable);
    TransportStream.prototype._write = function _write(info, enc, callback) {
      if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
      }
      const level = this.level || this.parent && this.parent.level;
      if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (info && !this.format) {
          return this.log(info, callback);
        }
        let errState;
        let transformed;
        try {
          transformed = this.format.transform(Object.assign({}, info), this.format.options);
        } catch (err) {
          errState = err;
        }
        if (errState || !transformed) {
          callback();
          if (errState)
            throw errState;
          return;
        }
        return this.log(transformed, callback);
      }
      this._writableState.sync = false;
      return callback(null);
    };
    TransportStream.prototype._writev = function _writev(chunks, callback) {
      if (this.logv) {
        const infos = chunks.filter(this._accept, this);
        if (!infos.length) {
          return callback(null);
        }
        return this.logv(infos, callback);
      }
      for (let i = 0; i < chunks.length; i++) {
        if (!this._accept(chunks[i]))
          continue;
        if (chunks[i].chunk && !this.format) {
          this.log(chunks[i].chunk, chunks[i].callback);
          continue;
        }
        let errState;
        let transformed;
        try {
          transformed = this.format.transform(
            Object.assign({}, chunks[i].chunk),
            this.format.options
          );
        } catch (err) {
          errState = err;
        }
        if (errState || !transformed) {
          chunks[i].callback();
          if (errState) {
            callback(null);
            throw errState;
          }
        } else {
          this.log(transformed, chunks[i].callback);
        }
      }
      return callback(null);
    };
    TransportStream.prototype._accept = function _accept(write) {
      const info = write.chunk;
      if (this.silent) {
        return false;
      }
      const level = this.level || this.parent && this.parent.level;
      if (info.exception === true || !level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (this.handleExceptions || info.exception !== true) {
          return true;
        }
      }
      return false;
    };
    TransportStream.prototype._nop = function _nop() {
      return void 0;
    };
  }
});

// node_modules/winston-transport/legacy.js
var require_legacy = __commonJS({
  "node_modules/winston-transport/legacy.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var { LEVEL } = require_triple_beam();
    var TransportStream = require_modern();
    var LegacyTransportStream = module2.exports = function LegacyTransportStream2(options = {}) {
      TransportStream.call(this, options);
      if (!options.transport || typeof options.transport.log !== "function") {
        throw new Error("Invalid transport, must be an object with a log method.");
      }
      this.transport = options.transport;
      this.level = this.level || options.transport.level;
      this.handleExceptions = this.handleExceptions || options.transport.handleExceptions;
      this._deprecated();
      function transportError(err) {
        this.emit("error", err, this.transport);
      }
      if (!this.transport.__winstonError) {
        this.transport.__winstonError = transportError.bind(this);
        this.transport.on("error", this.transport.__winstonError);
      }
    };
    util.inherits(LegacyTransportStream, TransportStream);
    LegacyTransportStream.prototype._write = function _write(info, enc, callback) {
      if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
      }
      if (!this.level || this.levels[this.level] >= this.levels[info[LEVEL]]) {
        this.transport.log(info[LEVEL], info.message, info, this._nop);
      }
      callback(null);
    };
    LegacyTransportStream.prototype._writev = function _writev(chunks, callback) {
      for (let i = 0; i < chunks.length; i++) {
        if (this._accept(chunks[i])) {
          this.transport.log(
            chunks[i].chunk[LEVEL],
            chunks[i].chunk.message,
            chunks[i].chunk,
            this._nop
          );
          chunks[i].callback();
        }
      }
      return callback(null);
    };
    LegacyTransportStream.prototype._deprecated = function _deprecated() {
      console.error([
        `${this.transport.name} is a legacy winston transport. Consider upgrading: `,
        "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md"
      ].join("\n"));
    };
    LegacyTransportStream.prototype.close = function close() {
      if (this.transport.close) {
        this.transport.close();
      }
      if (this.transport.__winstonError) {
        this.transport.removeListener("error", this.transport.__winstonError);
        this.transport.__winstonError = null;
      }
    };
  }
});

// node_modules/winston-transport/index.js
var require_winston_transport = __commonJS({
  "node_modules/winston-transport/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_modern();
    module2.exports.LegacyTransportStream = require_legacy();
  }
});

// node_modules/winston/lib/winston/transports/console.js
var require_console = __commonJS({
  "node_modules/winston/lib/winston/transports/console.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var { LEVEL, MESSAGE } = require_triple_beam();
    var TransportStream = require_winston_transport();
    module2.exports = class Console extends TransportStream {
      /**
       * Constructor function for the Console transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        this.name = options.name || "console";
        this.stderrLevels = this._stringArrayToSet(options.stderrLevels);
        this.consoleWarnLevels = this._stringArrayToSet(options.consoleWarnLevels);
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
        this.setMaxListeners(30);
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        setImmediate(() => this.emit("logged", info));
        if (this.stderrLevels[info[LEVEL]]) {
          if (console._stderr) {
            console._stderr.write(`${info[MESSAGE]}${this.eol}`);
          } else {
            console.error(info[MESSAGE]);
          }
          if (callback) {
            callback();
          }
          return;
        } else if (this.consoleWarnLevels[info[LEVEL]]) {
          if (console._stderr) {
            console._stderr.write(`${info[MESSAGE]}${this.eol}`);
          } else {
            console.warn(info[MESSAGE]);
          }
          if (callback) {
            callback();
          }
          return;
        }
        if (console._stdout) {
          console._stdout.write(`${info[MESSAGE]}${this.eol}`);
        } else {
          console.log(info[MESSAGE]);
        }
        if (callback) {
          callback();
        }
      }
      /**
       * Returns a Set-like object with strArray's elements as keys (each with the
       * value true).
       * @param {Array} strArray - Array of Set-elements as strings.
       * @param {?string} [errMsg] - Custom error message thrown on invalid input.
       * @returns {Object} - TODO: add return description.
       * @private
       */
      _stringArrayToSet(strArray, errMsg) {
        if (!strArray)
          return {};
        errMsg = errMsg || "Cannot make set from type other than Array of string elements";
        if (!Array.isArray(strArray)) {
          throw new Error(errMsg);
        }
        return strArray.reduce((set, el) => {
          if (typeof el !== "string") {
            throw new Error(errMsg);
          }
          set[el] = true;
          return set;
        }, {});
      }
    };
  }
});

// node_modules/async/internal/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/async/internal/isArrayLike.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isArrayLike2;
    function isArrayLike2(value) {
      return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
    }
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS({
  "node_modules/async/internal/initialParams.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(fn) {
      return function(...args) {
        var callback = args.pop();
        return fn.call(this, args, callback);
      };
    };
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS({
  "node_modules/async/internal/setImmediate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.fallback = fallback;
    exports2.wrap = wrap;
    var hasQueueMicrotask = exports2.hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
    var hasSetImmediate = exports2.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = exports2.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
      setTimeout(fn, 0);
    }
    function wrap(defer) {
      return (fn, ...args) => defer(() => fn(...args));
    }
    var _defer;
    if (hasQueueMicrotask) {
      _defer = queueMicrotask;
    } else if (hasSetImmediate) {
      _defer = setImmediate;
    } else if (hasNextTick) {
      _defer = process.nextTick;
    } else {
      _defer = fallback;
    }
    exports2.default = wrap(_defer);
  }
});

// node_modules/async/asyncify.js
var require_asyncify = __commonJS({
  "node_modules/async/asyncify.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = asyncify;
    var _initialParams = require_initialParams();
    var _initialParams2 = _interopRequireDefault(_initialParams);
    var _setImmediate = require_setImmediate();
    var _setImmediate2 = _interopRequireDefault(_setImmediate);
    var _wrapAsync = require_wrapAsync();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncify(func) {
      if ((0, _wrapAsync.isAsync)(func)) {
        return function(...args) {
          const callback = args.pop();
          const promise = func.apply(this, args);
          return handlePromise(promise, callback);
        };
      }
      return (0, _initialParams2.default)(function(args, callback) {
        var result;
        try {
          result = func.apply(this, args);
        } catch (e) {
          return callback(e);
        }
        if (result && typeof result.then === "function") {
          return handlePromise(result, callback);
        } else {
          callback(null, result);
        }
      });
    }
    function handlePromise(promise, callback) {
      return promise.then((value) => {
        invokeCallback(callback, null, value);
      }, (err) => {
        invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
      });
    }
    function invokeCallback(callback, error, value) {
      try {
        callback(error, value);
      } catch (err) {
        (0, _setImmediate2.default)((e) => {
          throw e;
        }, err);
      }
    }
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS({
  "node_modules/async/internal/wrapAsync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isAsyncIterable = exports2.isAsyncGenerator = exports2.isAsync = void 0;
    var _asyncify = require_asyncify();
    var _asyncify2 = _interopRequireDefault(_asyncify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isAsync(fn) {
      return fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function isAsyncGenerator(fn) {
      return fn[Symbol.toStringTag] === "AsyncGenerator";
    }
    function isAsyncIterable(obj) {
      return typeof obj[Symbol.asyncIterator] === "function";
    }
    function wrapAsync(asyncFn) {
      if (typeof asyncFn !== "function")
        throw new Error("expected a function");
      return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
    }
    exports2.default = wrapAsync;
    exports2.isAsync = isAsync;
    exports2.isAsyncGenerator = isAsyncGenerator;
    exports2.isAsyncIterable = isAsyncIterable;
  }
});

// node_modules/async/internal/awaitify.js
var require_awaitify = __commonJS({
  "node_modules/async/internal/awaitify.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = awaitify;
    function awaitify(asyncFn, arity) {
      if (!arity)
        arity = asyncFn.length;
      if (!arity)
        throw new Error("arity is undefined");
      function awaitable(...args) {
        if (typeof args[arity - 1] === "function") {
          return asyncFn.apply(this, args);
        }
        return new Promise((resolve, reject2) => {
          args[arity - 1] = (err, ...cbArgs) => {
            if (err)
              return reject2(err);
            resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
          };
          asyncFn.apply(this, args);
        });
      }
      return awaitable;
    }
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/parallel.js
var require_parallel = __commonJS({
  "node_modules/async/internal/parallel.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.default = (0, _awaitify2.default)((eachfn, tasks, callback) => {
      var results = (0, _isArrayLike2.default)(tasks) ? [] : {};
      eachfn(tasks, (task, key, taskCb) => {
        (0, _wrapAsync2.default)(task)((err, ...result) => {
          if (result.length < 2) {
            [result] = result;
          }
          results[key] = result;
          taskCb(err);
        });
      }, (err) => callback(err, results));
    }, 3);
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/once.js
var require_once = __commonJS({
  "node_modules/async/internal/once.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = once;
    function once(fn) {
      function wrapper(...args) {
        if (fn === null)
          return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      }
      Object.assign(wrapper, fn);
      return wrapper;
    }
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/getIterator.js
var require_getIterator = __commonJS({
  "node_modules/async/internal/getIterator.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(coll) {
      return coll[Symbol.iterator] && coll[Symbol.iterator]();
    };
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/iterator.js
var require_iterator = __commonJS({
  "node_modules/async/internal/iterator.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = createIterator;
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _getIterator = require_getIterator();
    var _getIterator2 = _interopRequireDefault(_getIterator);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function createArrayIterator(coll) {
      var i = -1;
      var len = coll.length;
      return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
      };
    }
    function createES2015Iterator(iterator) {
      var i = -1;
      return function next() {
        var item = iterator.next();
        if (item.done)
          return null;
        i++;
        return { value: item.value, key: i };
      };
    }
    function createObjectIterator(obj) {
      var okeys = obj ? Object.keys(obj) : [];
      var i = -1;
      var len = okeys.length;
      return function next() {
        var key = okeys[++i];
        if (key === "__proto__") {
          return next();
        }
        return i < len ? { value: obj[key], key } : null;
      };
    }
    function createIterator(coll) {
      if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
      }
      var iterator = (0, _getIterator2.default)(coll);
      return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS({
  "node_modules/async/internal/onlyOnce.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = onlyOnce;
    function onlyOnce(fn) {
      return function(...args) {
        if (fn === null)
          throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      };
    }
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/breakLoop.js
var require_breakLoop = __commonJS({
  "node_modules/async/internal/breakLoop.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var breakLoop = {};
    exports2.default = breakLoop;
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/asyncEachOfLimit.js
var require_asyncEachOfLimit = __commonJS({
  "node_modules/async/internal/asyncEachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = asyncEachOfLimit;
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncEachOfLimit(generator, limit, iteratee, callback) {
      let done = false;
      let canceled = false;
      let awaiting = false;
      let running = 0;
      let idx = 0;
      function replenish() {
        if (running >= limit || awaiting || done)
          return;
        awaiting = true;
        generator.next().then(({ value, done: iterDone }) => {
          if (canceled || done)
            return;
          awaiting = false;
          if (iterDone) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running++;
          iteratee(value, idx, iterateeCallback);
          idx++;
          replenish();
        }).catch(handleError);
      }
      function iterateeCallback(err, result) {
        running -= 1;
        if (canceled)
          return;
        if (err)
          return handleError(err);
        if (err === false) {
          done = true;
          canceled = true;
          return;
        }
        if (result === _breakLoop2.default || done && running <= 0) {
          done = true;
          return callback(null);
        }
        replenish();
      }
      function handleError(err) {
        if (canceled)
          return;
        awaiting = false;
        done = true;
        callback(err);
      }
      replenish();
    }
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit = __commonJS({
  "node_modules/async/internal/eachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _iterator = require_iterator();
    var _iterator2 = _interopRequireDefault(_iterator);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _asyncEachOfLimit = require_asyncEachOfLimit();
    var _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.default = (limit) => {
      return (obj, iteratee, callback) => {
        callback = (0, _once2.default)(callback);
        if (limit <= 0) {
          throw new RangeError("concurrency limit cannot be less than 1");
        }
        if (!obj) {
          return callback(null);
        }
        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
          return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
        }
        if ((0, _wrapAsync.isAsyncIterable)(obj)) {
          return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
          if (canceled)
            return;
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (err === false) {
            done = true;
            canceled = true;
          } else if (value === _breakLoop2.default || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    };
    module2.exports = exports2.default;
  }
});

// node_modules/async/eachOfLimit.js
var require_eachOfLimit2 = __commonJS({
  "node_modules/async/eachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOfLimit2 = require_eachOfLimit();
    var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfLimit(coll, limit, iteratee, callback) {
      return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOfLimit, 4);
    module2.exports = exports2.default;
  }
});

// node_modules/async/eachOfSeries.js
var require_eachOfSeries = __commonJS({
  "node_modules/async/eachOfSeries.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfSeries(coll, iteratee, callback) {
      return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOfSeries, 3);
    module2.exports = exports2.default;
  }
});

// node_modules/async/series.js
var require_series = __commonJS({
  "node_modules/async/series.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = series;
    var _parallel2 = require_parallel();
    var _parallel3 = _interopRequireDefault(_parallel2);
    var _eachOfSeries = require_eachOfSeries();
    var _eachOfSeries2 = _interopRequireDefault(_eachOfSeries);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function series(tasks, callback) {
      return (0, _parallel3.default)(_eachOfSeries2.default, tasks, callback);
    }
    module2.exports = exports2.default;
  }
});

// node_modules/winston/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream2 = __commonJS({
  "node_modules/winston/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/winston/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list2 = __commonJS({
  "node_modules/winston/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance2, Constructor) {
      if (!(instance2 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require("buffer");
    var Buffer4 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer4.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join2(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next)
            ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer4.alloc(0);
          var ret = Buffer4.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first2() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer4.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/winston/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS({
  "node_modules/winston/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/winston/node_modules/readable-stream/errors.js
var require_errors3 = __commonJS({
  "node_modules/winston/node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes2(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes2(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/winston/node_modules/readable-stream/lib/internal/streams/state.js
var require_state2 = __commonJS({
  "node_modules/winston/node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors3().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/winston/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable2 = __commonJS({
  "node_modules/winston/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream2();
    var Buffer4 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer4.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy2();
    var _require = require_state2();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors3().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex2();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex2();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer4.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer4.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last2 = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last2) {
          last2.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/winston/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex2 = __commonJS({
  "node_modules/winston/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys3 = [];
      for (var key in obj)
        keys3.push(key);
      return keys3;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable2();
    var Writable = require_stream_writable2();
    require_inherits()(Duplex, Readable);
    {
      keys2 = objectKeys(Writable.prototype);
      for (v = 0; v < keys2.length; v++) {
        method = keys2[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys2;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/winston/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream2 = __commonJS({
  "node_modules/winston/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors3().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop2() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop2);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/winston/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator2 = __commonJS({
  "node_modules/winston/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream2();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject2) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject2);
        }, reject2);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject2) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject2(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject2) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject2(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject2) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject2;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject2 = iterator[kLastReject];
          if (reject2 !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject2(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/winston/node_modules/readable-stream/lib/internal/streams/from.js
var require_from2 = __commonJS({
  "node_modules/winston/node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject2, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject2(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject2) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject2, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject2, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE = require_errors3().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// node_modules/winston/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable2 = __commonJS({
  "node_modules/winston/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream2();
    var Buffer4 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer4.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list2();
    var destroyImpl = require_destroy2();
    var _require = require_state2();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors3().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex2();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex2();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer4.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer4.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf2(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf2(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator2();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get4() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from2();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf2(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/winston/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/winston/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors3().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex2();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/winston/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/winston/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/winston/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/winston/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors3().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop2(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream2();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop2;
      if (typeof streams[streams.length - 1] !== "function")
        return noop2;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// node_modules/winston/node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/winston/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable2();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable2();
      exports2.Duplex = require_stream_duplex2();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
      exports2.finished = require_end_of_stream2();
      exports2.pipeline = require_pipeline();
    }
  }
});

// node_modules/@dabh/diagnostics/diagnostics.js
var require_diagnostics = __commonJS({
  "node_modules/@dabh/diagnostics/diagnostics.js"(exports2, module2) {
    var adapters = [];
    var modifiers = [];
    var logger = function devnull() {
    };
    function use(adapter) {
      if (~adapters.indexOf(adapter))
        return false;
      adapters.push(adapter);
      return true;
    }
    function set(custom) {
      logger = custom;
    }
    function enabled(namespace) {
      var async = [];
      for (var i = 0; i < adapters.length; i++) {
        if (adapters[i].async) {
          async.push(adapters[i]);
          continue;
        }
        if (adapters[i](namespace))
          return true;
      }
      if (!async.length)
        return false;
      return new Promise(function pinky(resolve) {
        Promise.all(
          async.map(function prebind(fn) {
            return fn(namespace);
          })
        ).then(function resolved(values2) {
          resolve(values2.some(Boolean));
        });
      });
    }
    function modify(fn) {
      if (~modifiers.indexOf(fn))
        return false;
      modifiers.push(fn);
      return true;
    }
    function write() {
      logger.apply(logger, arguments);
    }
    function process2(message) {
      for (var i = 0; i < modifiers.length; i++) {
        message = modifiers[i].apply(modifiers[i], arguments);
      }
      return message;
    }
    function introduce(fn, options) {
      var has2 = Object.prototype.hasOwnProperty;
      for (var key in options) {
        if (has2.call(options, key)) {
          fn[key] = options[key];
        }
      }
      return fn;
    }
    function nope(options) {
      options.enabled = false;
      options.modify = modify;
      options.set = set;
      options.use = use;
      return introduce(function diagnopes() {
        return false;
      }, options);
    }
    function yep(options) {
      function diagnostics() {
        var args = Array.prototype.slice.call(arguments, 0);
        write.call(write, options, process2(args, options));
        return true;
      }
      options.enabled = true;
      options.modify = modify;
      options.set = set;
      options.use = use;
      return introduce(diagnostics, options);
    }
    module2.exports = function create(diagnostics) {
      diagnostics.introduce = introduce;
      diagnostics.enabled = enabled;
      diagnostics.process = process2;
      diagnostics.modify = modify;
      diagnostics.write = write;
      diagnostics.nope = nope;
      diagnostics.yep = yep;
      diagnostics.set = set;
      diagnostics.use = use;
      return diagnostics;
    };
  }
});

// node_modules/@dabh/diagnostics/node/production.js
var require_production = __commonJS({
  "node_modules/@dabh/diagnostics/node/production.js"(exports2, module2) {
    var create = require_diagnostics();
    var diagnostics = create(function prod(namespace, options) {
      options = options || {};
      options.namespace = namespace;
      options.prod = true;
      options.dev = false;
      if (!(options.force || prod.force))
        return prod.nope(options);
      return prod.yep(options);
    });
    module2.exports = diagnostics;
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/is-arrayish/index.js"(exports2, module2) {
    module2.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "node_modules/simple-swizzle/index.js"(exports2, module2) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat = Array.prototype.concat;
    var slice = Array.prototype.slice;
    var swizzle = module2.exports = function swizzle2(args) {
      var results = [];
      for (var i = 0, len = args.length; i < len; i++) {
        var arg = args[i];
        if (isArrayish(arg)) {
          results = concat.call(results, slice.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});

// node_modules/color-string/index.js
var require_color_string = __commonJS({
  "node_modules/color-string/index.js"(exports2, module2) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty18 = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name in colorNames) {
      if (hasOwnProperty18.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module2.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb = [0, 0, 0, 1];
      var match;
      var i;
      var hexAlpha;
      if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];
        for (i = 0; i < 3; i++) {
          var i2 = i * 2;
          rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i + 1], 0);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(per)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty18.call(colorNames, match[1])) {
          return null;
        }
        rgb = colorNames[match[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i = 0; i < 3; i++) {
        rgb[i] = clamp(rgb[i], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hsl);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var s = clamp(parseFloat(match[2]), 0, 100);
        var l = clamp(parseFloat(match[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s, l, a];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var w = clamp(parseFloat(match[2]), 0, 100);
        var b = clamp(parseFloat(match[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r = Math.round(rgba[0] / 255 * 100);
      var g = Math.round(rgba[1] / 255 * 100);
      var b = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
  }
});

// node_modules/color/node_modules/color-name/index.js
var require_color_name2 = __commonJS({
  "node_modules/color/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color/node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name2();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert8 = module2.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert8) {
      if (convert8.hasOwnProperty(model)) {
        if (!("channels" in convert8[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert8[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert8[model].labels.length !== convert8[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert8[model].channels;
        labels = convert8[model].labels;
        delete convert8[model].channels;
        delete convert8[model].labels;
        Object.defineProperty(convert8[model], "channels", { value: channels });
        Object.defineProperty(convert8[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert8.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert8.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert8.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert8.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert8.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert8.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert8.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert8.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert8.rgb.lab = function(rgb) {
      var xyz = convert8.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert8.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert8.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert8.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert8.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert8.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert8.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert8.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert8.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert8.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert8.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert8.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert8.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert8.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert8.hsv.ansi16 = function(args) {
      return convert8.rgb.ansi16(convert8.hsv.rgb(args), args[2]);
    };
    convert8.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert8.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert8.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert8.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert8.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert8.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert8.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2 * s * l;
      } else {
        c = 2 * s * (1 - l);
      }
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert8.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert8.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert8.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      var f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert8.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c) + 0.5 * c;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert8.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert8.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert8.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert8.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert8.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert8.gray.hsl = convert8.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert8.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert8.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert8.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert8.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert8.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color/node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color/node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path4 = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path4.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path4;
      return fn;
    }
    module2.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color/node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert8 = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert8[fromModel] = {};
      Object.defineProperty(convert8[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert8[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert8[fromModel][toModel] = wrapRounded(fn);
        convert8[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert8;
  }
});

// node_modules/color/index.js
var require_color = __commonJS({
  "node_modules/color/index.js"(exports2, module2) {
    "use strict";
    var colorString = require_color_string();
    var convert8 = require_color_convert();
    var _slice = [].slice;
    var skippedModels = [
      // to be honest, I don't really feel like keyword belongs in color convert, but eh.
      "keyword",
      // gray conflicts with some method names, and has its own method defined.
      "gray",
      // shouldn't really be in color-convert either...
      "hex"
    ];
    var hashedModelKeys = {};
    Object.keys(convert8).forEach(function(model) {
      hashedModelKeys[_slice.call(convert8[model].labels).sort().join("")] = model;
    });
    var limiters = {};
    function Color(obj, model) {
      if (!(this instanceof Color)) {
        return new Color(obj, model);
      }
      if (model && model in skippedModels) {
        model = null;
      }
      if (model && !(model in convert8)) {
        throw new Error("Unknown model: " + model);
      }
      var i;
      var channels;
      if (obj == null) {
        this.model = "rgb";
        this.color = [0, 0, 0];
        this.valpha = 1;
      } else if (obj instanceof Color) {
        this.model = obj.model;
        this.color = obj.color.slice();
        this.valpha = obj.valpha;
      } else if (typeof obj === "string") {
        var result = colorString.get(obj);
        if (result === null) {
          throw new Error("Unable to parse color from string: " + obj);
        }
        this.model = result.model;
        channels = convert8[this.model].channels;
        this.color = result.value.slice(0, channels);
        this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
      } else if (obj.length) {
        this.model = model || "rgb";
        channels = convert8[this.model].channels;
        var newArr = _slice.call(obj, 0, channels);
        this.color = zeroArray(newArr, channels);
        this.valpha = typeof obj[channels] === "number" ? obj[channels] : 1;
      } else if (typeof obj === "number") {
        obj &= 16777215;
        this.model = "rgb";
        this.color = [
          obj >> 16 & 255,
          obj >> 8 & 255,
          obj & 255
        ];
        this.valpha = 1;
      } else {
        this.valpha = 1;
        var keys2 = Object.keys(obj);
        if ("alpha" in obj) {
          keys2.splice(keys2.indexOf("alpha"), 1);
          this.valpha = typeof obj.alpha === "number" ? obj.alpha : 0;
        }
        var hashedKeys = keys2.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
          throw new Error("Unable to parse color from object: " + JSON.stringify(obj));
        }
        this.model = hashedModelKeys[hashedKeys];
        var labels = convert8[this.model].labels;
        var color = [];
        for (i = 0; i < labels.length; i++) {
          color.push(obj[labels[i]]);
        }
        this.color = zeroArray(color);
      }
      if (limiters[this.model]) {
        channels = convert8[this.model].channels;
        for (i = 0; i < channels; i++) {
          var limit = limiters[this.model][i];
          if (limit) {
            this.color[i] = limit(this.color[i]);
          }
        }
      }
      this.valpha = Math.max(0, Math.min(1, this.valpha));
      if (Object.freeze) {
        Object.freeze(this);
      }
    }
    Color.prototype = {
      toString: function() {
        return this.string();
      },
      toJSON: function() {
        return this[this.model]();
      },
      string: function(places) {
        var self2 = this.model in colorString.to ? this : this.rgb();
        self2 = self2.round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to[self2.model](args);
      },
      percentString: function(places) {
        var self2 = this.rgb().round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to.rgb.percent(args);
      },
      array: function() {
        return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
      },
      object: function() {
        var result = {};
        var channels = convert8[this.model].channels;
        var labels = convert8[this.model].labels;
        for (var i = 0; i < channels; i++) {
          result[labels[i]] = this.color[i];
        }
        if (this.valpha !== 1) {
          result.alpha = this.valpha;
        }
        return result;
      },
      unitArray: function() {
        var rgb = this.rgb().color;
        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;
        if (this.valpha !== 1) {
          rgb.push(this.valpha);
        }
        return rgb;
      },
      unitObject: function() {
        var rgb = this.rgb().object();
        rgb.r /= 255;
        rgb.g /= 255;
        rgb.b /= 255;
        if (this.valpha !== 1) {
          rgb.alpha = this.valpha;
        }
        return rgb;
      },
      round: function(places) {
        places = Math.max(places || 0, 0);
        return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
      },
      alpha: function(val) {
        if (arguments.length) {
          return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
        }
        return this.valpha;
      },
      // rgb
      red: getset("rgb", 0, maxfn(255)),
      green: getset("rgb", 1, maxfn(255)),
      blue: getset("rgb", 2, maxfn(255)),
      hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(val) {
        return (val % 360 + 360) % 360;
      }),
      // eslint-disable-line brace-style
      saturationl: getset("hsl", 1, maxfn(100)),
      lightness: getset("hsl", 2, maxfn(100)),
      saturationv: getset("hsv", 1, maxfn(100)),
      value: getset("hsv", 2, maxfn(100)),
      chroma: getset("hcg", 1, maxfn(100)),
      gray: getset("hcg", 2, maxfn(100)),
      white: getset("hwb", 1, maxfn(100)),
      wblack: getset("hwb", 2, maxfn(100)),
      cyan: getset("cmyk", 0, maxfn(100)),
      magenta: getset("cmyk", 1, maxfn(100)),
      yellow: getset("cmyk", 2, maxfn(100)),
      black: getset("cmyk", 3, maxfn(100)),
      x: getset("xyz", 0, maxfn(100)),
      y: getset("xyz", 1, maxfn(100)),
      z: getset("xyz", 2, maxfn(100)),
      l: getset("lab", 0, maxfn(100)),
      a: getset("lab", 1),
      b: getset("lab", 2),
      keyword: function(val) {
        if (arguments.length) {
          return new Color(val);
        }
        return convert8[this.model].keyword(this.color);
      },
      hex: function(val) {
        if (arguments.length) {
          return new Color(val);
        }
        return colorString.to.hex(this.rgb().round().color);
      },
      rgbNumber: function() {
        var rgb = this.rgb().color;
        return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
      },
      luminosity: function() {
        var rgb = this.rgb().color;
        var lum = [];
        for (var i = 0; i < rgb.length; i++) {
          var chan = rgb[i] / 255;
          lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast: function(color2) {
        var lum1 = this.luminosity();
        var lum2 = color2.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level: function(color2) {
        var contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7.1) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      },
      isDark: function() {
        var rgb = this.rgb().color;
        var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1e3;
        return yiq < 128;
      },
      isLight: function() {
        return !this.isDark();
      },
      negate: function() {
        var rgb = this.rgb();
        for (var i = 0; i < 3; i++) {
          rgb.color[i] = 255 - rgb.color[i];
        }
        return rgb;
      },
      lighten: function(ratio) {
        var hsl = this.hsl();
        hsl.color[2] += hsl.color[2] * ratio;
        return hsl;
      },
      darken: function(ratio) {
        var hsl = this.hsl();
        hsl.color[2] -= hsl.color[2] * ratio;
        return hsl;
      },
      saturate: function(ratio) {
        var hsl = this.hsl();
        hsl.color[1] += hsl.color[1] * ratio;
        return hsl;
      },
      desaturate: function(ratio) {
        var hsl = this.hsl();
        hsl.color[1] -= hsl.color[1] * ratio;
        return hsl;
      },
      whiten: function(ratio) {
        var hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
      },
      blacken: function(ratio) {
        var hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
      },
      grayscale: function() {
        var rgb = this.rgb().color;
        var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        return Color.rgb(val, val, val);
      },
      fade: function(ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
      },
      opaquer: function(ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
      },
      rotate: function(degrees) {
        var hsl = this.hsl();
        var hue = hsl.color[0];
        hue = (hue + degrees) % 360;
        hue = hue < 0 ? 360 + hue : hue;
        hsl.color[0] = hue;
        return hsl;
      },
      mix: function(mixinColor, weight) {
        if (!mixinColor || !mixinColor.rgb) {
          throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
        }
        var color1 = mixinColor.rgb();
        var color2 = this.rgb();
        var p = weight === void 0 ? 0.5 : weight;
        var w = 2 * p - 1;
        var a = color1.alpha() - color2.alpha();
        var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        var w2 = 1 - w1;
        return Color.rgb(
          w1 * color1.red() + w2 * color2.red(),
          w1 * color1.green() + w2 * color2.green(),
          w1 * color1.blue() + w2 * color2.blue(),
          color1.alpha() * p + color2.alpha() * (1 - p)
        );
      }
    };
    Object.keys(convert8).forEach(function(model) {
      if (skippedModels.indexOf(model) !== -1) {
        return;
      }
      var channels = convert8[model].channels;
      Color.prototype[model] = function() {
        if (this.model === model) {
          return new Color(this);
        }
        if (arguments.length) {
          return new Color(arguments, model);
        }
        var newAlpha = typeof arguments[channels] === "number" ? channels : this.valpha;
        return new Color(assertArray(convert8[this.model][model].raw(this.color)).concat(newAlpha), model);
      };
      Color[model] = function(color) {
        if (typeof color === "number") {
          color = zeroArray(_slice.call(arguments), channels);
        }
        return new Color(color, model);
      };
    });
    function roundTo(num, places) {
      return Number(num.toFixed(places));
    }
    function roundToPlace(places) {
      return function(num) {
        return roundTo(num, places);
      };
    }
    function getset(model, channel, modifier) {
      model = Array.isArray(model) ? model : [model];
      model.forEach(function(m) {
        (limiters[m] || (limiters[m] = []))[channel] = modifier;
      });
      model = model[0];
      return function(val) {
        var result;
        if (arguments.length) {
          if (modifier) {
            val = modifier(val);
          }
          result = this[model]();
          result.color[channel] = val;
          return result;
        }
        result = this[model]().color[channel];
        if (modifier) {
          result = modifier(result);
        }
        return result;
      };
    }
    function maxfn(max) {
      return function(v) {
        return Math.max(0, Math.min(max, v));
      };
    }
    function assertArray(val) {
      return Array.isArray(val) ? val : [val];
    }
    function zeroArray(arr, length) {
      for (var i = 0; i < length; i++) {
        if (typeof arr[i] !== "number") {
          arr[i] = 0;
        }
      }
      return arr;
    }
    module2.exports = Color;
  }
});

// node_modules/text-hex/index.js
var require_text_hex = __commonJS({
  "node_modules/text-hex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function hex(str) {
      for (var i = 0, hash = 0; i < str.length; hash = str.charCodeAt(i++) + ((hash << 5) - hash))
        ;
      var color = Math.floor(
        Math.abs(
          Math.sin(hash) * 1e4 % 1 * 16777216
        )
      ).toString(16);
      return "#" + Array(6 - color.length + 1).join("0") + color;
    };
  }
});

// node_modules/colorspace/index.js
var require_colorspace = __commonJS({
  "node_modules/colorspace/index.js"(exports2, module2) {
    "use strict";
    var color = require_color();
    var hex = require_text_hex();
    module2.exports = function colorspace(namespace, delimiter) {
      var split = namespace.split(delimiter || ":");
      var base = hex(split[0]);
      if (!split.length)
        return base;
      for (var i = 0, l = split.length - 1; i < l; i++) {
        base = color(base).mix(color(hex(split[i + 1]))).saturate(1).hex();
      }
      return base;
    };
  }
});

// node_modules/kuler/index.js
var require_kuler = __commonJS({
  "node_modules/kuler/index.js"(exports2, module2) {
    "use strict";
    function Kuler(text, color) {
      if (color)
        return new Kuler(text).style(color);
      if (!(this instanceof Kuler))
        return new Kuler(text);
      this.text = text;
    }
    Kuler.prototype.prefix = "\x1B[";
    Kuler.prototype.suffix = "m";
    Kuler.prototype.hex = function hex(color) {
      color = color[0] === "#" ? color.substring(1) : color;
      if (color.length === 3) {
        color = color.split("");
        color[5] = color[2];
        color[4] = color[2];
        color[3] = color[1];
        color[2] = color[1];
        color[1] = color[0];
        color = color.join("");
      }
      var r = color.substring(0, 2), g = color.substring(2, 4), b = color.substring(4, 6);
      return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)];
    };
    Kuler.prototype.rgb = function rgb(r, g, b) {
      var red = r / 255 * 5, green = g / 255 * 5, blue = b / 255 * 5;
      return this.ansi(red, green, blue);
    };
    Kuler.prototype.ansi = function ansi(r, g, b) {
      var red = Math.round(r), green = Math.round(g), blue = Math.round(b);
      return 16 + red * 36 + green * 6 + blue;
    };
    Kuler.prototype.reset = function reset() {
      return this.prefix + "39;49" + this.suffix;
    };
    Kuler.prototype.style = function style(color) {
      return this.prefix + "38;5;" + this.rgb.apply(this, this.hex(color)) + this.suffix + this.text + this.reset();
    };
    module2.exports = Kuler;
  }
});

// node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js
var require_namespace_ansi = __commonJS({
  "node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js"(exports2, module2) {
    var colorspace = require_colorspace();
    var kuler = require_kuler();
    module2.exports = function ansiModifier(args, options) {
      var namespace = options.namespace;
      var ansi = options.colors !== false ? kuler(namespace + ":", colorspace(namespace)) : namespace + ":";
      args[0] = ansi + " " + args[0];
      return args;
    };
  }
});

// node_modules/enabled/index.js
var require_enabled = __commonJS({
  "node_modules/enabled/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function enabled(name, variable) {
      if (!variable)
        return false;
      var variables = variable.split(/[\s,]+/), i = 0;
      for (; i < variables.length; i++) {
        variable = variables[i].replace("*", ".*?");
        if ("-" === variable.charAt(0)) {
          if (new RegExp("^" + variable.substr(1) + "$").test(name)) {
            return false;
          }
          continue;
        }
        if (new RegExp("^" + variable + "$").test(name)) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/@dabh/diagnostics/adapters/index.js
var require_adapters = __commonJS({
  "node_modules/@dabh/diagnostics/adapters/index.js"(exports2, module2) {
    var enabled = require_enabled();
    module2.exports = function create(fn) {
      return function adapter(namespace) {
        try {
          return enabled(namespace, fn());
        } catch (e) {
        }
        return false;
      };
    };
  }
});

// node_modules/@dabh/diagnostics/adapters/process.env.js
var require_process_env = __commonJS({
  "node_modules/@dabh/diagnostics/adapters/process.env.js"(exports2, module2) {
    var adapter = require_adapters();
    module2.exports = adapter(function processenv() {
      return process.env.DEBUG || process.env.DIAGNOSTICS;
    });
  }
});

// node_modules/@dabh/diagnostics/logger/console.js
var require_console2 = __commonJS({
  "node_modules/@dabh/diagnostics/logger/console.js"(exports2, module2) {
    module2.exports = function(meta, messages) {
      try {
        Function.prototype.apply.call(console.log, console, messages);
      } catch (e) {
      }
    };
  }
});

// node_modules/@dabh/diagnostics/node/development.js
var require_development = __commonJS({
  "node_modules/@dabh/diagnostics/node/development.js"(exports2, module2) {
    var create = require_diagnostics();
    var tty = require("tty").isatty(1);
    var diagnostics = create(function dev(namespace, options) {
      options = options || {};
      options.colors = "colors" in options ? options.colors : tty;
      options.namespace = namespace;
      options.prod = false;
      options.dev = true;
      if (!dev.enabled(namespace) && !(options.force || dev.force)) {
        return dev.nope(options);
      }
      return dev.yep(options);
    });
    diagnostics.modify(require_namespace_ansi());
    diagnostics.use(require_process_env());
    diagnostics.set(require_console2());
    module2.exports = diagnostics;
  }
});

// node_modules/@dabh/diagnostics/node/index.js
var require_node2 = __commonJS({
  "node_modules/@dabh/diagnostics/node/index.js"(exports2, module2) {
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_production();
    } else {
      module2.exports = require_development();
    }
  }
});

// node_modules/winston/lib/winston/tail-file.js
var require_tail_file = __commonJS({
  "node_modules/winston/lib/winston/tail-file.js"(exports2, module2) {
    "use strict";
    var fs4 = require("fs");
    var { StringDecoder } = require("string_decoder");
    var { Stream } = require_readable();
    function noop2() {
    }
    module2.exports = (options, iter) => {
      const buffer = Buffer.alloc(64 * 1024);
      const decode = new StringDecoder("utf8");
      const stream = new Stream();
      let buff = "";
      let pos = 0;
      let row = 0;
      if (options.start === -1) {
        delete options.start;
      }
      stream.readable = true;
      stream.destroy = () => {
        stream.destroyed = true;
        stream.emit("end");
        stream.emit("close");
      };
      fs4.open(options.file, "a+", "0644", (err, fd) => {
        if (err) {
          if (!iter) {
            stream.emit("error", err);
          } else {
            iter(err);
          }
          stream.destroy();
          return;
        }
        (function read() {
          if (stream.destroyed) {
            fs4.close(fd, noop2);
            return;
          }
          return fs4.read(fd, buffer, 0, buffer.length, pos, (error, bytes) => {
            if (error) {
              if (!iter) {
                stream.emit("error", error);
              } else {
                iter(error);
              }
              stream.destroy();
              return;
            }
            if (!bytes) {
              if (buff) {
                if (options.start == null || row > options.start) {
                  if (!iter) {
                    stream.emit("line", buff);
                  } else {
                    iter(null, buff);
                  }
                }
                row++;
                buff = "";
              }
              return setTimeout(read, 1e3);
            }
            let data = decode.write(buffer.slice(0, bytes));
            if (!iter) {
              stream.emit("data", data);
            }
            data = (buff + data).split(/\n+/);
            const l = data.length - 1;
            let i = 0;
            for (; i < l; i++) {
              if (options.start == null || row > options.start) {
                if (!iter) {
                  stream.emit("line", data[i]);
                } else {
                  iter(null, data[i]);
                }
              }
              row++;
            }
            buff = data[l];
            pos += bytes;
            return read();
          });
        })();
      });
      if (!iter) {
        return stream;
      }
      return stream.destroy;
    };
  }
});

// node_modules/winston/lib/winston/transports/file.js
var require_file = __commonJS({
  "node_modules/winston/lib/winston/transports/file.js"(exports2, module2) {
    "use strict";
    var fs4 = require("fs");
    var path4 = require("path");
    var asyncSeries = require_series();
    var zlib = require("zlib");
    var { MESSAGE } = require_triple_beam();
    var { Stream, PassThrough } = require_readable();
    var TransportStream = require_winston_transport();
    var debug = require_node2()("winston:file");
    var os = require("os");
    var tailFile = require_tail_file();
    module2.exports = class File extends TransportStream {
      /**
       * Constructor function for the File transport object responsible for
       * persisting log messages and metadata to one or more files.
       * @param {Object} options - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        this.name = options.name || "file";
        function throwIf(target, ...args) {
          args.slice(1).forEach((name) => {
            if (options[name]) {
              throw new Error(`Cannot set ${name} and ${target} together`);
            }
          });
        }
        this._stream = new PassThrough();
        this._stream.setMaxListeners(30);
        this._onError = this._onError.bind(this);
        if (options.filename || options.dirname) {
          throwIf("filename or dirname", "stream");
          this._basename = this.filename = options.filename ? path4.basename(options.filename) : "winston.log";
          this.dirname = options.dirname || path4.dirname(options.filename);
          this.options = options.options || { flags: "a" };
        } else if (options.stream) {
          console.warn("options.stream will be removed in winston@4. Use winston.transports.Stream");
          throwIf("stream", "filename", "maxsize");
          this._dest = this._stream.pipe(this._setupStream(options.stream));
          this.dirname = path4.dirname(this._dest.path);
        } else {
          throw new Error("Cannot log to file without filename or stream.");
        }
        this.maxsize = options.maxsize || null;
        this.rotationFormat = options.rotationFormat || false;
        this.zippedArchive = options.zippedArchive || false;
        this.maxFiles = options.maxFiles || null;
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
        this.tailable = options.tailable || false;
        this.lazy = options.lazy || false;
        this._size = 0;
        this._pendingSize = 0;
        this._created = 0;
        this._drain = false;
        this._opening = false;
        this._ending = false;
        this._fileExist = false;
        if (this.dirname)
          this._createLogDirIfNotExist(this.dirname);
        if (!this.lazy)
          this.open();
      }
      finishIfEnding() {
        if (this._ending) {
          if (this._opening) {
            this.once("open", () => {
              this._stream.once("finish", () => this.emit("finish"));
              setImmediate(() => this._stream.end());
            });
          } else {
            this._stream.once("finish", () => this.emit("finish"));
            setImmediate(() => this._stream.end());
          }
        }
      }
      /**
       * Core logging method exposed to Winston. Metadata is optional.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback = () => {
      }) {
        if (this.silent) {
          callback();
          return true;
        }
        if (this._drain) {
          this._stream.once("drain", () => {
            this._drain = false;
            this.log(info, callback);
          });
          return;
        }
        if (this._rotate) {
          this._stream.once("rotate", () => {
            this._rotate = false;
            this.log(info, callback);
          });
          return;
        }
        if (this.lazy) {
          if (!this._fileExist) {
            if (!this._opening) {
              this.open();
            }
            this.once("open", () => {
              this._fileExist = true;
              this.log(info, callback);
              return;
            });
            return;
          }
          if (this._needsNewFile(this._pendingSize)) {
            this._dest.once("close", () => {
              if (!this._opening) {
                this.open();
              }
              this.once("open", () => {
                this.log(info, callback);
                return;
              });
              return;
            });
            return;
          }
        }
        const output = `${info[MESSAGE]}${this.eol}`;
        const bytes = Buffer.byteLength(output);
        function logged() {
          this._size += bytes;
          this._pendingSize -= bytes;
          debug("logged %s %s", this._size, output);
          this.emit("logged", info);
          if (this._rotate) {
            return;
          }
          if (this._opening) {
            return;
          }
          if (!this._needsNewFile()) {
            return;
          }
          if (this.lazy) {
            this._endStream(() => {
              this.emit("fileclosed");
            });
            return;
          }
          this._rotate = true;
          this._endStream(() => this._rotateFile());
        }
        this._pendingSize += bytes;
        if (this._opening && !this.rotatedWhileOpening && this._needsNewFile(this._size + this._pendingSize)) {
          this.rotatedWhileOpening = true;
        }
        const written = this._stream.write(output, logged.bind(this));
        if (!written) {
          this._drain = true;
          this._stream.once("drain", () => {
            this._drain = false;
            callback();
          });
        } else {
          callback();
        }
        debug("written", written, this._drain);
        this.finishIfEnding();
        return written;
      }
      /**
       * Query the transport. Options object is optional.
       * @param {Object} options - Loggly-like query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       * TODO: Refactor me.
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = normalizeQuery(options);
        const file = path4.join(this.dirname, this.filename);
        let buff = "";
        let results = [];
        let row = 0;
        const stream = fs4.createReadStream(file, {
          encoding: "utf8"
        });
        stream.on("error", (err) => {
          if (stream.readable) {
            stream.destroy();
          }
          if (!callback) {
            return;
          }
          return err.code !== "ENOENT" ? callback(err) : callback(null, results);
        });
        stream.on("data", (data) => {
          data = (buff + data).split(/\n+/);
          const l = data.length - 1;
          let i = 0;
          for (; i < l; i++) {
            if (!options.start || row >= options.start) {
              add(data[i]);
            }
            row++;
          }
          buff = data[l];
        });
        stream.on("close", () => {
          if (buff) {
            add(buff, true);
          }
          if (options.order === "desc") {
            results = results.reverse();
          }
          if (callback)
            callback(null, results);
        });
        function add(buff2, attempt) {
          try {
            const log4 = JSON.parse(buff2);
            if (check(log4)) {
              push(log4);
            }
          } catch (e) {
            if (!attempt) {
              stream.emit("error", e);
            }
          }
        }
        function push(log4) {
          if (options.rows && results.length >= options.rows && options.order !== "desc") {
            if (stream.readable) {
              stream.destroy();
            }
            return;
          }
          if (options.fields) {
            log4 = options.fields.reduce((obj, key) => {
              obj[key] = log4[key];
              return obj;
            }, {});
          }
          if (options.order === "desc") {
            if (results.length >= options.rows) {
              results.shift();
            }
          }
          results.push(log4);
        }
        function check(log4) {
          if (!log4) {
            return;
          }
          if (typeof log4 !== "object") {
            return;
          }
          const time = new Date(log4.timestamp);
          if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log4.level) {
            return;
          }
          return true;
        }
        function normalizeQuery(options2) {
          options2 = options2 || {};
          options2.rows = options2.rows || options2.limit || 10;
          options2.start = options2.start || 0;
          options2.until = options2.until || /* @__PURE__ */ new Date();
          if (typeof options2.until !== "object") {
            options2.until = new Date(options2.until);
          }
          options2.from = options2.from || options2.until - 24 * 60 * 60 * 1e3;
          if (typeof options2.from !== "object") {
            options2.from = new Date(options2.from);
          }
          options2.order = options2.order || "desc";
          return options2;
        }
      }
      /**
       * Returns a log stream for this transport. Options object is optional.
       * @param {Object} options - Stream options for this instance.
       * @returns {Stream} - TODO: add return description.
       * TODO: Refactor me.
       */
      stream(options = {}) {
        const file = path4.join(this.dirname, this.filename);
        const stream = new Stream();
        const tail = {
          file,
          start: options.start
        };
        stream.destroy = tailFile(tail, (err, line) => {
          if (err) {
            return stream.emit("error", err);
          }
          try {
            stream.emit("data", line);
            line = JSON.parse(line);
            stream.emit("log", line);
          } catch (e) {
            stream.emit("error", e);
          }
        });
        return stream;
      }
      /**
       * Checks to see the filesize of.
       * @returns {undefined}
       */
      open() {
        if (!this.filename)
          return;
        if (this._opening)
          return;
        this._opening = true;
        this.stat((err, size) => {
          if (err) {
            return this.emit("error", err);
          }
          debug("stat done: %s { size: %s }", this.filename, size);
          this._size = size;
          this._dest = this._createStream(this._stream);
          this._opening = false;
          this.once("open", () => {
            if (this._stream.eventNames().includes("rotate")) {
              this._stream.emit("rotate");
            } else {
              this._rotate = false;
            }
          });
        });
      }
      /**
       * Stat the file and assess information in order to create the proper stream.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      stat(callback) {
        const target = this._getFile();
        const fullpath = path4.join(this.dirname, target);
        fs4.stat(fullpath, (err, stat) => {
          if (err && err.code === "ENOENT") {
            debug("ENOENT\xA0ok", fullpath);
            this.filename = target;
            return callback(null, 0);
          }
          if (err) {
            debug(`err ${err.code} ${fullpath}`);
            return callback(err);
          }
          if (!stat || this._needsNewFile(stat.size)) {
            return this._incFile(() => this.stat(callback));
          }
          this.filename = target;
          callback(null, stat.size);
        });
      }
      /**
       * Closes the stream associated with this instance.
       * @param {function} cb - TODO: add param description.
       * @returns {undefined}
       */
      close(cb) {
        if (!this._stream) {
          return;
        }
        this._stream.end(() => {
          if (cb) {
            cb();
          }
          this.emit("flush");
          this.emit("closed");
        });
      }
      /**
       * TODO: add method description.
       * @param {number} size - TODO: add param description.
       * @returns {undefined}
       */
      _needsNewFile(size) {
        size = size || this._size;
        return this.maxsize && size >= this.maxsize;
      }
      /**
       * TODO: add method description.
       * @param {Error} err - TODO: add param description.
       * @returns {undefined}
       */
      _onError(err) {
        this.emit("error", err);
      }
      /**
       * TODO: add method description.
       * @param {Stream} stream - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      _setupStream(stream) {
        stream.on("error", this._onError);
        return stream;
      }
      /**
       * TODO: add method description.
       * @param {Stream} stream - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      _cleanupStream(stream) {
        stream.removeListener("error", this._onError);
        stream.destroy();
        return stream;
      }
      /**
       * TODO: add method description.
       */
      _rotateFile() {
        this._incFile(() => this.open());
      }
      /**
       * Unpipe from the stream that has been marked as full and end it so it
       * flushes to disk.
       *
       * @param {function} callback - Callback for when the current file has closed.
       * @private
       */
      _endStream(callback = () => {
      }) {
        if (this._dest) {
          this._stream.unpipe(this._dest);
          this._dest.end(() => {
            this._cleanupStream(this._dest);
            callback();
          });
        } else {
          callback();
        }
      }
      /**
       * Returns the WritableStream for the active file on this instance. If we
       * should gzip the file then a zlib stream is returned.
       *
       * @param {ReadableStream} source –PassThrough to pipe to the file when open.
       * @returns {WritableStream} Stream that writes to disk for the active file.
       */
      _createStream(source) {
        const fullpath = path4.join(this.dirname, this.filename);
        debug("create stream start", fullpath, this.options);
        const dest = fs4.createWriteStream(fullpath, this.options).on("error", (err) => debug(err)).on("close", () => debug("close", dest.path, dest.bytesWritten)).on("open", () => {
          debug("file open ok", fullpath);
          this.emit("open", fullpath);
          source.pipe(dest);
          if (this.rotatedWhileOpening) {
            this._stream = new PassThrough();
            this._stream.setMaxListeners(30);
            this._rotateFile();
            this.rotatedWhileOpening = false;
            this._cleanupStream(dest);
            source.end();
          }
        });
        debug("create stream ok", fullpath);
        return dest;
      }
      /**
       * TODO: add method description.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      _incFile(callback) {
        debug("_incFile", this.filename);
        const ext = path4.extname(this._basename);
        const basename = path4.basename(this._basename, ext);
        const tasks = [];
        if (this.zippedArchive) {
          tasks.push(
            function(cb) {
              const num = this._created > 0 && !this.tailable ? this._created : "";
              this._compressFile(
                path4.join(this.dirname, `${basename}${num}${ext}`),
                path4.join(this.dirname, `${basename}${num}${ext}.gz`),
                cb
              );
            }.bind(this)
          );
        }
        tasks.push(
          function(cb) {
            if (!this.tailable) {
              this._created += 1;
              this._checkMaxFilesIncrementing(ext, basename, cb);
            } else {
              this._checkMaxFilesTailable(ext, basename, cb);
            }
          }.bind(this)
        );
        asyncSeries(tasks, callback);
      }
      /**
       * Gets the next filename to use for this instance in the case that log
       * filesizes are being capped.
       * @returns {string} - TODO: add return description.
       * @private
       */
      _getFile() {
        const ext = path4.extname(this._basename);
        const basename = path4.basename(this._basename, ext);
        const isRotation = this.rotationFormat ? this.rotationFormat() : this._created;
        return !this.tailable && this._created ? `${basename}${isRotation}${ext}` : `${basename}${ext}`;
      }
      /**
       * Increment the number of files created or checked by this instance.
       * @param {mixed} ext - TODO: add param description.
       * @param {mixed} basename - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {undefined}
       * @private
       */
      _checkMaxFilesIncrementing(ext, basename, callback) {
        if (!this.maxFiles || this._created < this.maxFiles) {
          return setImmediate(callback);
        }
        const oldest = this._created - this.maxFiles;
        const isOldest = oldest !== 0 ? oldest : "";
        const isZipped = this.zippedArchive ? ".gz" : "";
        const filePath = `${basename}${isOldest}${ext}${isZipped}`;
        const target = path4.join(this.dirname, filePath);
        fs4.unlink(target, callback);
      }
      /**
       * Roll files forward based on integer, up to maxFiles. e.g. if base if
       * file.log and it becomes oversized, roll to file1.log, and allow file.log
       * to be re-used. If file is oversized again, roll file1.log to file2.log,
       * roll file.log to file1.log, and so on.
       * @param {mixed} ext - TODO: add param description.
       * @param {mixed} basename - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {undefined}
       * @private
       */
      _checkMaxFilesTailable(ext, basename, callback) {
        const tasks = [];
        if (!this.maxFiles) {
          return;
        }
        const isZipped = this.zippedArchive ? ".gz" : "";
        for (let x = this.maxFiles - 1; x > 1; x--) {
          tasks.push(function(i, cb) {
            let fileName = `${basename}${i - 1}${ext}${isZipped}`;
            const tmppath = path4.join(this.dirname, fileName);
            fs4.exists(tmppath, (exists5) => {
              if (!exists5) {
                return cb(null);
              }
              fileName = `${basename}${i}${ext}${isZipped}`;
              fs4.rename(tmppath, path4.join(this.dirname, fileName), cb);
            });
          }.bind(this, x));
        }
        asyncSeries(tasks, () => {
          fs4.rename(
            path4.join(this.dirname, `${basename}${ext}${isZipped}`),
            path4.join(this.dirname, `${basename}1${ext}${isZipped}`),
            callback
          );
        });
      }
      /**
       * Compresses src to dest with gzip and unlinks src
       * @param {string} src - path to source file.
       * @param {string} dest - path to zipped destination file.
       * @param {Function} callback - callback called after file has been compressed.
       * @returns {undefined}
       * @private
       */
      _compressFile(src, dest, callback) {
        fs4.access(src, fs4.F_OK, (err) => {
          if (err) {
            return callback();
          }
          var gzip = zlib.createGzip();
          var inp = fs4.createReadStream(src);
          var out = fs4.createWriteStream(dest);
          out.on("finish", () => {
            fs4.unlink(src, callback);
          });
          inp.pipe(gzip).pipe(out);
        });
      }
      _createLogDirIfNotExist(dirPath) {
        if (!fs4.existsSync(dirPath)) {
          fs4.mkdirSync(dirPath, { recursive: true });
        }
      }
    };
  }
});

// node_modules/winston/lib/winston/transports/http.js
var require_http = __commonJS({
  "node_modules/winston/lib/winston/transports/http.js"(exports2, module2) {
    "use strict";
    var http = require("http");
    var https = require("https");
    var { Stream } = require_readable();
    var TransportStream = require_winston_transport();
    var { configure } = require_safe_stable_stringify();
    module2.exports = class Http extends TransportStream {
      /**
       * Constructor function for the Http transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      // eslint-disable-next-line max-statements
      constructor(options = {}) {
        super(options);
        this.options = options;
        this.name = options.name || "http";
        this.ssl = !!options.ssl;
        this.host = options.host || "localhost";
        this.port = options.port;
        this.auth = options.auth;
        this.path = options.path || "";
        this.maximumDepth = options.maximumDepth;
        this.agent = options.agent;
        this.headers = options.headers || {};
        this.headers["content-type"] = "application/json";
        this.batch = options.batch || false;
        this.batchInterval = options.batchInterval || 5e3;
        this.batchCount = options.batchCount || 10;
        this.batchOptions = [];
        this.batchTimeoutID = -1;
        this.batchCallback = {};
        if (!this.port) {
          this.port = this.ssl ? 443 : 80;
        }
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        this._request(info, null, null, (err, res) => {
          if (res && res.statusCode !== 200) {
            err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
          }
          if (err) {
            this.emit("warn", err);
          } else {
            this.emit("logged", info);
          }
        });
        if (callback) {
          setImmediate(callback);
        }
      }
      /**
       * Query the transport. Options object is optional.
       * @param {Object} options -  Loggly-like query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       * @returns {undefined}
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = {
          method: "query",
          params: this.normalizeQuery(options)
        };
        const auth = options.params.auth || null;
        delete options.params.auth;
        const path4 = options.params.path || null;
        delete options.params.path;
        this._request(options, auth, path4, (err, res, body) => {
          if (res && res.statusCode !== 200) {
            err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
          }
          if (err) {
            return callback(err);
          }
          if (typeof body === "string") {
            try {
              body = JSON.parse(body);
            } catch (e) {
              return callback(e);
            }
          }
          callback(null, body);
        });
      }
      /**
       * Returns a log stream for this transport. Options object is optional.
       * @param {Object} options - Stream options for this instance.
       * @returns {Stream} - TODO: add return description
       */
      stream(options = {}) {
        const stream = new Stream();
        options = {
          method: "stream",
          params: options
        };
        const path4 = options.params.path || null;
        delete options.params.path;
        const auth = options.params.auth || null;
        delete options.params.auth;
        let buff = "";
        const req = this._request(options, auth, path4);
        stream.destroy = () => req.destroy();
        req.on("data", (data) => {
          data = (buff + data).split(/\n+/);
          const l = data.length - 1;
          let i = 0;
          for (; i < l; i++) {
            try {
              stream.emit("log", JSON.parse(data[i]));
            } catch (e) {
              stream.emit("error", e);
            }
          }
          buff = data[l];
        });
        req.on("error", (err) => stream.emit("error", err));
        return stream;
      }
      /**
       * Make a request to a winstond server or any http server which can
       * handle json-rpc.
       * @param {function} options - Options to sent the request.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       * @param {function} callback - Continuation to respond to when complete.
       */
      _request(options, auth, path4, callback) {
        options = options || {};
        auth = auth || this.auth;
        path4 = path4 || this.path || "";
        if (this.batch) {
          this._doBatch(options, callback, auth, path4);
        } else {
          this._doRequest(options, callback, auth, path4);
        }
      }
      /**
       * Send or memorize the options according to batch configuration
       * @param {function} options - Options to sent the request.
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doBatch(options, callback, auth, path4) {
        this.batchOptions.push(options);
        if (this.batchOptions.length === 1) {
          const me = this;
          this.batchCallback = callback;
          this.batchTimeoutID = setTimeout(function() {
            me.batchTimeoutID = -1;
            me._doBatchRequest(me.batchCallback, auth, path4);
          }, this.batchInterval);
        }
        if (this.batchOptions.length === this.batchCount) {
          this._doBatchRequest(this.batchCallback, auth, path4);
        }
      }
      /**
       * Initiate a request with the memorized batch options, stop the batch timeout
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doBatchRequest(callback, auth, path4) {
        if (this.batchTimeoutID > 0) {
          clearTimeout(this.batchTimeoutID);
          this.batchTimeoutID = -1;
        }
        const batchOptionsCopy = this.batchOptions.slice();
        this.batchOptions = [];
        this._doRequest(batchOptionsCopy, callback, auth, path4);
      }
      /**
       * Make a request to a winstond server or any http server which can
       * handle json-rpc.
       * @param {function} options - Options to sent the request.
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doRequest(options, callback, auth, path4) {
        const headers = Object.assign({}, this.headers);
        if (auth && auth.bearer) {
          headers.Authorization = `Bearer ${auth.bearer}`;
        }
        const req = (this.ssl ? https : http).request({
          ...this.options,
          method: "POST",
          host: this.host,
          port: this.port,
          path: `/${path4.replace(/^\//, "")}`,
          headers,
          auth: auth && auth.username && auth.password ? `${auth.username}:${auth.password}` : "",
          agent: this.agent
        });
        req.on("error", callback);
        req.on("response", (res) => res.on("end", () => callback(null, res)).resume());
        const jsonStringify = configure({
          ...this.maximumDepth && { maximumDepth: this.maximumDepth }
        });
        req.end(Buffer.from(jsonStringify(options, this.options.replacer), "utf8"));
      }
    };
  }
});

// node_modules/winston/node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "node_modules/winston/node_modules/is-stream/index.js"(exports2, module2) {
    "use strict";
    var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
    isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
    isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
    isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
    isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function";
    module2.exports = isStream;
  }
});

// node_modules/winston/lib/winston/transports/stream.js
var require_stream3 = __commonJS({
  "node_modules/winston/lib/winston/transports/stream.js"(exports2, module2) {
    "use strict";
    var isStream = require_is_stream();
    var { MESSAGE } = require_triple_beam();
    var os = require("os");
    var TransportStream = require_winston_transport();
    module2.exports = class Stream extends TransportStream {
      /**
       * Constructor function for the Console transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        if (!options.stream || !isStream(options.stream)) {
          throw new Error("options.stream is required.");
        }
        this._stream = options.stream;
        this._stream.setMaxListeners(Infinity);
        this.isObjectMode = options.stream._writableState.objectMode;
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        setImmediate(() => this.emit("logged", info));
        if (this.isObjectMode) {
          this._stream.write(info);
          if (callback) {
            callback();
          }
          return;
        }
        this._stream.write(`${info[MESSAGE]}${this.eol}`);
        if (callback) {
          callback();
        }
        return;
      }
    };
  }
});

// node_modules/winston/lib/winston/transports/index.js
var require_transports = __commonJS({
  "node_modules/winston/lib/winston/transports/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "Console", {
      configurable: true,
      enumerable: true,
      get() {
        return require_console();
      }
    });
    Object.defineProperty(exports2, "File", {
      configurable: true,
      enumerable: true,
      get() {
        return require_file();
      }
    });
    Object.defineProperty(exports2, "Http", {
      configurable: true,
      enumerable: true,
      get() {
        return require_http();
      }
    });
    Object.defineProperty(exports2, "Stream", {
      configurable: true,
      enumerable: true,
      get() {
        return require_stream3();
      }
    });
  }
});

// node_modules/winston/lib/winston/config/index.js
var require_config2 = __commonJS({
  "node_modules/winston/lib/winston/config/index.js"(exports2) {
    "use strict";
    var logform = require_logform();
    var { configs } = require_triple_beam();
    exports2.cli = logform.levels(configs.cli);
    exports2.npm = logform.levels(configs.npm);
    exports2.syslog = logform.levels(configs.syslog);
    exports2.addColors = logform.levels;
  }
});

// node_modules/async/eachOf.js
var require_eachOf = __commonJS({
  "node_modules/async/eachOf.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = (0, _once2.default)(callback);
      var index = 0, completed = 0, { length } = coll, canceled = false;
      if (length === 0) {
        callback(null);
      }
      function iteratorCallback(err, value) {
        if (err === false) {
          canceled = true;
        }
        if (canceled === true)
          return;
        if (err) {
          callback(err);
        } else if (++completed === length || value === _breakLoop2.default) {
          callback(null);
        }
      }
      for (; index < length; index++) {
        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
      }
    }
    function eachOfGeneric(coll, iteratee, callback) {
      return (0, _eachOfLimit2.default)(coll, Infinity, iteratee, callback);
    }
    function eachOf(coll, iteratee, callback) {
      var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
      return eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOf, 3);
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/withoutIndex.js
var require_withoutIndex = __commonJS({
  "node_modules/async/internal/withoutIndex.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _withoutIndex;
    function _withoutIndex(iteratee) {
      return (value, index, callback) => iteratee(value, callback);
    }
    module2.exports = exports2.default;
  }
});

// node_modules/async/forEach.js
var require_forEach = __commonJS({
  "node_modules/async/forEach.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOf = require_eachOf();
    var _eachOf2 = _interopRequireDefault(_eachOf);
    var _withoutIndex = require_withoutIndex();
    var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachLimit(coll, iteratee, callback) {
      return (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachLimit, 3);
    module2.exports = exports2.default;
  }
});

// node_modules/fn.name/index.js
var require_fn = __commonJS({
  "node_modules/fn.name/index.js"(exports2, module2) {
    "use strict";
    var toString2 = Object.prototype.toString;
    module2.exports = function name(fn) {
      if ("string" === typeof fn.displayName && fn.constructor.name) {
        return fn.displayName;
      } else if ("string" === typeof fn.name && fn.name) {
        return fn.name;
      }
      if ("object" === typeof fn && fn.constructor && "string" === typeof fn.constructor.name)
        return fn.constructor.name;
      var named = fn.toString(), type = toString2.call(fn).slice(8, -1);
      if ("Function" === type) {
        named = named.substring(named.indexOf("(") + 1, named.indexOf(")"));
      } else {
        named = type;
      }
      return named || "anonymous";
    };
  }
});

// node_modules/one-time/index.js
var require_one_time = __commonJS({
  "node_modules/one-time/index.js"(exports2, module2) {
    "use strict";
    var name = require_fn();
    module2.exports = function one(fn) {
      var called = 0, value;
      function onetime() {
        if (called)
          return value;
        called = 1;
        value = fn.apply(this, arguments);
        fn = null;
        return value;
      }
      onetime.displayName = name(fn);
      return onetime;
    };
  }
});

// node_modules/stack-trace/lib/stack-trace.js
var require_stack_trace = __commonJS({
  "node_modules/stack-trace/lib/stack-trace.js"(exports2) {
    exports2.get = function(belowFn) {
      var oldLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Infinity;
      var dummyObject = {};
      var v8Handler = Error.prepareStackTrace;
      Error.prepareStackTrace = function(dummyObject2, v8StackTrace2) {
        return v8StackTrace2;
      };
      Error.captureStackTrace(dummyObject, belowFn || exports2.get);
      var v8StackTrace = dummyObject.stack;
      Error.prepareStackTrace = v8Handler;
      Error.stackTraceLimit = oldLimit;
      return v8StackTrace;
    };
    exports2.parse = function(err) {
      if (!err.stack) {
        return [];
      }
      var self2 = this;
      var lines = err.stack.split("\n").slice(1);
      return lines.map(function(line) {
        if (line.match(/^\s*[-]{4,}$/)) {
          return self2._createParsedCallSite({
            fileName: line,
            lineNumber: null,
            functionName: null,
            typeName: null,
            methodName: null,
            columnNumber: null,
            "native": null
          });
        }
        var lineMatch = line.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
        if (!lineMatch) {
          return;
        }
        var object = null;
        var method = null;
        var functionName = null;
        var typeName = null;
        var methodName = null;
        var isNative = lineMatch[5] === "native";
        if (lineMatch[1]) {
          functionName = lineMatch[1];
          var methodStart = functionName.lastIndexOf(".");
          if (functionName[methodStart - 1] == ".")
            methodStart--;
          if (methodStart > 0) {
            object = functionName.substr(0, methodStart);
            method = functionName.substr(methodStart + 1);
            var objectEnd = object.indexOf(".Module");
            if (objectEnd > 0) {
              functionName = functionName.substr(objectEnd + 1);
              object = object.substr(0, objectEnd);
            }
          }
          typeName = null;
        }
        if (method) {
          typeName = object;
          methodName = method;
        }
        if (method === "<anonymous>") {
          methodName = null;
          functionName = null;
        }
        var properties = {
          fileName: lineMatch[2] || null,
          lineNumber: parseInt(lineMatch[3], 10) || null,
          functionName,
          typeName,
          methodName,
          columnNumber: parseInt(lineMatch[4], 10) || null,
          "native": isNative
        };
        return self2._createParsedCallSite(properties);
      }).filter(function(callSite) {
        return !!callSite;
      });
    };
    function CallSite(properties) {
      for (var property2 in properties) {
        this[property2] = properties[property2];
      }
    }
    var strProperties = [
      "this",
      "typeName",
      "functionName",
      "methodName",
      "fileName",
      "lineNumber",
      "columnNumber",
      "function",
      "evalOrigin"
    ];
    var boolProperties = [
      "topLevel",
      "eval",
      "native",
      "constructor"
    ];
    strProperties.forEach(function(property2) {
      CallSite.prototype[property2] = null;
      CallSite.prototype["get" + property2[0].toUpperCase() + property2.substr(1)] = function() {
        return this[property2];
      };
    });
    boolProperties.forEach(function(property2) {
      CallSite.prototype[property2] = false;
      CallSite.prototype["is" + property2[0].toUpperCase() + property2.substr(1)] = function() {
        return this[property2];
      };
    });
    exports2._createParsedCallSite = function(properties) {
      return new CallSite(properties);
    };
  }
});

// node_modules/winston/lib/winston/exception-stream.js
var require_exception_stream = __commonJS({
  "node_modules/winston/lib/winston/exception-stream.js"(exports2, module2) {
    "use strict";
    var { Writable } = require_readable();
    module2.exports = class ExceptionStream extends Writable {
      /**
       * Constructor function for the ExceptionStream responsible for wrapping a
       * TransportStream; only allowing writes of `info` objects with
       * `info.exception` set to true.
       * @param {!TransportStream} transport - Stream to filter to exceptions
       */
      constructor(transport) {
        super({ objectMode: true });
        if (!transport) {
          throw new Error("ExceptionStream requires a TransportStream instance.");
        }
        this.handleExceptions = true;
        this.transport = transport;
      }
      /**
       * Writes the info object to our transport instance if (and only if) the
       * `exception` property is set on the info.
       * @param {mixed} info - TODO: add param description.
       * @param {mixed} enc - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _write(info, enc, callback) {
        if (info.exception) {
          return this.transport.log(info, callback);
        }
        callback();
        return true;
      }
    };
  }
});

// node_modules/winston/lib/winston/exception-handler.js
var require_exception_handler = __commonJS({
  "node_modules/winston/lib/winston/exception-handler.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var asyncForEach = require_forEach();
    var debug = require_node2()("winston:exception");
    var once = require_one_time();
    var stackTrace = require_stack_trace();
    var ExceptionStream = require_exception_stream();
    module2.exports = class ExceptionHandler {
      /**
       * TODO: add contructor description
       * @param {!Logger} logger - TODO: add param description
       */
      constructor(logger) {
        if (!logger) {
          throw new Error("Logger is required to handle exceptions");
        }
        this.logger = logger;
        this.handlers = /* @__PURE__ */ new Map();
      }
      /**
       * Handles `uncaughtException` events for the current process by adding any
       * handlers passed in.
       * @returns {undefined}
       */
      handle(...args) {
        args.forEach((arg) => {
          if (Array.isArray(arg)) {
            return arg.forEach((handler) => this._addHandler(handler));
          }
          this._addHandler(arg);
        });
        if (!this.catcher) {
          this.catcher = this._uncaughtException.bind(this);
          process.on("uncaughtException", this.catcher);
        }
      }
      /**
       * Removes any handlers to `uncaughtException` events for the current
       * process. This does not modify the state of the `this.handlers` set.
       * @returns {undefined}
       */
      unhandle() {
        if (this.catcher) {
          process.removeListener("uncaughtException", this.catcher);
          this.catcher = false;
          Array.from(this.handlers.values()).forEach((wrapper) => this.logger.unpipe(wrapper));
        }
      }
      /**
       * TODO: add method description
       * @param {Error} err - Error to get information about.
       * @returns {mixed} - TODO: add return description.
       */
      getAllInfo(err) {
        let message = null;
        if (err) {
          message = typeof err === "string" ? err : err.message;
        }
        return {
          error: err,
          // TODO (indexzero): how do we configure this?
          level: "error",
          message: [
            `uncaughtException: ${message || "(no error message)"}`,
            err && err.stack || "  No stack trace"
          ].join("\n"),
          stack: err && err.stack,
          exception: true,
          date: (/* @__PURE__ */ new Date()).toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(err)
        };
      }
      /**
       * Gets all relevant process information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getProcessInfo() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
      /**
       * Gets all relevant OS information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getOsInfo() {
        return {
          loadavg: os.loadavg(),
          uptime: os.uptime()
        };
      }
      /**
       * Gets a stack trace for the specified error.
       * @param {mixed} err - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      getTrace(err) {
        const trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map((site) => {
          return {
            column: site.getColumnNumber(),
            file: site.getFileName(),
            function: site.getFunctionName(),
            line: site.getLineNumber(),
            method: site.getMethodName(),
            native: site.isNative()
          };
        });
      }
      /**
       * Helper method to add a transport as an exception handler.
       * @param {Transport} handler - The transport to add as an exception handler.
       * @returns {void}
       */
      _addHandler(handler) {
        if (!this.handlers.has(handler)) {
          handler.handleExceptions = true;
          const wrapper = new ExceptionStream(handler);
          this.handlers.set(handler, wrapper);
          this.logger.pipe(wrapper);
        }
      }
      /**
       * Logs all relevant information around the `err` and exits the current
       * process.
       * @param {Error} err - Error to handle
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _uncaughtException(err) {
        const info = this.getAllInfo(err);
        const handlers = this._getExceptionHandlers();
        let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        let timeout;
        if (!handlers.length && doExit) {
          console.warn("winston: exitOnError cannot be true with no exception handlers.");
          console.warn("winston: not exiting process.");
          doExit = false;
        }
        function gracefulExit() {
          debug("doExit", doExit);
          debug("process._exiting", process._exiting);
          if (doExit && !process._exiting) {
            if (timeout) {
              clearTimeout(timeout);
            }
            process.exit(1);
          }
        }
        if (!handlers || handlers.length === 0) {
          return process.nextTick(gracefulExit);
        }
        asyncForEach(handlers, (handler, next) => {
          const done = once(next);
          const transport = handler.transport || handler;
          function onDone(event) {
            return () => {
              debug(event);
              done();
            };
          }
          transport._ending = true;
          transport.once("finish", onDone("finished"));
          transport.once("error", onDone("error"));
        }, () => doExit && gracefulExit());
        this.logger.log(info);
        if (doExit) {
          timeout = setTimeout(gracefulExit, 3e3);
        }
      }
      /**
       * Returns the list of transports and exceptionHandlers for this instance.
       * @returns {Array} - List of transports and exceptionHandlers for this
       * instance.
       * @private
       */
      _getExceptionHandlers() {
        return this.logger.transports.filter((wrap) => {
          const transport = wrap.transport || wrap;
          return transport.handleExceptions;
        });
      }
    };
  }
});

// node_modules/winston/lib/winston/rejection-stream.js
var require_rejection_stream = __commonJS({
  "node_modules/winston/lib/winston/rejection-stream.js"(exports2, module2) {
    "use strict";
    var { Writable } = require_readable();
    module2.exports = class RejectionStream extends Writable {
      /**
       * Constructor function for the RejectionStream responsible for wrapping a
       * TransportStream; only allowing writes of `info` objects with
       * `info.rejection` set to true.
       * @param {!TransportStream} transport - Stream to filter to rejections
       */
      constructor(transport) {
        super({ objectMode: true });
        if (!transport) {
          throw new Error("RejectionStream requires a TransportStream instance.");
        }
        this.handleRejections = true;
        this.transport = transport;
      }
      /**
       * Writes the info object to our transport instance if (and only if) the
       * `rejection` property is set on the info.
       * @param {mixed} info - TODO: add param description.
       * @param {mixed} enc - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _write(info, enc, callback) {
        if (info.rejection) {
          return this.transport.log(info, callback);
        }
        callback();
        return true;
      }
    };
  }
});

// node_modules/winston/lib/winston/rejection-handler.js
var require_rejection_handler = __commonJS({
  "node_modules/winston/lib/winston/rejection-handler.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var asyncForEach = require_forEach();
    var debug = require_node2()("winston:rejection");
    var once = require_one_time();
    var stackTrace = require_stack_trace();
    var RejectionStream = require_rejection_stream();
    module2.exports = class RejectionHandler {
      /**
       * TODO: add contructor description
       * @param {!Logger} logger - TODO: add param description
       */
      constructor(logger) {
        if (!logger) {
          throw new Error("Logger is required to handle rejections");
        }
        this.logger = logger;
        this.handlers = /* @__PURE__ */ new Map();
      }
      /**
       * Handles `unhandledRejection` events for the current process by adding any
       * handlers passed in.
       * @returns {undefined}
       */
      handle(...args) {
        args.forEach((arg) => {
          if (Array.isArray(arg)) {
            return arg.forEach((handler) => this._addHandler(handler));
          }
          this._addHandler(arg);
        });
        if (!this.catcher) {
          this.catcher = this._unhandledRejection.bind(this);
          process.on("unhandledRejection", this.catcher);
        }
      }
      /**
       * Removes any handlers to `unhandledRejection` events for the current
       * process. This does not modify the state of the `this.handlers` set.
       * @returns {undefined}
       */
      unhandle() {
        if (this.catcher) {
          process.removeListener("unhandledRejection", this.catcher);
          this.catcher = false;
          Array.from(this.handlers.values()).forEach(
            (wrapper) => this.logger.unpipe(wrapper)
          );
        }
      }
      /**
       * TODO: add method description
       * @param {Error} err - Error to get information about.
       * @returns {mixed} - TODO: add return description.
       */
      getAllInfo(err) {
        let message = null;
        if (err) {
          message = typeof err === "string" ? err : err.message;
        }
        return {
          error: err,
          // TODO (indexzero): how do we configure this?
          level: "error",
          message: [
            `unhandledRejection: ${message || "(no error message)"}`,
            err && err.stack || "  No stack trace"
          ].join("\n"),
          stack: err && err.stack,
          rejection: true,
          date: (/* @__PURE__ */ new Date()).toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(err)
        };
      }
      /**
       * Gets all relevant process information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getProcessInfo() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
      /**
       * Gets all relevant OS information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getOsInfo() {
        return {
          loadavg: os.loadavg(),
          uptime: os.uptime()
        };
      }
      /**
       * Gets a stack trace for the specified error.
       * @param {mixed} err - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      getTrace(err) {
        const trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map((site) => {
          return {
            column: site.getColumnNumber(),
            file: site.getFileName(),
            function: site.getFunctionName(),
            line: site.getLineNumber(),
            method: site.getMethodName(),
            native: site.isNative()
          };
        });
      }
      /**
       * Helper method to add a transport as an exception handler.
       * @param {Transport} handler - The transport to add as an exception handler.
       * @returns {void}
       */
      _addHandler(handler) {
        if (!this.handlers.has(handler)) {
          handler.handleRejections = true;
          const wrapper = new RejectionStream(handler);
          this.handlers.set(handler, wrapper);
          this.logger.pipe(wrapper);
        }
      }
      /**
       * Logs all relevant information around the `err` and exits the current
       * process.
       * @param {Error} err - Error to handle
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _unhandledRejection(err) {
        const info = this.getAllInfo(err);
        const handlers = this._getRejectionHandlers();
        let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        let timeout;
        if (!handlers.length && doExit) {
          console.warn("winston: exitOnError cannot be true with no rejection handlers.");
          console.warn("winston: not exiting process.");
          doExit = false;
        }
        function gracefulExit() {
          debug("doExit", doExit);
          debug("process._exiting", process._exiting);
          if (doExit && !process._exiting) {
            if (timeout) {
              clearTimeout(timeout);
            }
            process.exit(1);
          }
        }
        if (!handlers || handlers.length === 0) {
          return process.nextTick(gracefulExit);
        }
        asyncForEach(
          handlers,
          (handler, next) => {
            const done = once(next);
            const transport = handler.transport || handler;
            function onDone(event) {
              return () => {
                debug(event);
                done();
              };
            }
            transport._ending = true;
            transport.once("finish", onDone("finished"));
            transport.once("error", onDone("error"));
          },
          () => doExit && gracefulExit()
        );
        this.logger.log(info);
        if (doExit) {
          timeout = setTimeout(gracefulExit, 3e3);
        }
      }
      /**
       * Returns the list of transports and exceptionHandlers for this instance.
       * @returns {Array} - List of transports and exceptionHandlers for this
       * instance.
       * @private
       */
      _getRejectionHandlers() {
        return this.logger.transports.filter((wrap) => {
          const transport = wrap.transport || wrap;
          return transport.handleRejections;
        });
      }
    };
  }
});

// node_modules/winston/lib/winston/profiler.js
var require_profiler = __commonJS({
  "node_modules/winston/lib/winston/profiler.js"(exports2, module2) {
    "use strict";
    var Profiler = class {
      /**
       * Constructor function for the Profiler instance used by
       * `Logger.prototype.startTimer`. When done is called the timer will finish
       * and log the duration.
       * @param {!Logger} logger - TODO: add param description.
       * @private
       */
      constructor(logger) {
        const Logger = require_logger();
        if (typeof logger !== "object" || Array.isArray(logger) || !(logger instanceof Logger)) {
          throw new Error("Logger is required for profiling");
        } else {
          this.logger = logger;
          this.start = Date.now();
        }
      }
      /**
       * Ends the current timer (i.e. Profiler) instance and logs the `msg` along
       * with the duration since creation.
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      done(...args) {
        if (typeof args[args.length - 1] === "function") {
          console.warn("Callback function no longer supported as of winston@3.0.0");
          args.pop();
        }
        const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
        info.level = info.level || "info";
        info.durationMs = Date.now() - this.start;
        return this.logger.write(info);
      }
    };
    module2.exports = Profiler;
  }
});

// node_modules/winston/lib/winston/logger.js
var require_logger = __commonJS({
  "node_modules/winston/lib/winston/logger.js"(exports2, module2) {
    "use strict";
    var { Stream, Transform } = require_readable();
    var asyncForEach = require_forEach();
    var { LEVEL, SPLAT } = require_triple_beam();
    var isStream = require_is_stream();
    var ExceptionHandler = require_exception_handler();
    var RejectionHandler = require_rejection_handler();
    var LegacyTransportStream = require_legacy();
    var Profiler = require_profiler();
    var { warn } = require_common();
    var config = require_config2();
    var formatRegExp = /%[scdjifoO%]/g;
    var Logger = class extends Transform {
      /**
       * Constructor function for the Logger object responsible for persisting log
       * messages and metadata to one or more transports.
       * @param {!Object} options - foo
       */
      constructor(options) {
        super({ objectMode: true });
        this.configure(options);
      }
      child(defaultRequestMetadata) {
        const logger = this;
        return Object.create(logger, {
          write: {
            value: function(info) {
              const infoClone = Object.assign(
                {},
                defaultRequestMetadata,
                info
              );
              if (info instanceof Error) {
                infoClone.stack = info.stack;
                infoClone.message = info.message;
              }
              logger.write(infoClone);
            }
          }
        });
      }
      /**
       * This will wholesale reconfigure this instance by:
       * 1. Resetting all transports. Older transports will be removed implicitly.
       * 2. Set all other options including levels, colors, rewriters, filters,
       *    exceptionHandlers, etc.
       * @param {!Object} options - TODO: add param description.
       * @returns {undefined}
       */
      configure({
        silent,
        format: format2,
        defaultMeta,
        levels,
        level = "info",
        exitOnError = true,
        transports: transports2,
        colors,
        emitErrs,
        formatters,
        padLevels,
        rewriters,
        stripColors,
        exceptionHandlers,
        rejectionHandlers
      } = {}) {
        if (this.transports.length) {
          this.clear();
        }
        this.silent = silent;
        this.format = format2 || this.format || require_json()();
        this.defaultMeta = defaultMeta || null;
        this.levels = levels || this.levels || config.npm.levels;
        this.level = level;
        if (this.exceptions) {
          this.exceptions.unhandle();
        }
        if (this.rejections) {
          this.rejections.unhandle();
        }
        this.exceptions = new ExceptionHandler(this);
        this.rejections = new RejectionHandler(this);
        this.profilers = {};
        this.exitOnError = exitOnError;
        if (transports2) {
          transports2 = Array.isArray(transports2) ? transports2 : [transports2];
          transports2.forEach((transport) => this.add(transport));
        }
        if (colors || emitErrs || formatters || padLevels || rewriters || stripColors) {
          throw new Error(
            [
              "{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.",
              "Use a custom winston.format(function) instead.",
              "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
            ].join("\n")
          );
        }
        if (exceptionHandlers) {
          this.exceptions.handle(exceptionHandlers);
        }
        if (rejectionHandlers) {
          this.rejections.handle(rejectionHandlers);
        }
      }
      isLevelEnabled(level) {
        const givenLevelValue = getLevelValue(this.levels, level);
        if (givenLevelValue === null) {
          return false;
        }
        const configuredLevelValue = getLevelValue(this.levels, this.level);
        if (configuredLevelValue === null) {
          return false;
        }
        if (!this.transports || this.transports.length === 0) {
          return configuredLevelValue >= givenLevelValue;
        }
        const index = this.transports.findIndex((transport) => {
          let transportLevelValue = getLevelValue(this.levels, transport.level);
          if (transportLevelValue === null) {
            transportLevelValue = configuredLevelValue;
          }
          return transportLevelValue >= givenLevelValue;
        });
        return index !== -1;
      }
      /* eslint-disable valid-jsdoc */
      /**
       * Ensure backwards compatibility with a `log` method
       * @param {mixed} level - Level the log message is written at.
       * @param {mixed} msg - TODO: add param description.
       * @param {mixed} meta - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       *
       * @example
       *    // Supports the existing API:
       *    logger.log('info', 'Hello world', { custom: true });
       *    logger.log('info', new Error('Yo, it\'s on fire'));
       *
       *    // Requires winston.format.splat()
       *    logger.log('info', '%s %d%%', 'A string', 50, { thisIsMeta: true });
       *
       *    // And the new API with a single JSON literal:
       *    logger.log({ level: 'info', message: 'Hello world', custom: true });
       *    logger.log({ level: 'info', message: new Error('Yo, it\'s on fire') });
       *
       *    // Also requires winston.format.splat()
       *    logger.log({
       *      level: 'info',
       *      message: '%s %d%%',
       *      [SPLAT]: ['A string', 50],
       *      meta: { thisIsMeta: true }
       *    });
       *
       */
      /* eslint-enable valid-jsdoc */
      log(level, msg, ...splat) {
        if (arguments.length === 1) {
          level[LEVEL] = level.level;
          this._addDefaultMeta(level);
          this.write(level);
          return this;
        }
        if (arguments.length === 2) {
          if (msg && typeof msg === "object") {
            msg[LEVEL] = msg.level = level;
            this._addDefaultMeta(msg);
            this.write(msg);
            return this;
          }
          msg = { [LEVEL]: level, level, message: msg };
          this._addDefaultMeta(msg);
          this.write(msg);
          return this;
        }
        const [meta] = splat;
        if (typeof meta === "object" && meta !== null) {
          const tokens3 = msg && msg.match && msg.match(formatRegExp);
          if (!tokens3) {
            const info = Object.assign({}, this.defaultMeta, meta, {
              [LEVEL]: level,
              [SPLAT]: splat,
              level,
              message: msg
            });
            if (meta.message)
              info.message = `${info.message} ${meta.message}`;
            if (meta.stack)
              info.stack = meta.stack;
            this.write(info);
            return this;
          }
        }
        this.write(Object.assign({}, this.defaultMeta, {
          [LEVEL]: level,
          [SPLAT]: splat,
          level,
          message: msg
        }));
        return this;
      }
      /**
       * Pushes data so that it can be picked up by all of our pipe targets.
       * @param {mixed} info - TODO: add param description.
       * @param {mixed} enc - TODO: add param description.
       * @param {mixed} callback - Continues stream processing.
       * @returns {undefined}
       * @private
       */
      _transform(info, enc, callback) {
        if (this.silent) {
          return callback();
        }
        if (!info[LEVEL]) {
          info[LEVEL] = info.level;
        }
        if (!this.levels[info[LEVEL]] && this.levels[info[LEVEL]] !== 0) {
          console.error("[winston] Unknown logger level: %s", info[LEVEL]);
        }
        if (!this._readableState.pipes) {
          console.error(
            "[winston] Attempt to write logs with no transports, which can increase memory usage: %j",
            info
          );
        }
        try {
          this.push(this.format.transform(info, this.format.options));
        } finally {
          this._writableState.sync = false;
          callback();
        }
      }
      /**
       * Delays the 'finish' event until all transport pipe targets have
       * also emitted 'finish' or are already finished.
       * @param {mixed} callback - Continues stream processing.
       */
      _final(callback) {
        const transports2 = this.transports.slice();
        asyncForEach(
          transports2,
          (transport, next) => {
            if (!transport || transport.finished)
              return setImmediate(next);
            transport.once("finish", next);
            transport.end();
          },
          callback
        );
      }
      /**
       * Adds the transport to this logger instance by piping to it.
       * @param {mixed} transport - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       */
      add(transport) {
        const target = !isStream(transport) || transport.log.length > 2 ? new LegacyTransportStream({ transport }) : transport;
        if (!target._writableState || !target._writableState.objectMode) {
          throw new Error(
            "Transports must WritableStreams in objectMode. Set { objectMode: true }."
          );
        }
        this._onEvent("error", target);
        this._onEvent("warn", target);
        this.pipe(target);
        if (transport.handleExceptions) {
          this.exceptions.handle();
        }
        if (transport.handleRejections) {
          this.rejections.handle();
        }
        return this;
      }
      /**
       * Removes the transport from this logger instance by unpiping from it.
       * @param {mixed} transport - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       */
      remove(transport) {
        if (!transport)
          return this;
        let target = transport;
        if (!isStream(transport) || transport.log.length > 2) {
          target = this.transports.filter(
            (match) => match.transport === transport
          )[0];
        }
        if (target) {
          this.unpipe(target);
        }
        return this;
      }
      /**
       * Removes all transports from this logger instance.
       * @returns {Logger} - TODO: add return description.
       */
      clear() {
        this.unpipe();
        return this;
      }
      /**
       * Cleans up resources (streams, event listeners) for all transports
       * associated with this instance (if necessary).
       * @returns {Logger} - TODO: add return description.
       */
      close() {
        this.exceptions.unhandle();
        this.rejections.unhandle();
        this.clear();
        this.emit("close");
        return this;
      }
      /**
       * Sets the `target` levels specified on this instance.
       * @param {Object} Target levels to use on this instance.
       */
      setLevels() {
        warn.deprecated("setLevels");
      }
      /**
       * Queries the all transports for this instance with the specified `options`.
       * This will aggregate each transport's results into one object containing
       * a property per transport.
       * @param {Object} options - Query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        const results = {};
        const queryObject = Object.assign({}, options.query || {});
        function queryTransport(transport, next) {
          if (options.query && typeof transport.formatQuery === "function") {
            options.query = transport.formatQuery(queryObject);
          }
          transport.query(options, (err, res) => {
            if (err) {
              return next(err);
            }
            if (typeof transport.formatResults === "function") {
              res = transport.formatResults(res, options.format);
            }
            next(null, res);
          });
        }
        function addResults(transport, next) {
          queryTransport(transport, (err, result) => {
            if (next) {
              result = err || result;
              if (result) {
                results[transport.name] = result;
              }
              next();
            }
            next = null;
          });
        }
        asyncForEach(
          this.transports.filter((transport) => !!transport.query),
          addResults,
          () => callback(null, results)
        );
      }
      /**
       * Returns a log stream for all transports. Options object is optional.
       * @param{Object} options={} - Stream options for this instance.
       * @returns {Stream} - TODO: add return description.
       */
      stream(options = {}) {
        const out = new Stream();
        const streams = [];
        out._streams = streams;
        out.destroy = () => {
          let i = streams.length;
          while (i--) {
            streams[i].destroy();
          }
        };
        this.transports.filter((transport) => !!transport.stream).forEach((transport) => {
          const str = transport.stream(options);
          if (!str) {
            return;
          }
          streams.push(str);
          str.on("log", (log4) => {
            log4.transport = log4.transport || [];
            log4.transport.push(transport.name);
            out.emit("log", log4);
          });
          str.on("error", (err) => {
            err.transport = err.transport || [];
            err.transport.push(transport.name);
            out.emit("error", err);
          });
        });
        return out;
      }
      /**
       * Returns an object corresponding to a specific timing. When done is called
       * the timer will finish and log the duration. e.g.:
       * @returns {Profile} - TODO: add return description.
       * @example
       *    const timer = winston.startTimer()
       *    setTimeout(() => {
       *      timer.done({
       *        message: 'Logging message'
       *      });
       *    }, 1000);
       */
      startTimer() {
        return new Profiler(this);
      }
      /**
       * Tracks the time inbetween subsequent calls to this method with the same
       * `id` parameter. The second call to this method will log the difference in
       * milliseconds along with the message.
       * @param {string} id Unique id of the profiler
       * @returns {Logger} - TODO: add return description.
       */
      profile(id, ...args) {
        const time = Date.now();
        if (this.profilers[id]) {
          const timeEnd = this.profilers[id];
          delete this.profilers[id];
          if (typeof args[args.length - 2] === "function") {
            console.warn(
              "Callback function no longer supported as of winston@3.0.0"
            );
            args.pop();
          }
          const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
          info.level = info.level || "info";
          info.durationMs = time - timeEnd;
          info.message = info.message || id;
          return this.write(info);
        }
        this.profilers[id] = time;
        return this;
      }
      /**
       * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
       * @returns {undefined}
       * @deprecated
       */
      handleExceptions(...args) {
        console.warn(
          "Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()"
        );
        this.exceptions.handle(...args);
      }
      /**
       * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
       * @returns {undefined}
       * @deprecated
       */
      unhandleExceptions(...args) {
        console.warn(
          "Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()"
        );
        this.exceptions.unhandle(...args);
      }
      /**
       * Throw a more meaningful deprecation notice
       * @throws {Error} - TODO: add throws description.
       */
      cli() {
        throw new Error(
          [
            "Logger.cli() was removed in winston@3.0.0",
            "Use a custom winston.formats.cli() instead.",
            "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
          ].join("\n")
        );
      }
      /**
       * Bubbles the `event` that occured on the specified `transport` up
       * from this instance.
       * @param {string} event - The event that occured
       * @param {Object} transport - Transport on which the event occured
       * @private
       */
      _onEvent(event, transport) {
        function transportEvent(err) {
          if (event === "error" && !this.transports.includes(transport)) {
            this.add(transport);
          }
          this.emit(event, err, transport);
        }
        if (!transport["__winston" + event]) {
          transport["__winston" + event] = transportEvent.bind(this);
          transport.on(event, transport["__winston" + event]);
        }
      }
      _addDefaultMeta(msg) {
        if (this.defaultMeta) {
          Object.assign(msg, this.defaultMeta);
        }
      }
    };
    function getLevelValue(levels, level) {
      const value = levels[level];
      if (!value && value !== 0) {
        return null;
      }
      return value;
    }
    Object.defineProperty(Logger.prototype, "transports", {
      configurable: false,
      enumerable: true,
      get() {
        const { pipes } = this._readableState;
        return !Array.isArray(pipes) ? [pipes].filter(Boolean) : pipes;
      }
    });
    module2.exports = Logger;
  }
});

// node_modules/winston/lib/winston/create-logger.js
var require_create_logger = __commonJS({
  "node_modules/winston/lib/winston/create-logger.js"(exports2, module2) {
    "use strict";
    var { LEVEL } = require_triple_beam();
    var config = require_config2();
    var Logger = require_logger();
    var debug = require_node2()("winston:create-logger");
    function isLevelEnabledFunctionName(level) {
      return "is" + level.charAt(0).toUpperCase() + level.slice(1) + "Enabled";
    }
    module2.exports = function(opts = {}) {
      opts.levels = opts.levels || config.npm.levels;
      class DerivedLogger extends Logger {
        /**
         * Create a new class derived logger for which the levels can be attached to
         * the prototype of. This is a V8 optimization that is well know to increase
         * performance of prototype functions.
         * @param {!Object} options - Options for the created logger.
         */
        constructor(options) {
          super(options);
        }
      }
      const logger = new DerivedLogger(opts);
      Object.keys(opts.levels).forEach(function(level) {
        debug('Define prototype method for "%s"', level);
        if (level === "log") {
          console.warn('Level "log" not defined: conflicts with the method "log". Use a different level name.');
          return;
        }
        DerivedLogger.prototype[level] = function(...args) {
          const self2 = this || logger;
          if (args.length === 1) {
            const [msg] = args;
            const info = msg && msg.message && msg || { message: msg };
            info.level = info[LEVEL] = level;
            self2._addDefaultMeta(info);
            self2.write(info);
            return this || logger;
          }
          if (args.length === 0) {
            self2.log(level, "");
            return self2;
          }
          return self2.log(level, ...args);
        };
        DerivedLogger.prototype[isLevelEnabledFunctionName(level)] = function() {
          return (this || logger).isLevelEnabled(level);
        };
      });
      return logger;
    };
  }
});

// node_modules/winston/lib/winston/container.js
var require_container = __commonJS({
  "node_modules/winston/lib/winston/container.js"(exports2, module2) {
    "use strict";
    var createLogger2 = require_create_logger();
    module2.exports = class Container {
      /**
       * Constructor function for the Container object responsible for managing a
       * set of `winston.Logger` instances based on string ids.
       * @param {!Object} [options={}] - Default pass-thru options for Loggers.
       */
      constructor(options = {}) {
        this.loggers = /* @__PURE__ */ new Map();
        this.options = options;
      }
      /**
       * Retrieves a `winston.Logger` instance for the specified `id`. If an
       * instance does not exist, one is created.
       * @param {!string} id - The id of the Logger to get.
       * @param {?Object} [options] - Options for the Logger instance.
       * @returns {Logger} - A configured Logger instance with a specified id.
       */
      add(id, options) {
        if (!this.loggers.has(id)) {
          options = Object.assign({}, options || this.options);
          const existing = options.transports || this.options.transports;
          if (existing) {
            options.transports = Array.isArray(existing) ? existing.slice() : [existing];
          } else {
            options.transports = [];
          }
          const logger = createLogger2(options);
          logger.on("close", () => this._delete(id));
          this.loggers.set(id, logger);
        }
        return this.loggers.get(id);
      }
      /**
       * Retreives a `winston.Logger` instance for the specified `id`. If
       * an instance does not exist, one is created.
       * @param {!string} id - The id of the Logger to get.
       * @param {?Object} [options] - Options for the Logger instance.
       * @returns {Logger} - A configured Logger instance with a specified id.
       */
      get(id, options) {
        return this.add(id, options);
      }
      /**
       * Check if the container has a logger with the id.
       * @param {?string} id - The id of the Logger instance to find.
       * @returns {boolean} - Boolean value indicating if this instance has a
       * logger with the specified `id`.
       */
      has(id) {
        return !!this.loggers.has(id);
      }
      /**
       * Closes a `Logger` instance with the specified `id` if it exists.
       * If no `id` is supplied then all Loggers are closed.
       * @param {?string} id - The id of the Logger instance to close.
       * @returns {undefined}
       */
      close(id) {
        if (id) {
          return this._removeLogger(id);
        }
        this.loggers.forEach((val, key) => this._removeLogger(key));
      }
      /**
       * Remove a logger based on the id.
       * @param {!string} id - The id of the logger to remove.
       * @returns {undefined}
       * @private
       */
      _removeLogger(id) {
        if (!this.loggers.has(id)) {
          return;
        }
        const logger = this.loggers.get(id);
        logger.close();
        this._delete(id);
      }
      /**
       * Deletes a `Logger` instance with the specified `id`.
       * @param {!string} id - The id of the Logger instance to delete from
       * container.
       * @returns {undefined}
       * @private
       */
      _delete(id) {
        this.loggers.delete(id);
      }
    };
  }
});

// node_modules/winston/lib/winston.js
var require_winston = __commonJS({
  "node_modules/winston/lib/winston.js"(exports2) {
    "use strict";
    var logform = require_logform();
    var { warn } = require_common();
    exports2.version = require_package().version;
    exports2.transports = require_transports();
    exports2.config = require_config2();
    exports2.addColors = logform.levels;
    exports2.format = logform.format;
    exports2.createLogger = require_create_logger();
    exports2.Logger = require_logger();
    exports2.ExceptionHandler = require_exception_handler();
    exports2.RejectionHandler = require_rejection_handler();
    exports2.Container = require_container();
    exports2.Transport = require_winston_transport();
    exports2.loggers = new exports2.Container();
    var defaultLogger = exports2.createLogger();
    Object.keys(exports2.config.npm.levels).concat([
      "log",
      "query",
      "stream",
      "add",
      "remove",
      "clear",
      "profile",
      "startTimer",
      "handleExceptions",
      "unhandleExceptions",
      "handleRejections",
      "unhandleRejections",
      "configure",
      "child"
    ]).forEach(
      (method) => exports2[method] = (...args) => defaultLogger[method](...args)
    );
    Object.defineProperty(exports2, "level", {
      get() {
        return defaultLogger.level;
      },
      set(val) {
        defaultLogger.level = val;
      }
    });
    Object.defineProperty(exports2, "exceptions", {
      get() {
        return defaultLogger.exceptions;
      }
    });
    Object.defineProperty(exports2, "rejections", {
      get() {
        return defaultLogger.rejections;
      }
    });
    ["exitOnError"].forEach((prop) => {
      Object.defineProperty(exports2, prop, {
        get() {
          return defaultLogger[prop];
        },
        set(val) {
          defaultLogger[prop] = val;
        }
      });
    });
    Object.defineProperty(exports2, "default", {
      get() {
        return {
          exceptionHandlers: defaultLogger.exceptionHandlers,
          rejectionHandlers: defaultLogger.rejectionHandlers,
          transports: defaultLogger.transports
        };
      }
    });
    warn.deprecated(exports2, "setLevels");
    warn.forFunctions(exports2, "useFormat", ["cli"]);
    warn.forProperties(exports2, "useFormat", ["padLevels", "stripColors"]);
    warn.forFunctions(exports2, "deprecated", [
      "addRewriter",
      "addFilter",
      "clone",
      "extend"
    ]);
    warn.forProperties(exports2, "deprecated", ["emitErrs", "levelLength"]);
  }
});

// node_modules/generator-begcode/dist/jdl/utils/objects/logger.js
var import_winston, Console, printf, combine, myFormat, logger_default;
var init_logger = __esm({
  "node_modules/generator-begcode/dist/jdl/utils/objects/logger.js"() {
    import_winston = __toESM(require_winston(), 1);
    ({ Console } = import_winston.transports);
    ({ printf, combine } = import_winston.format);
    myFormat = printf((info) => `${info.level}: ${info.message}`);
    logger_default = (0, import_winston.createLogger)({
      transports: [new Console()],
      format: combine(myFormat),
      handleExceptions: true
    });
  }
});

// node_modules/chevrotain/lib/src/version.js
var init_version = __esm({
  "node_modules/chevrotain/lib/src/version.js"() {
  }
});

// node_modules/@chevrotain/utils/lib/src/print.js
function PRINT_ERROR(msg) {
  if (console && console.error) {
    console.error(`Error: ${msg}`);
  }
}
function PRINT_WARNING(msg) {
  if (console && console.warn) {
    console.warn(`Warning: ${msg}`);
  }
}
var init_print = __esm({
  "node_modules/@chevrotain/utils/lib/src/print.js"() {
  }
});

// node_modules/@chevrotain/utils/lib/src/timer.js
function timer(func) {
  const start = (/* @__PURE__ */ new Date()).getTime();
  const val = func();
  const end = (/* @__PURE__ */ new Date()).getTime();
  const total = end - start;
  return { time: total, value: val };
}
var init_timer = __esm({
  "node_modules/@chevrotain/utils/lib/src/timer.js"() {
  }
});

// node_modules/@chevrotain/utils/lib/src/to-fast-properties.js
function toFastProperties(toBecomeFast) {
  function FakeConstructor() {
  }
  FakeConstructor.prototype = toBecomeFast;
  const fakeInstance = new FakeConstructor();
  function fakeAccess() {
    return typeof fakeInstance.bar;
  }
  fakeAccess();
  fakeAccess();
  if (1)
    return toBecomeFast;
  (0, eval)(toBecomeFast);
}
var init_to_fast_properties = __esm({
  "node_modules/@chevrotain/utils/lib/src/to-fast-properties.js"() {
  }
});

// node_modules/@chevrotain/utils/lib/src/api.js
var init_api = __esm({
  "node_modules/@chevrotain/utils/lib/src/api.js"() {
    init_print();
    init_timer();
    init_to_fast_properties();
  }
});

// node_modules/@chevrotain/gast/lib/src/model.js
function tokenLabel(tokType) {
  if (hasTokenLabel(tokType)) {
    return tokType.LABEL;
  } else {
    return tokType.name;
  }
}
function hasTokenLabel(obj) {
  return isString_default(obj.LABEL) && obj.LABEL !== "";
}
function serializeGrammar(topRules) {
  return map_default(topRules, serializeProduction);
}
function serializeProduction(node) {
  function convertDefinition(definition) {
    return map_default(definition, serializeProduction);
  }
  if (node instanceof NonTerminal) {
    const serializedNonTerminal = {
      type: "NonTerminal",
      name: node.nonTerminalName,
      idx: node.idx
    };
    if (isString_default(node.label)) {
      serializedNonTerminal.label = node.label;
    }
    return serializedNonTerminal;
  } else if (node instanceof Alternative) {
    return {
      type: "Alternative",
      definition: convertDefinition(node.definition)
    };
  } else if (node instanceof Option) {
    return {
      type: "Option",
      idx: node.idx,
      definition: convertDefinition(node.definition)
    };
  } else if (node instanceof RepetitionMandatory) {
    return {
      type: "RepetitionMandatory",
      idx: node.idx,
      definition: convertDefinition(node.definition)
    };
  } else if (node instanceof RepetitionMandatoryWithSeparator) {
    return {
      type: "RepetitionMandatoryWithSeparator",
      idx: node.idx,
      separator: serializeProduction(new Terminal({ terminalType: node.separator })),
      definition: convertDefinition(node.definition)
    };
  } else if (node instanceof RepetitionWithSeparator) {
    return {
      type: "RepetitionWithSeparator",
      idx: node.idx,
      separator: serializeProduction(new Terminal({ terminalType: node.separator })),
      definition: convertDefinition(node.definition)
    };
  } else if (node instanceof Repetition) {
    return {
      type: "Repetition",
      idx: node.idx,
      definition: convertDefinition(node.definition)
    };
  } else if (node instanceof Alternation) {
    return {
      type: "Alternation",
      idx: node.idx,
      definition: convertDefinition(node.definition)
    };
  } else if (node instanceof Terminal) {
    const serializedTerminal = {
      type: "Terminal",
      name: node.terminalType.name,
      label: tokenLabel(node.terminalType),
      idx: node.idx
    };
    if (isString_default(node.label)) {
      serializedTerminal.terminalLabel = node.label;
    }
    const pattern = node.terminalType.PATTERN;
    if (node.terminalType.PATTERN) {
      serializedTerminal.pattern = isRegExp_default(pattern) ? pattern.source : pattern;
    }
    return serializedTerminal;
  } else if (node instanceof Rule) {
    return {
      type: "Rule",
      name: node.name,
      orgText: node.orgText,
      definition: convertDefinition(node.definition)
    };
  } else {
    throw Error("non exhaustive match");
  }
}
var AbstractProduction, NonTerminal, Rule, Alternative, Option, RepetitionMandatory, RepetitionMandatoryWithSeparator, Repetition, RepetitionWithSeparator, Alternation, Terminal;
var init_model = __esm({
  "node_modules/@chevrotain/gast/lib/src/model.js"() {
    init_lodash();
    AbstractProduction = class {
      get definition() {
        return this._definition;
      }
      set definition(value) {
        this._definition = value;
      }
      constructor(_definition) {
        this._definition = _definition;
      }
      accept(visitor) {
        visitor.visit(this);
        forEach_default(this.definition, (prod) => {
          prod.accept(visitor);
        });
      }
    };
    NonTerminal = class extends AbstractProduction {
      constructor(options) {
        super([]);
        this.idx = 1;
        assign_default(this, pickBy_default(options, (v) => v !== void 0));
      }
      set definition(definition) {
      }
      get definition() {
        if (this.referencedRule !== void 0) {
          return this.referencedRule.definition;
        }
        return [];
      }
      accept(visitor) {
        visitor.visit(this);
      }
    };
    Rule = class extends AbstractProduction {
      constructor(options) {
        super(options.definition);
        this.orgText = "";
        assign_default(this, pickBy_default(options, (v) => v !== void 0));
      }
    };
    Alternative = class extends AbstractProduction {
      constructor(options) {
        super(options.definition);
        this.ignoreAmbiguities = false;
        assign_default(this, pickBy_default(options, (v) => v !== void 0));
      }
    };
    Option = class extends AbstractProduction {
      constructor(options) {
        super(options.definition);
        this.idx = 1;
        assign_default(this, pickBy_default(options, (v) => v !== void 0));
      }
    };
    RepetitionMandatory = class extends AbstractProduction {
      constructor(options) {
        super(options.definition);
        this.idx = 1;
        assign_default(this, pickBy_default(options, (v) => v !== void 0));
      }
    };
    RepetitionMandatoryWithSeparator = class extends AbstractProduction {
      constructor(options) {
        super(options.definition);
        this.idx = 1;
        assign_default(this, pickBy_default(options, (v) => v !== void 0));
      }
    };
    Repetition = class extends AbstractProduction {
      constructor(options) {
        super(options.definition);
        this.idx = 1;
        assign_default(this, pickBy_default(options, (v) => v !== void 0));
      }
    };
    RepetitionWithSeparator = class extends AbstractProduction {
      constructor(options) {
        super(options.definition);
        this.idx = 1;
        assign_default(this, pickBy_default(options, (v) => v !== void 0));
      }
    };
    Alternation = class extends AbstractProduction {
      get definition() {
        return this._definition;
      }
      set definition(value) {
        this._definition = value;
      }
      constructor(options) {
        super(options.definition);
        this.idx = 1;
        this.ignoreAmbiguities = false;
        this.hasPredicates = false;
        assign_default(this, pickBy_default(options, (v) => v !== void 0));
      }
    };
    Terminal = class {
      constructor(options) {
        this.idx = 1;
        assign_default(this, pickBy_default(options, (v) => v !== void 0));
      }
      accept(visitor) {
        visitor.visit(this);
      }
    };
  }
});

// node_modules/@chevrotain/gast/lib/src/visitor.js
var GAstVisitor;
var init_visitor = __esm({
  "node_modules/@chevrotain/gast/lib/src/visitor.js"() {
    init_model();
    GAstVisitor = class {
      visit(node) {
        const nodeAny = node;
        switch (nodeAny.constructor) {
          case NonTerminal:
            return this.visitNonTerminal(nodeAny);
          case Alternative:
            return this.visitAlternative(nodeAny);
          case Option:
            return this.visitOption(nodeAny);
          case RepetitionMandatory:
            return this.visitRepetitionMandatory(nodeAny);
          case RepetitionMandatoryWithSeparator:
            return this.visitRepetitionMandatoryWithSeparator(nodeAny);
          case RepetitionWithSeparator:
            return this.visitRepetitionWithSeparator(nodeAny);
          case Repetition:
            return this.visitRepetition(nodeAny);
          case Alternation:
            return this.visitAlternation(nodeAny);
          case Terminal:
            return this.visitTerminal(nodeAny);
          case Rule:
            return this.visitRule(nodeAny);
          default:
            throw Error("non exhaustive match");
        }
      }
      /* c8 ignore next */
      visitNonTerminal(node) {
      }
      /* c8 ignore next */
      visitAlternative(node) {
      }
      /* c8 ignore next */
      visitOption(node) {
      }
      /* c8 ignore next */
      visitRepetition(node) {
      }
      /* c8 ignore next */
      visitRepetitionMandatory(node) {
      }
      /* c8 ignore next 3 */
      visitRepetitionMandatoryWithSeparator(node) {
      }
      /* c8 ignore next */
      visitRepetitionWithSeparator(node) {
      }
      /* c8 ignore next */
      visitAlternation(node) {
      }
      /* c8 ignore next */
      visitTerminal(node) {
      }
      /* c8 ignore next */
      visitRule(node) {
      }
    };
  }
});

// node_modules/@chevrotain/gast/lib/src/helpers.js
function isSequenceProd(prod) {
  return prod instanceof Alternative || prod instanceof Option || prod instanceof Repetition || prod instanceof RepetitionMandatory || prod instanceof RepetitionMandatoryWithSeparator || prod instanceof RepetitionWithSeparator || prod instanceof Terminal || prod instanceof Rule;
}
function isOptionalProd(prod, alreadyVisited = []) {
  const isDirectlyOptional = prod instanceof Option || prod instanceof Repetition || prod instanceof RepetitionWithSeparator;
  if (isDirectlyOptional) {
    return true;
  }
  if (prod instanceof Alternation) {
    return some_default(prod.definition, (subProd) => {
      return isOptionalProd(subProd, alreadyVisited);
    });
  } else if (prod instanceof NonTerminal && includes_default(alreadyVisited, prod)) {
    return false;
  } else if (prod instanceof AbstractProduction) {
    if (prod instanceof NonTerminal) {
      alreadyVisited.push(prod);
    }
    return every_default(prod.definition, (subProd) => {
      return isOptionalProd(subProd, alreadyVisited);
    });
  } else {
    return false;
  }
}
function isBranchingProd(prod) {
  return prod instanceof Alternation;
}
function getProductionDslName(prod) {
  if (prod instanceof NonTerminal) {
    return "SUBRULE";
  } else if (prod instanceof Option) {
    return "OPTION";
  } else if (prod instanceof Alternation) {
    return "OR";
  } else if (prod instanceof RepetitionMandatory) {
    return "AT_LEAST_ONE";
  } else if (prod instanceof RepetitionMandatoryWithSeparator) {
    return "AT_LEAST_ONE_SEP";
  } else if (prod instanceof RepetitionWithSeparator) {
    return "MANY_SEP";
  } else if (prod instanceof Repetition) {
    return "MANY";
  } else if (prod instanceof Terminal) {
    return "CONSUME";
  } else {
    throw Error("non exhaustive match");
  }
}
var init_helpers = __esm({
  "node_modules/@chevrotain/gast/lib/src/helpers.js"() {
    init_lodash();
    init_model();
  }
});

// node_modules/@chevrotain/gast/lib/src/api.js
var init_api2 = __esm({
  "node_modules/@chevrotain/gast/lib/src/api.js"() {
    init_model();
    init_visitor();
    init_helpers();
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/rest.js
function restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {
  const repSepRest = [
    new Option({
      definition: [
        new Terminal({ terminalType: repSepProd.separator })
      ].concat(repSepProd.definition)
    })
  ];
  const fullRepSepRest = repSepRest.concat(currRest, prevRest);
  return fullRepSepRest;
}
var RestWalker;
var init_rest = __esm({
  "node_modules/chevrotain/lib/src/parse/grammar/rest.js"() {
    init_lodash();
    init_api2();
    RestWalker = class {
      walk(prod, prevRest = []) {
        forEach_default(prod.definition, (subProd, index) => {
          const currRest = drop_default(prod.definition, index + 1);
          if (subProd instanceof NonTerminal) {
            this.walkProdRef(subProd, currRest, prevRest);
          } else if (subProd instanceof Terminal) {
            this.walkTerminal(subProd, currRest, prevRest);
          } else if (subProd instanceof Alternative) {
            this.walkFlat(subProd, currRest, prevRest);
          } else if (subProd instanceof Option) {
            this.walkOption(subProd, currRest, prevRest);
          } else if (subProd instanceof RepetitionMandatory) {
            this.walkAtLeastOne(subProd, currRest, prevRest);
          } else if (subProd instanceof RepetitionMandatoryWithSeparator) {
            this.walkAtLeastOneSep(subProd, currRest, prevRest);
          } else if (subProd instanceof RepetitionWithSeparator) {
            this.walkManySep(subProd, currRest, prevRest);
          } else if (subProd instanceof Repetition) {
            this.walkMany(subProd, currRest, prevRest);
          } else if (subProd instanceof Alternation) {
            this.walkOr(subProd, currRest, prevRest);
          } else {
            throw Error("non exhaustive match");
          }
        });
      }
      walkTerminal(terminal, currRest, prevRest) {
      }
      walkProdRef(refProd, currRest, prevRest) {
      }
      walkFlat(flatProd, currRest, prevRest) {
        const fullOrRest = currRest.concat(prevRest);
        this.walk(flatProd, fullOrRest);
      }
      walkOption(optionProd, currRest, prevRest) {
        const fullOrRest = currRest.concat(prevRest);
        this.walk(optionProd, fullOrRest);
      }
      walkAtLeastOne(atLeastOneProd, currRest, prevRest) {
        const fullAtLeastOneRest = [
          new Option({ definition: atLeastOneProd.definition })
        ].concat(currRest, prevRest);
        this.walk(atLeastOneProd, fullAtLeastOneRest);
      }
      walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {
        const fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);
        this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);
      }
      walkMany(manyProd, currRest, prevRest) {
        const fullManyRest = [
          new Option({ definition: manyProd.definition })
        ].concat(currRest, prevRest);
        this.walk(manyProd, fullManyRest);
      }
      walkManySep(manySepProd, currRest, prevRest) {
        const fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);
        this.walk(manySepProd, fullManySepRest);
      }
      walkOr(orProd, currRest, prevRest) {
        const fullOrRest = currRest.concat(prevRest);
        forEach_default(orProd.definition, (alt) => {
          const prodWrapper = new Alternative({ definition: [alt] });
          this.walk(prodWrapper, fullOrRest);
        });
      }
    };
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/first.js
function first(prod) {
  if (prod instanceof NonTerminal) {
    return first(prod.referencedRule);
  } else if (prod instanceof Terminal) {
    return firstForTerminal(prod);
  } else if (isSequenceProd(prod)) {
    return firstForSequence(prod);
  } else if (isBranchingProd(prod)) {
    return firstForBranching(prod);
  } else {
    throw Error("non exhaustive match");
  }
}
function firstForSequence(prod) {
  let firstSet = [];
  const seq = prod.definition;
  let nextSubProdIdx = 0;
  let hasInnerProdsRemaining = seq.length > nextSubProdIdx;
  let currSubProd;
  let isLastInnerProdOptional = true;
  while (hasInnerProdsRemaining && isLastInnerProdOptional) {
    currSubProd = seq[nextSubProdIdx];
    isLastInnerProdOptional = isOptionalProd(currSubProd);
    firstSet = firstSet.concat(first(currSubProd));
    nextSubProdIdx = nextSubProdIdx + 1;
    hasInnerProdsRemaining = seq.length > nextSubProdIdx;
  }
  return uniq_default(firstSet);
}
function firstForBranching(prod) {
  const allAlternativesFirsts = map_default(prod.definition, (innerProd) => {
    return first(innerProd);
  });
  return uniq_default(flatten_default(allAlternativesFirsts));
}
function firstForTerminal(terminal) {
  return [terminal.terminalType];
}
var init_first2 = __esm({
  "node_modules/chevrotain/lib/src/parse/grammar/first.js"() {
    init_lodash();
    init_api2();
  }
});

// node_modules/chevrotain/lib/src/parse/constants.js
var IN;
var init_constants = __esm({
  "node_modules/chevrotain/lib/src/parse/constants.js"() {
    IN = "_~IN~_";
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/follow.js
function computeAllProdsFollows(topProductions) {
  const reSyncFollows = {};
  forEach_default(topProductions, (topProd) => {
    const currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();
    assign_default(reSyncFollows, currRefsFollow);
  });
  return reSyncFollows;
}
function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {
  return inner.name + occurenceInParent + IN;
}
var ResyncFollowsWalker;
var init_follow = __esm({
  "node_modules/chevrotain/lib/src/parse/grammar/follow.js"() {
    init_rest();
    init_first2();
    init_lodash();
    init_constants();
    init_api2();
    ResyncFollowsWalker = class extends RestWalker {
      constructor(topProd) {
        super();
        this.topProd = topProd;
        this.follows = {};
      }
      startWalking() {
        this.walk(this.topProd);
        return this.follows;
      }
      walkTerminal(terminal, currRest, prevRest) {
      }
      walkProdRef(refProd, currRest, prevRest) {
        const followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) + this.topProd.name;
        const fullRest = currRest.concat(prevRest);
        const restProd = new Alternative({ definition: fullRest });
        const t_in_topProd_follows = first(restProd);
        this.follows[followName] = t_in_topProd_follows;
      }
    };
  }
});

// node_modules/@chevrotain/regexp-to-ast/lib/src/utils.js
function cc(char) {
  return char.charCodeAt(0);
}
function insertToSet(item, set) {
  if (Array.isArray(item)) {
    item.forEach(function(subItem) {
      set.push(subItem);
    });
  } else {
    set.push(item);
  }
}
function addFlag(flagObj, flagKey) {
  if (flagObj[flagKey] === true) {
    throw "duplicate flag " + flagKey;
  }
  const x = flagObj[flagKey];
  flagObj[flagKey] = true;
}
function ASSERT_EXISTS(obj) {
  if (obj === void 0) {
    throw Error("Internal Error - Should never get here!");
  }
  return true;
}
function ASSERT_NEVER_REACH_HERE() {
  throw Error("Internal Error - Should never get here!");
}
function isCharacter(obj) {
  return obj["type"] === "Character";
}
var init_utils = __esm({
  "node_modules/@chevrotain/regexp-to-ast/lib/src/utils.js"() {
  }
});

// node_modules/@chevrotain/regexp-to-ast/lib/src/character-classes.js
var digitsCharCodes, wordCharCodes, whitespaceCodes;
var init_character_classes = __esm({
  "node_modules/@chevrotain/regexp-to-ast/lib/src/character-classes.js"() {
    init_utils();
    digitsCharCodes = [];
    for (let i = cc("0"); i <= cc("9"); i++) {
      digitsCharCodes.push(i);
    }
    wordCharCodes = [cc("_")].concat(digitsCharCodes);
    for (let i = cc("a"); i <= cc("z"); i++) {
      wordCharCodes.push(i);
    }
    for (let i = cc("A"); i <= cc("Z"); i++) {
      wordCharCodes.push(i);
    }
    whitespaceCodes = [
      cc(" "),
      cc("\f"),
      cc("\n"),
      cc("\r"),
      cc("	"),
      cc("\v"),
      cc("	"),
      cc("\xA0"),
      cc("\u1680"),
      cc("\u2000"),
      cc("\u2001"),
      cc("\u2002"),
      cc("\u2003"),
      cc("\u2004"),
      cc("\u2005"),
      cc("\u2006"),
      cc("\u2007"),
      cc("\u2008"),
      cc("\u2009"),
      cc("\u200A"),
      cc("\u2028"),
      cc("\u2029"),
      cc("\u202F"),
      cc("\u205F"),
      cc("\u3000"),
      cc("\uFEFF")
    ];
  }
});

// node_modules/@chevrotain/regexp-to-ast/lib/src/regexp-parser.js
var hexDigitPattern, decimalPattern, decimalPatternNoZero, RegExpParser;
var init_regexp_parser = __esm({
  "node_modules/@chevrotain/regexp-to-ast/lib/src/regexp-parser.js"() {
    init_utils();
    init_character_classes();
    hexDigitPattern = /[0-9a-fA-F]/;
    decimalPattern = /[0-9]/;
    decimalPatternNoZero = /[1-9]/;
    RegExpParser = class {
      constructor() {
        this.idx = 0;
        this.input = "";
        this.groupIdx = 0;
      }
      saveState() {
        return {
          idx: this.idx,
          input: this.input,
          groupIdx: this.groupIdx
        };
      }
      restoreState(newState) {
        this.idx = newState.idx;
        this.input = newState.input;
        this.groupIdx = newState.groupIdx;
      }
      pattern(input) {
        this.idx = 0;
        this.input = input;
        this.groupIdx = 0;
        this.consumeChar("/");
        const value = this.disjunction();
        this.consumeChar("/");
        const flags = {
          type: "Flags",
          loc: { begin: this.idx, end: input.length },
          global: false,
          ignoreCase: false,
          multiLine: false,
          unicode: false,
          sticky: false
        };
        while (this.isRegExpFlag()) {
          switch (this.popChar()) {
            case "g":
              addFlag(flags, "global");
              break;
            case "i":
              addFlag(flags, "ignoreCase");
              break;
            case "m":
              addFlag(flags, "multiLine");
              break;
            case "u":
              addFlag(flags, "unicode");
              break;
            case "y":
              addFlag(flags, "sticky");
              break;
          }
        }
        if (this.idx !== this.input.length) {
          throw Error("Redundant input: " + this.input.substring(this.idx));
        }
        return {
          type: "Pattern",
          flags,
          value,
          loc: this.loc(0)
        };
      }
      disjunction() {
        const alts = [];
        const begin = this.idx;
        alts.push(this.alternative());
        while (this.peekChar() === "|") {
          this.consumeChar("|");
          alts.push(this.alternative());
        }
        return { type: "Disjunction", value: alts, loc: this.loc(begin) };
      }
      alternative() {
        const terms = [];
        const begin = this.idx;
        while (this.isTerm()) {
          terms.push(this.term());
        }
        return { type: "Alternative", value: terms, loc: this.loc(begin) };
      }
      term() {
        if (this.isAssertion()) {
          return this.assertion();
        } else {
          return this.atom();
        }
      }
      assertion() {
        const begin = this.idx;
        switch (this.popChar()) {
          case "^":
            return {
              type: "StartAnchor",
              loc: this.loc(begin)
            };
          case "$":
            return { type: "EndAnchor", loc: this.loc(begin) };
          case "\\":
            switch (this.popChar()) {
              case "b":
                return {
                  type: "WordBoundary",
                  loc: this.loc(begin)
                };
              case "B":
                return {
                  type: "NonWordBoundary",
                  loc: this.loc(begin)
                };
            }
            throw Error("Invalid Assertion Escape");
          case "(":
            this.consumeChar("?");
            let type;
            switch (this.popChar()) {
              case "=":
                type = "Lookahead";
                break;
              case "!":
                type = "NegativeLookahead";
                break;
            }
            ASSERT_EXISTS(type);
            const disjunction = this.disjunction();
            this.consumeChar(")");
            return {
              type,
              value: disjunction,
              loc: this.loc(begin)
            };
        }
        return ASSERT_NEVER_REACH_HERE();
      }
      quantifier(isBacktracking = false) {
        let range = void 0;
        const begin = this.idx;
        switch (this.popChar()) {
          case "*":
            range = {
              atLeast: 0,
              atMost: Infinity
            };
            break;
          case "+":
            range = {
              atLeast: 1,
              atMost: Infinity
            };
            break;
          case "?":
            range = {
              atLeast: 0,
              atMost: 1
            };
            break;
          case "{":
            const atLeast = this.integerIncludingZero();
            switch (this.popChar()) {
              case "}":
                range = {
                  atLeast,
                  atMost: atLeast
                };
                break;
              case ",":
                let atMost;
                if (this.isDigit()) {
                  atMost = this.integerIncludingZero();
                  range = {
                    atLeast,
                    atMost
                  };
                } else {
                  range = {
                    atLeast,
                    atMost: Infinity
                  };
                }
                this.consumeChar("}");
                break;
            }
            if (isBacktracking === true && range === void 0) {
              return void 0;
            }
            ASSERT_EXISTS(range);
            break;
        }
        if (isBacktracking === true && range === void 0) {
          return void 0;
        }
        if (ASSERT_EXISTS(range)) {
          if (this.peekChar(0) === "?") {
            this.consumeChar("?");
            range.greedy = false;
          } else {
            range.greedy = true;
          }
          range.type = "Quantifier";
          range.loc = this.loc(begin);
          return range;
        }
      }
      atom() {
        let atom;
        const begin = this.idx;
        switch (this.peekChar()) {
          case ".":
            atom = this.dotAll();
            break;
          case "\\":
            atom = this.atomEscape();
            break;
          case "[":
            atom = this.characterClass();
            break;
          case "(":
            atom = this.group();
            break;
        }
        if (atom === void 0 && this.isPatternCharacter()) {
          atom = this.patternCharacter();
        }
        if (ASSERT_EXISTS(atom)) {
          atom.loc = this.loc(begin);
          if (this.isQuantifier()) {
            atom.quantifier = this.quantifier();
          }
          return atom;
        }
        return ASSERT_NEVER_REACH_HERE();
      }
      dotAll() {
        this.consumeChar(".");
        return {
          type: "Set",
          complement: true,
          value: [cc("\n"), cc("\r"), cc("\u2028"), cc("\u2029")]
        };
      }
      atomEscape() {
        this.consumeChar("\\");
        switch (this.peekChar()) {
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            return this.decimalEscapeAtom();
          case "d":
          case "D":
          case "s":
          case "S":
          case "w":
          case "W":
            return this.characterClassEscape();
          case "f":
          case "n":
          case "r":
          case "t":
          case "v":
            return this.controlEscapeAtom();
          case "c":
            return this.controlLetterEscapeAtom();
          case "0":
            return this.nulCharacterAtom();
          case "x":
            return this.hexEscapeSequenceAtom();
          case "u":
            return this.regExpUnicodeEscapeSequenceAtom();
          default:
            return this.identityEscapeAtom();
        }
      }
      decimalEscapeAtom() {
        const value = this.positiveInteger();
        return { type: "GroupBackReference", value };
      }
      characterClassEscape() {
        let set;
        let complement = false;
        switch (this.popChar()) {
          case "d":
            set = digitsCharCodes;
            break;
          case "D":
            set = digitsCharCodes;
            complement = true;
            break;
          case "s":
            set = whitespaceCodes;
            break;
          case "S":
            set = whitespaceCodes;
            complement = true;
            break;
          case "w":
            set = wordCharCodes;
            break;
          case "W":
            set = wordCharCodes;
            complement = true;
            break;
        }
        if (ASSERT_EXISTS(set)) {
          return { type: "Set", value: set, complement };
        }
        return ASSERT_NEVER_REACH_HERE();
      }
      controlEscapeAtom() {
        let escapeCode;
        switch (this.popChar()) {
          case "f":
            escapeCode = cc("\f");
            break;
          case "n":
            escapeCode = cc("\n");
            break;
          case "r":
            escapeCode = cc("\r");
            break;
          case "t":
            escapeCode = cc("	");
            break;
          case "v":
            escapeCode = cc("\v");
            break;
        }
        if (ASSERT_EXISTS(escapeCode)) {
          return { type: "Character", value: escapeCode };
        }
        return ASSERT_NEVER_REACH_HERE();
      }
      controlLetterEscapeAtom() {
        this.consumeChar("c");
        const letter = this.popChar();
        if (/[a-zA-Z]/.test(letter) === false) {
          throw Error("Invalid ");
        }
        const letterCode = letter.toUpperCase().charCodeAt(0) - 64;
        return { type: "Character", value: letterCode };
      }
      nulCharacterAtom() {
        this.consumeChar("0");
        return { type: "Character", value: cc("\0") };
      }
      hexEscapeSequenceAtom() {
        this.consumeChar("x");
        return this.parseHexDigits(2);
      }
      regExpUnicodeEscapeSequenceAtom() {
        this.consumeChar("u");
        return this.parseHexDigits(4);
      }
      identityEscapeAtom() {
        const escapedChar = this.popChar();
        return { type: "Character", value: cc(escapedChar) };
      }
      classPatternCharacterAtom() {
        switch (this.peekChar()) {
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
          case "\\":
          case "]":
            throw Error("TBD");
          default:
            const nextChar = this.popChar();
            return { type: "Character", value: cc(nextChar) };
        }
      }
      characterClass() {
        const set = [];
        let complement = false;
        this.consumeChar("[");
        if (this.peekChar(0) === "^") {
          this.consumeChar("^");
          complement = true;
        }
        while (this.isClassAtom()) {
          const from = this.classAtom();
          const isFromSingleChar = from.type === "Character";
          if (isCharacter(from) && this.isRangeDash()) {
            this.consumeChar("-");
            const to = this.classAtom();
            const isToSingleChar = to.type === "Character";
            if (isCharacter(to)) {
              if (to.value < from.value) {
                throw Error("Range out of order in character class");
              }
              set.push({ from: from.value, to: to.value });
            } else {
              insertToSet(from.value, set);
              set.push(cc("-"));
              insertToSet(to.value, set);
            }
          } else {
            insertToSet(from.value, set);
          }
        }
        this.consumeChar("]");
        return { type: "Set", complement, value: set };
      }
      classAtom() {
        switch (this.peekChar()) {
          case "]":
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            throw Error("TBD");
          case "\\":
            return this.classEscape();
          default:
            return this.classPatternCharacterAtom();
        }
      }
      classEscape() {
        this.consumeChar("\\");
        switch (this.peekChar()) {
          case "b":
            this.consumeChar("b");
            return { type: "Character", value: cc("\b") };
          case "d":
          case "D":
          case "s":
          case "S":
          case "w":
          case "W":
            return this.characterClassEscape();
          case "f":
          case "n":
          case "r":
          case "t":
          case "v":
            return this.controlEscapeAtom();
          case "c":
            return this.controlLetterEscapeAtom();
          case "0":
            return this.nulCharacterAtom();
          case "x":
            return this.hexEscapeSequenceAtom();
          case "u":
            return this.regExpUnicodeEscapeSequenceAtom();
          default:
            return this.identityEscapeAtom();
        }
      }
      group() {
        let capturing = true;
        this.consumeChar("(");
        switch (this.peekChar(0)) {
          case "?":
            this.consumeChar("?");
            this.consumeChar(":");
            capturing = false;
            break;
          default:
            this.groupIdx++;
            break;
        }
        const value = this.disjunction();
        this.consumeChar(")");
        const groupAst = {
          type: "Group",
          capturing,
          value
        };
        if (capturing) {
          groupAst["idx"] = this.groupIdx;
        }
        return groupAst;
      }
      positiveInteger() {
        let number = this.popChar();
        if (decimalPatternNoZero.test(number) === false) {
          throw Error("Expecting a positive integer");
        }
        while (decimalPattern.test(this.peekChar(0))) {
          number += this.popChar();
        }
        return parseInt(number, 10);
      }
      integerIncludingZero() {
        let number = this.popChar();
        if (decimalPattern.test(number) === false) {
          throw Error("Expecting an integer");
        }
        while (decimalPattern.test(this.peekChar(0))) {
          number += this.popChar();
        }
        return parseInt(number, 10);
      }
      patternCharacter() {
        const nextChar = this.popChar();
        switch (nextChar) {
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
          case "^":
          case "$":
          case "\\":
          case ".":
          case "*":
          case "+":
          case "?":
          case "(":
          case ")":
          case "[":
          case "|":
            throw Error("TBD");
          default:
            return { type: "Character", value: cc(nextChar) };
        }
      }
      isRegExpFlag() {
        switch (this.peekChar(0)) {
          case "g":
          case "i":
          case "m":
          case "u":
          case "y":
            return true;
          default:
            return false;
        }
      }
      isRangeDash() {
        return this.peekChar() === "-" && this.isClassAtom(1);
      }
      isDigit() {
        return decimalPattern.test(this.peekChar(0));
      }
      isClassAtom(howMuch = 0) {
        switch (this.peekChar(howMuch)) {
          case "]":
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            return false;
          default:
            return true;
        }
      }
      isTerm() {
        return this.isAtom() || this.isAssertion();
      }
      isAtom() {
        if (this.isPatternCharacter()) {
          return true;
        }
        switch (this.peekChar(0)) {
          case ".":
          case "\\":
          case "[":
          case "(":
            return true;
          default:
            return false;
        }
      }
      isAssertion() {
        switch (this.peekChar(0)) {
          case "^":
          case "$":
            return true;
          case "\\":
            switch (this.peekChar(1)) {
              case "b":
              case "B":
                return true;
              default:
                return false;
            }
          case "(":
            return this.peekChar(1) === "?" && (this.peekChar(2) === "=" || this.peekChar(2) === "!");
          default:
            return false;
        }
      }
      isQuantifier() {
        const prevState = this.saveState();
        try {
          return this.quantifier(true) !== void 0;
        } catch (e) {
          return false;
        } finally {
          this.restoreState(prevState);
        }
      }
      isPatternCharacter() {
        switch (this.peekChar()) {
          case "^":
          case "$":
          case "\\":
          case ".":
          case "*":
          case "+":
          case "?":
          case "(":
          case ")":
          case "[":
          case "|":
          case "/":
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            return false;
          default:
            return true;
        }
      }
      parseHexDigits(howMany) {
        let hexString = "";
        for (let i = 0; i < howMany; i++) {
          const hexChar = this.popChar();
          if (hexDigitPattern.test(hexChar) === false) {
            throw Error("Expecting a HexDecimal digits");
          }
          hexString += hexChar;
        }
        const charCode = parseInt(hexString, 16);
        return { type: "Character", value: charCode };
      }
      peekChar(howMuch = 0) {
        return this.input[this.idx + howMuch];
      }
      popChar() {
        const nextChar = this.peekChar(0);
        this.consumeChar(void 0);
        return nextChar;
      }
      consumeChar(char) {
        if (char !== void 0 && this.input[this.idx] !== char) {
          throw Error("Expected: '" + char + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx);
        }
        if (this.idx >= this.input.length) {
          throw Error("Unexpected end of input");
        }
        this.idx++;
      }
      loc(begin) {
        return { begin, end: this.idx };
      }
    };
  }
});

// node_modules/@chevrotain/regexp-to-ast/lib/src/base-regexp-visitor.js
var BaseRegExpVisitor;
var init_base_regexp_visitor = __esm({
  "node_modules/@chevrotain/regexp-to-ast/lib/src/base-regexp-visitor.js"() {
    BaseRegExpVisitor = class {
      visitChildren(node) {
        for (const key in node) {
          const child = node[key];
          if (node.hasOwnProperty(key)) {
            if (child.type !== void 0) {
              this.visit(child);
            } else if (Array.isArray(child)) {
              child.forEach((subChild) => {
                this.visit(subChild);
              }, this);
            }
          }
        }
      }
      visit(node) {
        switch (node.type) {
          case "Pattern":
            this.visitPattern(node);
            break;
          case "Flags":
            this.visitFlags(node);
            break;
          case "Disjunction":
            this.visitDisjunction(node);
            break;
          case "Alternative":
            this.visitAlternative(node);
            break;
          case "StartAnchor":
            this.visitStartAnchor(node);
            break;
          case "EndAnchor":
            this.visitEndAnchor(node);
            break;
          case "WordBoundary":
            this.visitWordBoundary(node);
            break;
          case "NonWordBoundary":
            this.visitNonWordBoundary(node);
            break;
          case "Lookahead":
            this.visitLookahead(node);
            break;
          case "NegativeLookahead":
            this.visitNegativeLookahead(node);
            break;
          case "Character":
            this.visitCharacter(node);
            break;
          case "Set":
            this.visitSet(node);
            break;
          case "Group":
            this.visitGroup(node);
            break;
          case "GroupBackReference":
            this.visitGroupBackReference(node);
            break;
          case "Quantifier":
            this.visitQuantifier(node);
            break;
        }
        this.visitChildren(node);
      }
      visitPattern(node) {
      }
      visitFlags(node) {
      }
      visitDisjunction(node) {
      }
      visitAlternative(node) {
      }
      // Assertion
      visitStartAnchor(node) {
      }
      visitEndAnchor(node) {
      }
      visitWordBoundary(node) {
      }
      visitNonWordBoundary(node) {
      }
      visitLookahead(node) {
      }
      visitNegativeLookahead(node) {
      }
      // atoms
      visitCharacter(node) {
      }
      visitSet(node) {
      }
      visitGroup(node) {
      }
      visitGroupBackReference(node) {
      }
      visitQuantifier(node) {
      }
    };
  }
});

// node_modules/@chevrotain/regexp-to-ast/lib/src/api.js
var init_api3 = __esm({
  "node_modules/@chevrotain/regexp-to-ast/lib/src/api.js"() {
    init_regexp_parser();
    init_base_regexp_visitor();
  }
});

// node_modules/chevrotain/lib/src/scan/reg_exp_parser.js
function getRegExpAst(regExp) {
  const regExpStr = regExp.toString();
  if (regExpAstCache.hasOwnProperty(regExpStr)) {
    return regExpAstCache[regExpStr];
  } else {
    const regExpAst = regExpParser.pattern(regExpStr);
    regExpAstCache[regExpStr] = regExpAst;
    return regExpAst;
  }
}
function clearRegExpParserCache() {
  regExpAstCache = {};
}
var regExpAstCache, regExpParser;
var init_reg_exp_parser = __esm({
  "node_modules/chevrotain/lib/src/scan/reg_exp_parser.js"() {
    init_api3();
    regExpAstCache = {};
    regExpParser = new RegExpParser();
  }
});

// node_modules/chevrotain/lib/src/scan/reg_exp.js
function getOptimizedStartCodesIndices(regExp, ensureOptimizations = false) {
  try {
    const ast = getRegExpAst(regExp);
    const firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);
    return firstChars;
  } catch (e) {
    if (e.message === complementErrorMessage) {
      if (ensureOptimizations) {
        PRINT_WARNING(`${failedOptimizationPrefixMsg}	Unable to optimize: < ${regExp.toString()} >
	Complement Sets cannot be automatically optimized.
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`);
      }
    } else {
      let msgSuffix = "";
      if (ensureOptimizations) {
        msgSuffix = "\n	This will disable the lexer's first char optimizations.\n	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.";
      }
      PRINT_ERROR(`${failedOptimizationPrefixMsg}
	Failed parsing: < ${regExp.toString()} >
	Using the @chevrotain/regexp-to-ast library
	Please open an issue at: https://github.com/chevrotain/chevrotain/issues` + msgSuffix);
    }
  }
  return [];
}
function firstCharOptimizedIndices(ast, result, ignoreCase) {
  switch (ast.type) {
    case "Disjunction":
      for (let i = 0; i < ast.value.length; i++) {
        firstCharOptimizedIndices(ast.value[i], result, ignoreCase);
      }
      break;
    case "Alternative":
      const terms = ast.value;
      for (let i = 0; i < terms.length; i++) {
        const term = terms[i];
        switch (term.type) {
          case "EndAnchor":
          case "GroupBackReference":
          case "Lookahead":
          case "NegativeLookahead":
          case "StartAnchor":
          case "WordBoundary":
          case "NonWordBoundary":
            continue;
        }
        const atom = term;
        switch (atom.type) {
          case "Character":
            addOptimizedIdxToResult(atom.value, result, ignoreCase);
            break;
          case "Set":
            if (atom.complement === true) {
              throw Error(complementErrorMessage);
            }
            forEach_default(atom.value, (code) => {
              if (typeof code === "number") {
                addOptimizedIdxToResult(code, result, ignoreCase);
              } else {
                const range = code;
                if (ignoreCase === true) {
                  for (let rangeCode = range.from; rangeCode <= range.to; rangeCode++) {
                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                  }
                } else {
                  for (let rangeCode = range.from; rangeCode <= range.to && rangeCode < minOptimizationVal; rangeCode++) {
                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                  }
                  if (range.to >= minOptimizationVal) {
                    const minUnOptVal = range.from >= minOptimizationVal ? range.from : minOptimizationVal;
                    const maxUnOptVal = range.to;
                    const minOptIdx = charCodeToOptimizedIndex(minUnOptVal);
                    const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);
                    for (let currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {
                      result[currOptIdx] = currOptIdx;
                    }
                  }
                }
              }
            });
            break;
          case "Group":
            firstCharOptimizedIndices(atom.value, result, ignoreCase);
            break;
          default:
            throw Error("Non Exhaustive Match");
        }
        const isOptionalQuantifier = atom.quantifier !== void 0 && atom.quantifier.atLeast === 0;
        if (
          // A group may be optional due to empty contents /(?:)/
          // or if everything inside it is optional /((a)?)/
          atom.type === "Group" && isWholeOptional(atom) === false || // If this term is not a group it may only be optional if it has an optional quantifier
          atom.type !== "Group" && isOptionalQuantifier === false
        ) {
          break;
        }
      }
      break;
    default:
      throw Error("non exhaustive match!");
  }
  return values_default(result);
}
function addOptimizedIdxToResult(code, result, ignoreCase) {
  const optimizedCharIdx = charCodeToOptimizedIndex(code);
  result[optimizedCharIdx] = optimizedCharIdx;
  if (ignoreCase === true) {
    handleIgnoreCase(code, result);
  }
}
function handleIgnoreCase(code, result) {
  const char = String.fromCharCode(code);
  const upperChar = char.toUpperCase();
  if (upperChar !== char) {
    const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));
    result[optimizedCharIdx] = optimizedCharIdx;
  } else {
    const lowerChar = char.toLowerCase();
    if (lowerChar !== char) {
      const optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0));
      result[optimizedCharIdx] = optimizedCharIdx;
    }
  }
}
function findCode(setNode, targetCharCodes) {
  return find_default(setNode.value, (codeOrRange) => {
    if (typeof codeOrRange === "number") {
      return includes_default(targetCharCodes, codeOrRange);
    } else {
      const range = codeOrRange;
      return find_default(targetCharCodes, (targetCode) => range.from <= targetCode && targetCode <= range.to) !== void 0;
    }
  });
}
function isWholeOptional(ast) {
  const quantifier = ast.quantifier;
  if (quantifier && quantifier.atLeast === 0) {
    return true;
  }
  if (!ast.value) {
    return false;
  }
  return isArray_default(ast.value) ? every_default(ast.value, isWholeOptional) : isWholeOptional(ast.value);
}
function canMatchCharCode(charCodes, pattern) {
  if (pattern instanceof RegExp) {
    const ast = getRegExpAst(pattern);
    const charCodeFinder = new CharCodeFinder(charCodes);
    charCodeFinder.visit(ast);
    return charCodeFinder.found;
  } else {
    return find_default(pattern, (char) => {
      return includes_default(charCodes, char.charCodeAt(0));
    }) !== void 0;
  }
}
var complementErrorMessage, failedOptimizationPrefixMsg, CharCodeFinder;
var init_reg_exp = __esm({
  "node_modules/chevrotain/lib/src/scan/reg_exp.js"() {
    init_api3();
    init_lodash();
    init_api();
    init_reg_exp_parser();
    init_lexer();
    complementErrorMessage = "Complement Sets are not supported for first char optimization";
    failedOptimizationPrefixMsg = 'Unable to use "first char" lexer optimizations:\n';
    CharCodeFinder = class extends BaseRegExpVisitor {
      constructor(targetCharCodes) {
        super();
        this.targetCharCodes = targetCharCodes;
        this.found = false;
      }
      visitChildren(node) {
        if (this.found === true) {
          return;
        }
        switch (node.type) {
          case "Lookahead":
            this.visitLookahead(node);
            return;
          case "NegativeLookahead":
            this.visitNegativeLookahead(node);
            return;
        }
        super.visitChildren(node);
      }
      visitCharacter(node) {
        if (includes_default(this.targetCharCodes, node.value)) {
          this.found = true;
        }
      }
      visitSet(node) {
        if (node.complement) {
          if (findCode(node, this.targetCharCodes) === void 0) {
            this.found = true;
          }
        } else {
          if (findCode(node, this.targetCharCodes) !== void 0) {
            this.found = true;
          }
        }
      }
    };
  }
});

// node_modules/chevrotain/lib/src/scan/lexer.js
function analyzeTokenTypes(tokenTypes, options) {
  options = defaults_default(options, {
    useSticky: SUPPORT_STICKY,
    debug: false,
    safeMode: false,
    positionTracking: "full",
    lineTerminatorCharacters: ["\r", "\n"],
    tracer: (msg, action) => action()
  });
  const tracer = options.tracer;
  tracer("initCharCodeToOptimizedIndexMap", () => {
    initCharCodeToOptimizedIndexMap();
  });
  let onlyRelevantTypes;
  tracer("Reject Lexer.NA", () => {
    onlyRelevantTypes = reject_default(tokenTypes, (currType) => {
      return currType[PATTERN] === Lexer.NA;
    });
  });
  let hasCustom = false;
  let allTransformedPatterns;
  tracer("Transform Patterns", () => {
    hasCustom = false;
    allTransformedPatterns = map_default(onlyRelevantTypes, (currType) => {
      const currPattern = currType[PATTERN];
      if (isRegExp_default(currPattern)) {
        const regExpSource = currPattern.source;
        if (regExpSource.length === 1 && // only these regExp meta characters which can appear in a length one regExp
        regExpSource !== "^" && regExpSource !== "$" && regExpSource !== "." && !currPattern.ignoreCase) {
          return regExpSource;
        } else if (regExpSource.length === 2 && regExpSource[0] === "\\" && // not a meta character
        !includes_default([
          "d",
          "D",
          "s",
          "S",
          "t",
          "r",
          "n",
          "t",
          "0",
          "c",
          "b",
          "B",
          "f",
          "v",
          "w",
          "W"
        ], regExpSource[1])) {
          return regExpSource[1];
        } else {
          return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);
        }
      } else if (isFunction_default(currPattern)) {
        hasCustom = true;
        return { exec: currPattern };
      } else if (typeof currPattern === "object") {
        hasCustom = true;
        return currPattern;
      } else if (typeof currPattern === "string") {
        if (currPattern.length === 1) {
          return currPattern;
        } else {
          const escapedRegExpString = currPattern.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
          const wrappedRegExp = new RegExp(escapedRegExpString);
          return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);
        }
      } else {
        throw Error("non exhaustive match");
      }
    });
  });
  let patternIdxToType;
  let patternIdxToGroup;
  let patternIdxToLongerAltIdxArr;
  let patternIdxToPushMode;
  let patternIdxToPopMode;
  tracer("misc mapping", () => {
    patternIdxToType = map_default(onlyRelevantTypes, (currType) => currType.tokenTypeIdx);
    patternIdxToGroup = map_default(onlyRelevantTypes, (clazz) => {
      const groupName = clazz.GROUP;
      if (groupName === Lexer.SKIPPED) {
        return void 0;
      } else if (isString_default(groupName)) {
        return groupName;
      } else if (isUndefined_default(groupName)) {
        return false;
      } else {
        throw Error("non exhaustive match");
      }
    });
    patternIdxToLongerAltIdxArr = map_default(onlyRelevantTypes, (clazz) => {
      const longerAltType = clazz.LONGER_ALT;
      if (longerAltType) {
        const longerAltIdxArr = isArray_default(longerAltType) ? map_default(longerAltType, (type) => indexOf_default(onlyRelevantTypes, type)) : [indexOf_default(onlyRelevantTypes, longerAltType)];
        return longerAltIdxArr;
      }
    });
    patternIdxToPushMode = map_default(onlyRelevantTypes, (clazz) => clazz.PUSH_MODE);
    patternIdxToPopMode = map_default(onlyRelevantTypes, (clazz) => has_default(clazz, "POP_MODE"));
  });
  let patternIdxToCanLineTerminator;
  tracer("Line Terminator Handling", () => {
    const lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);
    patternIdxToCanLineTerminator = map_default(onlyRelevantTypes, (tokType) => false);
    if (options.positionTracking !== "onlyOffset") {
      patternIdxToCanLineTerminator = map_default(onlyRelevantTypes, (tokType) => {
        if (has_default(tokType, "LINE_BREAKS")) {
          return !!tokType.LINE_BREAKS;
        } else {
          return checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false && canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);
        }
      });
    }
  });
  let patternIdxToIsCustom;
  let patternIdxToShort;
  let emptyGroups;
  let patternIdxToConfig;
  tracer("Misc Mapping #2", () => {
    patternIdxToIsCustom = map_default(onlyRelevantTypes, isCustomPattern);
    patternIdxToShort = map_default(allTransformedPatterns, isShortPattern);
    emptyGroups = reduce_default(onlyRelevantTypes, (acc, clazz) => {
      const groupName = clazz.GROUP;
      if (isString_default(groupName) && !(groupName === Lexer.SKIPPED)) {
        acc[groupName] = [];
      }
      return acc;
    }, {});
    patternIdxToConfig = map_default(allTransformedPatterns, (x, idx) => {
      return {
        pattern: allTransformedPatterns[idx],
        longerAlt: patternIdxToLongerAltIdxArr[idx],
        canLineTerminator: patternIdxToCanLineTerminator[idx],
        isCustom: patternIdxToIsCustom[idx],
        short: patternIdxToShort[idx],
        group: patternIdxToGroup[idx],
        push: patternIdxToPushMode[idx],
        pop: patternIdxToPopMode[idx],
        tokenTypeIdx: patternIdxToType[idx],
        tokenType: onlyRelevantTypes[idx]
      };
    });
  });
  let canBeOptimized = true;
  let charCodeToPatternIdxToConfig = [];
  if (!options.safeMode) {
    tracer("First Char Optimization", () => {
      charCodeToPatternIdxToConfig = reduce_default(onlyRelevantTypes, (result, currTokType, idx) => {
        if (typeof currTokType.PATTERN === "string") {
          const charCode = currTokType.PATTERN.charCodeAt(0);
          const optimizedIdx = charCodeToOptimizedIndex(charCode);
          addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);
        } else if (isArray_default(currTokType.START_CHARS_HINT)) {
          let lastOptimizedIdx;
          forEach_default(currTokType.START_CHARS_HINT, (charOrInt) => {
            const charCode = typeof charOrInt === "string" ? charOrInt.charCodeAt(0) : charOrInt;
            const currOptimizedIdx = charCodeToOptimizedIndex(charCode);
            if (lastOptimizedIdx !== currOptimizedIdx) {
              lastOptimizedIdx = currOptimizedIdx;
              addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);
            }
          });
        } else if (isRegExp_default(currTokType.PATTERN)) {
          if (currTokType.PATTERN.unicode) {
            canBeOptimized = false;
            if (options.ensureOptimizations) {
              PRINT_ERROR(`${failedOptimizationPrefixMsg}	Unable to analyze < ${currTokType.PATTERN.toString()} > pattern.
	The regexp unicode flag is not currently supported by the regexp-to-ast library.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`);
            }
          } else {
            const optimizedCodes = getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations);
            if (isEmpty_default(optimizedCodes)) {
              canBeOptimized = false;
            }
            forEach_default(optimizedCodes, (code) => {
              addToMapOfArrays(result, code, patternIdxToConfig[idx]);
            });
          }
        } else {
          if (options.ensureOptimizations) {
            PRINT_ERROR(`${failedOptimizationPrefixMsg}	TokenType: <${currTokType.name}> is using a custom token pattern without providing <start_chars_hint> parameter.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`);
          }
          canBeOptimized = false;
        }
        return result;
      }, []);
    });
  }
  return {
    emptyGroups,
    patternIdxToConfig,
    charCodeToPatternIdxToConfig,
    hasCustom,
    canBeOptimized
  };
}
function validatePatterns(tokenTypes, validModesNames) {
  let errors = [];
  const missingResult = findMissingPatterns(tokenTypes);
  errors = errors.concat(missingResult.errors);
  const invalidResult = findInvalidPatterns(missingResult.valid);
  const validTokenTypes = invalidResult.valid;
  errors = errors.concat(invalidResult.errors);
  errors = errors.concat(validateRegExpPattern(validTokenTypes));
  errors = errors.concat(findInvalidGroupType(validTokenTypes));
  errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));
  errors = errors.concat(findUnreachablePatterns(validTokenTypes));
  return errors;
}
function validateRegExpPattern(tokenTypes) {
  let errors = [];
  const withRegExpPatterns = filter_default(tokenTypes, (currTokType) => isRegExp_default(currTokType[PATTERN]));
  errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));
  errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));
  errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));
  errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));
  errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));
  return errors;
}
function findMissingPatterns(tokenTypes) {
  const tokenTypesWithMissingPattern = filter_default(tokenTypes, (currType) => {
    return !has_default(currType, PATTERN);
  });
  const errors = map_default(tokenTypesWithMissingPattern, (currType) => {
    return {
      message: "Token Type: ->" + currType.name + "<- missing static 'PATTERN' property",
      type: LexerDefinitionErrorType.MISSING_PATTERN,
      tokenTypes: [currType]
    };
  });
  const valid = difference_default(tokenTypes, tokenTypesWithMissingPattern);
  return { errors, valid };
}
function findInvalidPatterns(tokenTypes) {
  const tokenTypesWithInvalidPattern = filter_default(tokenTypes, (currType) => {
    const pattern = currType[PATTERN];
    return !isRegExp_default(pattern) && !isFunction_default(pattern) && !has_default(pattern, "exec") && !isString_default(pattern);
  });
  const errors = map_default(tokenTypesWithInvalidPattern, (currType) => {
    return {
      message: "Token Type: ->" + currType.name + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
      type: LexerDefinitionErrorType.INVALID_PATTERN,
      tokenTypes: [currType]
    };
  });
  const valid = difference_default(tokenTypes, tokenTypesWithInvalidPattern);
  return { errors, valid };
}
function findEndOfInputAnchor(tokenTypes) {
  class EndAnchorFinder extends BaseRegExpVisitor {
    constructor() {
      super(...arguments);
      this.found = false;
    }
    visitEndAnchor(node) {
      this.found = true;
    }
  }
  const invalidRegex = filter_default(tokenTypes, (currType) => {
    const pattern = currType.PATTERN;
    try {
      const regexpAst = getRegExpAst(pattern);
      const endAnchorVisitor = new EndAnchorFinder();
      endAnchorVisitor.visit(regexpAst);
      return endAnchorVisitor.found;
    } catch (e) {
      return end_of_input.test(pattern.source);
    }
  });
  const errors = map_default(invalidRegex, (currType) => {
    return {
      message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + currType.name + "<- static 'PATTERN' cannot contain end of input anchor '$'\n	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",
      type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,
      tokenTypes: [currType]
    };
  });
  return errors;
}
function findEmptyMatchRegExps(tokenTypes) {
  const matchesEmptyString = filter_default(tokenTypes, (currType) => {
    const pattern = currType.PATTERN;
    return pattern.test("");
  });
  const errors = map_default(matchesEmptyString, (currType) => {
    return {
      message: "Token Type: ->" + currType.name + "<- static 'PATTERN' must not match an empty string",
      type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,
      tokenTypes: [currType]
    };
  });
  return errors;
}
function findStartOfInputAnchor(tokenTypes) {
  class StartAnchorFinder extends BaseRegExpVisitor {
    constructor() {
      super(...arguments);
      this.found = false;
    }
    visitStartAnchor(node) {
      this.found = true;
    }
  }
  const invalidRegex = filter_default(tokenTypes, (currType) => {
    const pattern = currType.PATTERN;
    try {
      const regexpAst = getRegExpAst(pattern);
      const startAnchorVisitor = new StartAnchorFinder();
      startAnchorVisitor.visit(regexpAst);
      return startAnchorVisitor.found;
    } catch (e) {
      return start_of_input.test(pattern.source);
    }
  });
  const errors = map_default(invalidRegex, (currType) => {
    return {
      message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + currType.name + "<- static 'PATTERN' cannot contain start of input anchor '^'\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",
      type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,
      tokenTypes: [currType]
    };
  });
  return errors;
}
function findUnsupportedFlags(tokenTypes) {
  const invalidFlags = filter_default(tokenTypes, (currType) => {
    const pattern = currType[PATTERN];
    return pattern instanceof RegExp && (pattern.multiline || pattern.global);
  });
  const errors = map_default(invalidFlags, (currType) => {
    return {
      message: "Token Type: ->" + currType.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
      type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,
      tokenTypes: [currType]
    };
  });
  return errors;
}
function findDuplicatePatterns(tokenTypes) {
  const found = [];
  let identicalPatterns = map_default(tokenTypes, (outerType) => {
    return reduce_default(tokenTypes, (result, innerType) => {
      if (outerType.PATTERN.source === innerType.PATTERN.source && !includes_default(found, innerType) && innerType.PATTERN !== Lexer.NA) {
        found.push(innerType);
        result.push(innerType);
        return result;
      }
      return result;
    }, []);
  });
  identicalPatterns = compact_default(identicalPatterns);
  const duplicatePatterns = filter_default(identicalPatterns, (currIdenticalSet) => {
    return currIdenticalSet.length > 1;
  });
  const errors = map_default(duplicatePatterns, (setOfIdentical) => {
    const tokenTypeNames = map_default(setOfIdentical, (currType) => {
      return currType.name;
    });
    const dupPatternSrc = head_default(setOfIdentical).PATTERN;
    return {
      message: `The same RegExp pattern ->${dupPatternSrc}<-has been used in all of the following Token Types: ${tokenTypeNames.join(", ")} <-`,
      type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,
      tokenTypes: setOfIdentical
    };
  });
  return errors;
}
function findInvalidGroupType(tokenTypes) {
  const invalidTypes = filter_default(tokenTypes, (clazz) => {
    if (!has_default(clazz, "GROUP")) {
      return false;
    }
    const group = clazz.GROUP;
    return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString_default(group);
  });
  const errors = map_default(invalidTypes, (currType) => {
    return {
      message: "Token Type: ->" + currType.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
      type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,
      tokenTypes: [currType]
    };
  });
  return errors;
}
function findModesThatDoNotExist(tokenTypes, validModes) {
  const invalidModes = filter_default(tokenTypes, (clazz) => {
    return clazz.PUSH_MODE !== void 0 && !includes_default(validModes, clazz.PUSH_MODE);
  });
  const errors = map_default(invalidModes, (tokType) => {
    const msg = `Token Type: ->${tokType.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${tokType.PUSH_MODE}<-which does not exist`;
    return {
      message: msg,
      type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,
      tokenTypes: [tokType]
    };
  });
  return errors;
}
function findUnreachablePatterns(tokenTypes) {
  const errors = [];
  const canBeTested = reduce_default(tokenTypes, (result, tokType, idx) => {
    const pattern = tokType.PATTERN;
    if (pattern === Lexer.NA) {
      return result;
    }
    if (isString_default(pattern)) {
      result.push({ str: pattern, idx, tokenType: tokType });
    } else if (isRegExp_default(pattern) && noMetaChar(pattern)) {
      result.push({ str: pattern.source, idx, tokenType: tokType });
    }
    return result;
  }, []);
  forEach_default(tokenTypes, (tokType, testIdx) => {
    forEach_default(canBeTested, ({ str, idx, tokenType }) => {
      if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {
        const msg = `Token: ->${tokenType.name}<- can never be matched.
Because it appears AFTER the Token Type ->${tokType.name}<-in the lexer's definition.
See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;
        errors.push({
          message: msg,
          type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,
          tokenTypes: [tokType, tokenType]
        });
      }
    });
  });
  return errors;
}
function testTokenType(str, pattern) {
  if (isRegExp_default(pattern)) {
    const regExpArray = pattern.exec(str);
    return regExpArray !== null && regExpArray.index === 0;
  } else if (isFunction_default(pattern)) {
    return pattern(str, 0, [], {});
  } else if (has_default(pattern, "exec")) {
    return pattern.exec(str, 0, [], {});
  } else if (typeof pattern === "string") {
    return pattern === str;
  } else {
    throw Error("non exhaustive match");
  }
}
function noMetaChar(regExp) {
  const metaChars = [
    ".",
    "\\",
    "[",
    "]",
    "|",
    "^",
    "$",
    "(",
    ")",
    "?",
    "*",
    "+",
    "{"
  ];
  return find_default(metaChars, (char) => regExp.source.indexOf(char) !== -1) === void 0;
}
function addStartOfInput(pattern) {
  const flags = pattern.ignoreCase ? "i" : "";
  return new RegExp(`^(?:${pattern.source})`, flags);
}
function addStickyFlag(pattern) {
  const flags = pattern.ignoreCase ? "iy" : "y";
  return new RegExp(`${pattern.source}`, flags);
}
function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
  const errors = [];
  if (!has_default(lexerDefinition, DEFAULT_MODE)) {
    errors.push({
      message: "A MultiMode Lexer cannot be initialized without a <" + DEFAULT_MODE + "> property in its definition\n",
      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
    });
  }
  if (!has_default(lexerDefinition, MODES)) {
    errors.push({
      message: "A MultiMode Lexer cannot be initialized without a <" + MODES + "> property in its definition\n",
      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
    });
  }
  if (has_default(lexerDefinition, MODES) && has_default(lexerDefinition, DEFAULT_MODE) && !has_default(lexerDefinition.modes, lexerDefinition.defaultMode)) {
    errors.push({
      message: `A MultiMode Lexer cannot be initialized with a ${DEFAULT_MODE}: <${lexerDefinition.defaultMode}>which does not exist
`,
      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
    });
  }
  if (has_default(lexerDefinition, MODES)) {
    forEach_default(lexerDefinition.modes, (currModeValue, currModeName) => {
      forEach_default(currModeValue, (currTokType, currIdx) => {
        if (isUndefined_default(currTokType)) {
          errors.push({
            message: `A Lexer cannot be initialized using an undefined Token Type. Mode:<${currModeName}> at index: <${currIdx}>
`,
            type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
          });
        } else if (has_default(currTokType, "LONGER_ALT")) {
          const longerAlt = isArray_default(currTokType.LONGER_ALT) ? currTokType.LONGER_ALT : [currTokType.LONGER_ALT];
          forEach_default(longerAlt, (currLongerAlt) => {
            if (!isUndefined_default(currLongerAlt) && !includes_default(currModeValue, currLongerAlt)) {
              errors.push({
                message: `A MultiMode Lexer cannot be initialized with a longer_alt <${currLongerAlt.name}> on token <${currTokType.name}> outside of mode <${currModeName}>
`,
                type: LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE
              });
            }
          });
        }
      });
    });
  }
  return errors;
}
function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
  const warnings = [];
  let hasAnyLineBreak = false;
  const allTokenTypes = compact_default(flatten_default(values_default(lexerDefinition.modes)));
  const concreteTokenTypes = reject_default(allTokenTypes, (currType) => currType[PATTERN] === Lexer.NA);
  const terminatorCharCodes = getCharCodes(lineTerminatorCharacters);
  if (trackLines) {
    forEach_default(concreteTokenTypes, (tokType) => {
      const currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);
      if (currIssue !== false) {
        const message = buildLineBreakIssueMessage(tokType, currIssue);
        const warningDescriptor = {
          message,
          type: currIssue.issue,
          tokenType: tokType
        };
        warnings.push(warningDescriptor);
      } else {
        if (has_default(tokType, "LINE_BREAKS")) {
          if (tokType.LINE_BREAKS === true) {
            hasAnyLineBreak = true;
          }
        } else {
          if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {
            hasAnyLineBreak = true;
          }
        }
      }
    });
  }
  if (trackLines && !hasAnyLineBreak) {
    warnings.push({
      message: "Warning: No LINE_BREAKS Found.\n	This Lexer has been defined to track line and column information,\n	But none of the Token Types can be identified as matching a line terminator.\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n	for details.",
      type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS
    });
  }
  return warnings;
}
function cloneEmptyGroups(emptyGroups) {
  const clonedResult = {};
  const groupKeys = keys_default(emptyGroups);
  forEach_default(groupKeys, (currKey) => {
    const currGroupValue = emptyGroups[currKey];
    if (isArray_default(currGroupValue)) {
      clonedResult[currKey] = [];
    } else {
      throw Error("non exhaustive match");
    }
  });
  return clonedResult;
}
function isCustomPattern(tokenType) {
  const pattern = tokenType.PATTERN;
  if (isRegExp_default(pattern)) {
    return false;
  } else if (isFunction_default(pattern)) {
    return true;
  } else if (has_default(pattern, "exec")) {
    return true;
  } else if (isString_default(pattern)) {
    return false;
  } else {
    throw Error("non exhaustive match");
  }
}
function isShortPattern(pattern) {
  if (isString_default(pattern) && pattern.length === 1) {
    return pattern.charCodeAt(0);
  } else {
    return false;
  }
}
function checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {
  if (has_default(tokType, "LINE_BREAKS")) {
    return false;
  } else {
    if (isRegExp_default(tokType.PATTERN)) {
      try {
        canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);
      } catch (e) {
        return {
          issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,
          errMsg: e.message
        };
      }
      return false;
    } else if (isString_default(tokType.PATTERN)) {
      return false;
    } else if (isCustomPattern(tokType)) {
      return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK };
    } else {
      throw Error("non exhaustive match");
    }
  }
}
function buildLineBreakIssueMessage(tokType, details) {
  if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {
    return `Warning: unable to identify line terminator usage in pattern.
	The problem is in the <${tokType.name}> Token Type
	 Root cause: ${details.errMsg}.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR`;
  } else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {
    return `Warning: A Custom Token Pattern should specify the <line_breaks> option.
	The problem is in the <${tokType.name}> Token Type
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK`;
  } else {
    throw Error("non exhaustive match");
  }
}
function getCharCodes(charsOrCodes) {
  const charCodes = map_default(charsOrCodes, (numOrString) => {
    if (isString_default(numOrString)) {
      return numOrString.charCodeAt(0);
    } else {
      return numOrString;
    }
  });
  return charCodes;
}
function addToMapOfArrays(map2, key, value) {
  if (map2[key] === void 0) {
    map2[key] = [value];
  } else {
    map2[key].push(value);
  }
}
function charCodeToOptimizedIndex(charCode) {
  return charCode < minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];
}
function initCharCodeToOptimizedIndexMap() {
  if (isEmpty_default(charCodeToOptimizedIdxMap)) {
    charCodeToOptimizedIdxMap = new Array(65536);
    for (let i = 0; i < 65536; i++) {
      charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;
    }
  }
}
var PATTERN, DEFAULT_MODE, MODES, SUPPORT_STICKY, end_of_input, start_of_input, LineTerminatorOptimizedTester, minOptimizationVal, charCodeToOptimizedIdxMap;
var init_lexer = __esm({
  "node_modules/chevrotain/lib/src/scan/lexer.js"() {
    init_api3();
    init_lexer_public();
    init_lodash();
    init_api();
    init_reg_exp();
    init_reg_exp_parser();
    PATTERN = "PATTERN";
    DEFAULT_MODE = "defaultMode";
    MODES = "modes";
    SUPPORT_STICKY = typeof new RegExp("(?:)").sticky === "boolean";
    end_of_input = /[^\\][$]/;
    start_of_input = /[^\\[][\^]|^\^/;
    LineTerminatorOptimizedTester = {
      // implements /\n|\r\n?/g.test
      test: function(text) {
        const len = text.length;
        for (let i = this.lastIndex; i < len; i++) {
          const c = text.charCodeAt(i);
          if (c === 10) {
            this.lastIndex = i + 1;
            return true;
          } else if (c === 13) {
            if (text.charCodeAt(i + 1) === 10) {
              this.lastIndex = i + 2;
            } else {
              this.lastIndex = i + 1;
            }
            return true;
          }
        }
        return false;
      },
      lastIndex: 0
    };
    minOptimizationVal = 256;
    charCodeToOptimizedIdxMap = [];
  }
});

// node_modules/chevrotain/lib/src/scan/tokens.js
function tokenStructuredMatcher(tokInstance, tokConstructor) {
  const instanceType = tokInstance.tokenTypeIdx;
  if (instanceType === tokConstructor.tokenTypeIdx) {
    return true;
  } else {
    return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;
  }
}
function tokenStructuredMatcherNoCategories(token, tokType) {
  return token.tokenTypeIdx === tokType.tokenTypeIdx;
}
function augmentTokenTypes(tokenTypes) {
  const tokenTypesAndParents = expandCategories(tokenTypes);
  assignTokenDefaultProps(tokenTypesAndParents);
  assignCategoriesMapProp(tokenTypesAndParents);
  assignCategoriesTokensProp(tokenTypesAndParents);
  forEach_default(tokenTypesAndParents, (tokType) => {
    tokType.isParent = tokType.categoryMatches.length > 0;
  });
}
function expandCategories(tokenTypes) {
  let result = clone_default(tokenTypes);
  let categories = tokenTypes;
  let searching = true;
  while (searching) {
    categories = compact_default(flatten_default(map_default(categories, (currTokType) => currTokType.CATEGORIES)));
    const newCategories = difference_default(categories, result);
    result = result.concat(newCategories);
    if (isEmpty_default(newCategories)) {
      searching = false;
    } else {
      categories = newCategories;
    }
  }
  return result;
}
function assignTokenDefaultProps(tokenTypes) {
  forEach_default(tokenTypes, (currTokType) => {
    if (!hasShortKeyProperty(currTokType)) {
      tokenIdxToClass[tokenShortNameIdx] = currTokType;
      currTokType.tokenTypeIdx = tokenShortNameIdx++;
    }
    if (hasCategoriesProperty(currTokType) && !isArray_default(currTokType.CATEGORIES)) {
      currTokType.CATEGORIES = [currTokType.CATEGORIES];
    }
    if (!hasCategoriesProperty(currTokType)) {
      currTokType.CATEGORIES = [];
    }
    if (!hasExtendingTokensTypesProperty(currTokType)) {
      currTokType.categoryMatches = [];
    }
    if (!hasExtendingTokensTypesMapProperty(currTokType)) {
      currTokType.categoryMatchesMap = {};
    }
  });
}
function assignCategoriesTokensProp(tokenTypes) {
  forEach_default(tokenTypes, (currTokType) => {
    currTokType.categoryMatches = [];
    forEach_default(currTokType.categoryMatchesMap, (val, key) => {
      currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);
    });
  });
}
function assignCategoriesMapProp(tokenTypes) {
  forEach_default(tokenTypes, (currTokType) => {
    singleAssignCategoriesToksMap([], currTokType);
  });
}
function singleAssignCategoriesToksMap(path4, nextNode) {
  forEach_default(path4, (pathNode) => {
    nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;
  });
  forEach_default(nextNode.CATEGORIES, (nextCategory) => {
    const newPath = path4.concat(nextNode);
    if (!includes_default(newPath, nextCategory)) {
      singleAssignCategoriesToksMap(newPath, nextCategory);
    }
  });
}
function hasShortKeyProperty(tokType) {
  return has_default(tokType, "tokenTypeIdx");
}
function hasCategoriesProperty(tokType) {
  return has_default(tokType, "CATEGORIES");
}
function hasExtendingTokensTypesProperty(tokType) {
  return has_default(tokType, "categoryMatches");
}
function hasExtendingTokensTypesMapProperty(tokType) {
  return has_default(tokType, "categoryMatchesMap");
}
function isTokenType(tokType) {
  return has_default(tokType, "tokenTypeIdx");
}
var tokenShortNameIdx, tokenIdxToClass;
var init_tokens = __esm({
  "node_modules/chevrotain/lib/src/scan/tokens.js"() {
    init_lodash();
    tokenShortNameIdx = 1;
    tokenIdxToClass = {};
  }
});

// node_modules/chevrotain/lib/src/scan/lexer_errors_public.js
var defaultLexerErrorProvider;
var init_lexer_errors_public = __esm({
  "node_modules/chevrotain/lib/src/scan/lexer_errors_public.js"() {
    defaultLexerErrorProvider = {
      buildUnableToPopLexerModeMessage(token) {
        return `Unable to pop Lexer Mode after encountering Token ->${token.image}<- The Mode Stack is empty`;
      },
      buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {
        return `unexpected character: ->${fullText.charAt(startOffset)}<- at offset: ${startOffset}, skipped ${length} characters.`;
      }
    };
  }
});

// node_modules/chevrotain/lib/src/scan/lexer_public.js
var LexerDefinitionErrorType, DEFAULT_LEXER_CONFIG, Lexer;
var init_lexer_public = __esm({
  "node_modules/chevrotain/lib/src/scan/lexer_public.js"() {
    init_lexer();
    init_lodash();
    init_api();
    init_tokens();
    init_lexer_errors_public();
    init_reg_exp_parser();
    (function(LexerDefinitionErrorType2) {
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["MISSING_PATTERN"] = 0] = "MISSING_PATTERN";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["INVALID_PATTERN"] = 1] = "INVALID_PATTERN";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["EOI_ANCHOR_FOUND"] = 2] = "EOI_ANCHOR_FOUND";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["UNSUPPORTED_FLAGS_FOUND"] = 3] = "UNSUPPORTED_FLAGS_FOUND";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["DUPLICATE_PATTERNS_FOUND"] = 4] = "DUPLICATE_PATTERNS_FOUND";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["INVALID_GROUP_TYPE_FOUND"] = 5] = "INVALID_GROUP_TYPE_FOUND";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["PUSH_MODE_DOES_NOT_EXIST"] = 6] = "PUSH_MODE_DOES_NOT_EXIST";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE"] = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY"] = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST"] = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED"] = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["SOI_ANCHOR_FOUND"] = 11] = "SOI_ANCHOR_FOUND";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["EMPTY_MATCH_PATTERN"] = 12] = "EMPTY_MATCH_PATTERN";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["NO_LINE_BREAKS_FLAGS"] = 13] = "NO_LINE_BREAKS_FLAGS";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["UNREACHABLE_PATTERN"] = 14] = "UNREACHABLE_PATTERN";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["IDENTIFY_TERMINATOR"] = 15] = "IDENTIFY_TERMINATOR";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["CUSTOM_LINE_BREAK"] = 16] = "CUSTOM_LINE_BREAK";
      LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE"] = 17] = "MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE";
    })(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));
    DEFAULT_LEXER_CONFIG = {
      deferDefinitionErrorsHandling: false,
      positionTracking: "full",
      lineTerminatorsPattern: /\n|\r\n?/g,
      lineTerminatorCharacters: ["\n", "\r"],
      ensureOptimizations: false,
      safeMode: false,
      errorMessageProvider: defaultLexerErrorProvider,
      traceInitPerf: false,
      skipValidations: false,
      recoveryEnabled: true
    };
    Object.freeze(DEFAULT_LEXER_CONFIG);
    Lexer = class {
      constructor(lexerDefinition, config = DEFAULT_LEXER_CONFIG) {
        this.lexerDefinition = lexerDefinition;
        this.lexerDefinitionErrors = [];
        this.lexerDefinitionWarning = [];
        this.patternIdxToConfig = {};
        this.charCodeToPatternIdxToConfig = {};
        this.modes = [];
        this.emptyGroups = {};
        this.trackStartLines = true;
        this.trackEndLines = true;
        this.hasCustom = false;
        this.canModeBeOptimized = {};
        this.TRACE_INIT = (phaseDesc, phaseImpl) => {
          if (this.traceInitPerf === true) {
            this.traceInitIndent++;
            const indent = new Array(this.traceInitIndent + 1).join("	");
            if (this.traceInitIndent < this.traceInitMaxIdent) {
              console.log(`${indent}--> <${phaseDesc}>`);
            }
            const { time, value } = timer(phaseImpl);
            const traceMethod = time > 10 ? console.warn : console.log;
            if (this.traceInitIndent < this.traceInitMaxIdent) {
              traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);
            }
            this.traceInitIndent--;
            return value;
          } else {
            return phaseImpl();
          }
        };
        if (typeof config === "boolean") {
          throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\na boolean 2nd argument is no longer supported");
        }
        this.config = assign_default({}, DEFAULT_LEXER_CONFIG, config);
        const traceInitVal = this.config.traceInitPerf;
        if (traceInitVal === true) {
          this.traceInitMaxIdent = Infinity;
          this.traceInitPerf = true;
        } else if (typeof traceInitVal === "number") {
          this.traceInitMaxIdent = traceInitVal;
          this.traceInitPerf = true;
        }
        this.traceInitIndent = -1;
        this.TRACE_INIT("Lexer Constructor", () => {
          let actualDefinition;
          let hasOnlySingleMode = true;
          this.TRACE_INIT("Lexer Config handling", () => {
            if (this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {
              this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;
            } else {
              if (this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {
                throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");
              }
            }
            if (config.safeMode && config.ensureOptimizations) {
              throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
            }
            this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking);
            this.trackEndLines = /full/i.test(this.config.positionTracking);
            if (isArray_default(lexerDefinition)) {
              actualDefinition = {
                modes: { defaultMode: clone_default(lexerDefinition) },
                defaultMode: DEFAULT_MODE
              };
            } else {
              hasOnlySingleMode = false;
              actualDefinition = clone_default(lexerDefinition);
            }
          });
          if (this.config.skipValidations === false) {
            this.TRACE_INIT("performRuntimeChecks", () => {
              this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(performRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));
            });
            this.TRACE_INIT("performWarningRuntimeChecks", () => {
              this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(performWarningRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));
            });
          }
          actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {};
          forEach_default(actualDefinition.modes, (currModeValue, currModeName) => {
            actualDefinition.modes[currModeName] = reject_default(currModeValue, (currTokType) => isUndefined_default(currTokType));
          });
          const allModeNames = keys_default(actualDefinition.modes);
          forEach_default(actualDefinition.modes, (currModDef, currModName) => {
            this.TRACE_INIT(`Mode: <${currModName}> processing`, () => {
              this.modes.push(currModName);
              if (this.config.skipValidations === false) {
                this.TRACE_INIT(`validatePatterns`, () => {
                  this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(validatePatterns(currModDef, allModeNames));
                });
              }
              if (isEmpty_default(this.lexerDefinitionErrors)) {
                augmentTokenTypes(currModDef);
                let currAnalyzeResult;
                this.TRACE_INIT(`analyzeTokenTypes`, () => {
                  currAnalyzeResult = analyzeTokenTypes(currModDef, {
                    lineTerminatorCharacters: this.config.lineTerminatorCharacters,
                    positionTracking: config.positionTracking,
                    ensureOptimizations: config.ensureOptimizations,
                    safeMode: config.safeMode,
                    tracer: this.TRACE_INIT
                  });
                });
                this.patternIdxToConfig[currModName] = currAnalyzeResult.patternIdxToConfig;
                this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult.charCodeToPatternIdxToConfig;
                this.emptyGroups = assign_default({}, this.emptyGroups, currAnalyzeResult.emptyGroups);
                this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom;
                this.canModeBeOptimized[currModName] = currAnalyzeResult.canBeOptimized;
              }
            });
          });
          this.defaultMode = actualDefinition.defaultMode;
          if (!isEmpty_default(this.lexerDefinitionErrors) && !this.config.deferDefinitionErrorsHandling) {
            const allErrMessages = map_default(this.lexerDefinitionErrors, (error) => {
              return error.message;
            });
            const allErrMessagesString = allErrMessages.join("-----------------------\n");
            throw new Error("Errors detected in definition of Lexer:\n" + allErrMessagesString);
          }
          forEach_default(this.lexerDefinitionWarning, (warningDescriptor) => {
            PRINT_WARNING(warningDescriptor.message);
          });
          this.TRACE_INIT("Choosing sub-methods implementations", () => {
            if (SUPPORT_STICKY) {
              this.chopInput = identity_default;
              this.match = this.matchWithTest;
            } else {
              this.updateLastIndex = noop_default;
              this.match = this.matchWithExec;
            }
            if (hasOnlySingleMode) {
              this.handleModes = noop_default;
            }
            if (this.trackStartLines === false) {
              this.computeNewColumn = identity_default;
            }
            if (this.trackEndLines === false) {
              this.updateTokenEndLineColumnLocation = noop_default;
            }
            if (/full/i.test(this.config.positionTracking)) {
              this.createTokenInstance = this.createFullToken;
            } else if (/onlyStart/i.test(this.config.positionTracking)) {
              this.createTokenInstance = this.createStartOnlyToken;
            } else if (/onlyOffset/i.test(this.config.positionTracking)) {
              this.createTokenInstance = this.createOffsetOnlyToken;
            } else {
              throw Error(`Invalid <positionTracking> config option: "${this.config.positionTracking}"`);
            }
            if (this.hasCustom) {
              this.addToken = this.addTokenUsingPush;
              this.handlePayload = this.handlePayloadWithCustom;
            } else {
              this.addToken = this.addTokenUsingMemberAccess;
              this.handlePayload = this.handlePayloadNoCustom;
            }
          });
          this.TRACE_INIT("Failed Optimization Warnings", () => {
            const unOptimizedModes = reduce_default(this.canModeBeOptimized, (cannotBeOptimized, canBeOptimized, modeName) => {
              if (canBeOptimized === false) {
                cannotBeOptimized.push(modeName);
              }
              return cannotBeOptimized;
            }, []);
            if (config.ensureOptimizations && !isEmpty_default(unOptimizedModes)) {
              throw Error(`Lexer Modes: < ${unOptimizedModes.join(", ")} > cannot be optimized.
	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.
	 Or inspect the console log for details on how to resolve these issues.`);
            }
          });
          this.TRACE_INIT("clearRegExpParserCache", () => {
            clearRegExpParserCache();
          });
          this.TRACE_INIT("toFastProperties", () => {
            toFastProperties(this);
          });
        });
      }
      tokenize(text, initialMode = this.defaultMode) {
        if (!isEmpty_default(this.lexerDefinitionErrors)) {
          const allErrMessages = map_default(this.lexerDefinitionErrors, (error) => {
            return error.message;
          });
          const allErrMessagesString = allErrMessages.join("-----------------------\n");
          throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n" + allErrMessagesString);
        }
        return this.tokenizeInternal(text, initialMode);
      }
      // There is quite a bit of duplication between this and "tokenizeInternalLazy"
      // This is intentional due to performance considerations.
      // this method also used quite a bit of `!` none null assertions because it is too optimized
      // for `tsc` to always understand it is "safe"
      tokenizeInternal(text, initialMode) {
        let i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;
        const orgText = text;
        const orgLength = orgText.length;
        let offset = 0;
        let matchedTokensIndex = 0;
        const guessedNumberOfTokens = this.hasCustom ? 0 : Math.floor(text.length / 10);
        const matchedTokens = new Array(guessedNumberOfTokens);
        const errors = [];
        let line = this.trackStartLines ? 1 : void 0;
        let column = this.trackStartLines ? 1 : void 0;
        const groups = cloneEmptyGroups(this.emptyGroups);
        const trackLines = this.trackStartLines;
        const lineTerminatorPattern = this.config.lineTerminatorsPattern;
        let currModePatternsLength = 0;
        let patternIdxToConfig = [];
        let currCharCodeToPatternIdxToConfig = [];
        const modeStack = [];
        const emptyArray = [];
        Object.freeze(emptyArray);
        let getPossiblePatterns;
        function getPossiblePatternsSlow() {
          return patternIdxToConfig;
        }
        function getPossiblePatternsOptimized(charCode) {
          const optimizedCharIdx = charCodeToOptimizedIndex(charCode);
          const possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];
          if (possiblePatterns === void 0) {
            return emptyArray;
          } else {
            return possiblePatterns;
          }
        }
        const pop_mode = (popToken) => {
          if (modeStack.length === 1 && // if we have both a POP_MODE and a PUSH_MODE this is in-fact a "transition"
          // So no error should occur.
          popToken.tokenType.PUSH_MODE === void 0) {
            const msg2 = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);
            errors.push({
              offset: popToken.startOffset,
              line: popToken.startLine,
              column: popToken.startColumn,
              length: popToken.image.length,
              message: msg2
            });
          } else {
            modeStack.pop();
            const newMode = last_default(modeStack);
            patternIdxToConfig = this.patternIdxToConfig[newMode];
            currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];
            currModePatternsLength = patternIdxToConfig.length;
            const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;
            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
              getPossiblePatterns = getPossiblePatternsOptimized;
            } else {
              getPossiblePatterns = getPossiblePatternsSlow;
            }
          }
        };
        function push_mode(newMode) {
          modeStack.push(newMode);
          currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];
          patternIdxToConfig = this.patternIdxToConfig[newMode];
          currModePatternsLength = patternIdxToConfig.length;
          currModePatternsLength = patternIdxToConfig.length;
          const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;
          if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
            getPossiblePatterns = getPossiblePatternsOptimized;
          } else {
            getPossiblePatterns = getPossiblePatternsSlow;
          }
        }
        push_mode.call(this, initialMode);
        let currConfig;
        const recoveryEnabled = this.config.recoveryEnabled;
        while (offset < orgLength) {
          matchedImage = null;
          const nextCharCode = orgText.charCodeAt(offset);
          const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);
          const chosenPatternsLength = chosenPatternIdxToConfig.length;
          for (i = 0; i < chosenPatternsLength; i++) {
            currConfig = chosenPatternIdxToConfig[i];
            const currPattern = currConfig.pattern;
            payload = null;
            const singleCharCode = currConfig.short;
            if (singleCharCode !== false) {
              if (nextCharCode === singleCharCode) {
                matchedImage = currPattern;
              }
            } else if (currConfig.isCustom === true) {
              match = currPattern.exec(orgText, offset, matchedTokens, groups);
              if (match !== null) {
                matchedImage = match[0];
                if (match.payload !== void 0) {
                  payload = match.payload;
                }
              } else {
                matchedImage = null;
              }
            } else {
              this.updateLastIndex(currPattern, offset);
              matchedImage = this.match(currPattern, text, offset);
            }
            if (matchedImage !== null) {
              longerAlt = currConfig.longerAlt;
              if (longerAlt !== void 0) {
                const longerAltLength = longerAlt.length;
                for (k = 0; k < longerAltLength; k++) {
                  const longerAltConfig = patternIdxToConfig[longerAlt[k]];
                  const longerAltPattern = longerAltConfig.pattern;
                  altPayload = null;
                  if (longerAltConfig.isCustom === true) {
                    match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);
                    if (match !== null) {
                      matchAltImage = match[0];
                      if (match.payload !== void 0) {
                        altPayload = match.payload;
                      }
                    } else {
                      matchAltImage = null;
                    }
                  } else {
                    this.updateLastIndex(longerAltPattern, offset);
                    matchAltImage = this.match(longerAltPattern, text, offset);
                  }
                  if (matchAltImage && matchAltImage.length > matchedImage.length) {
                    matchedImage = matchAltImage;
                    payload = altPayload;
                    currConfig = longerAltConfig;
                    break;
                  }
                }
              }
              break;
            }
          }
          if (matchedImage !== null) {
            imageLength = matchedImage.length;
            group = currConfig.group;
            if (group !== void 0) {
              tokType = currConfig.tokenTypeIdx;
              newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);
              this.handlePayload(newToken, payload);
              if (group === false) {
                matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);
              } else {
                groups[group].push(newToken);
              }
            }
            text = this.chopInput(text, imageLength);
            offset = offset + imageLength;
            column = this.computeNewColumn(column, imageLength);
            if (trackLines === true && currConfig.canLineTerminator === true) {
              let numOfLTsInMatch = 0;
              let foundTerminator;
              let lastLTEndOffset;
              lineTerminatorPattern.lastIndex = 0;
              do {
                foundTerminator = lineTerminatorPattern.test(matchedImage);
                if (foundTerminator === true) {
                  lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;
                  numOfLTsInMatch++;
                }
              } while (foundTerminator === true);
              if (numOfLTsInMatch !== 0) {
                line = line + numOfLTsInMatch;
                column = imageLength - lastLTEndOffset;
                this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);
              }
            }
            this.handleModes(currConfig, pop_mode, push_mode, newToken);
          } else {
            const errorStartOffset = offset;
            const errorLine = line;
            const errorColumn = column;
            let foundResyncPoint = recoveryEnabled === false;
            while (foundResyncPoint === false && offset < orgLength) {
              text = this.chopInput(text, 1);
              offset++;
              for (j = 0; j < currModePatternsLength; j++) {
                const currConfig2 = patternIdxToConfig[j];
                const currPattern = currConfig2.pattern;
                const singleCharCode = currConfig2.short;
                if (singleCharCode !== false) {
                  if (orgText.charCodeAt(offset) === singleCharCode) {
                    foundResyncPoint = true;
                  }
                } else if (currConfig2.isCustom === true) {
                  foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;
                } else {
                  this.updateLastIndex(currPattern, offset);
                  foundResyncPoint = currPattern.exec(text) !== null;
                }
                if (foundResyncPoint === true) {
                  break;
                }
              }
            }
            errLength = offset - errorStartOffset;
            column = this.computeNewColumn(column, errLength);
            msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);
            errors.push({
              offset: errorStartOffset,
              line: errorLine,
              column: errorColumn,
              length: errLength,
              message: msg
            });
            if (recoveryEnabled === false) {
              break;
            }
          }
        }
        if (!this.hasCustom) {
          matchedTokens.length = matchedTokensIndex;
        }
        return {
          tokens: matchedTokens,
          groups,
          errors
        };
      }
      handleModes(config, pop_mode, push_mode, newToken) {
        if (config.pop === true) {
          const pushMode = config.push;
          pop_mode(newToken);
          if (pushMode !== void 0) {
            push_mode.call(this, pushMode);
          }
        } else if (config.push !== void 0) {
          push_mode.call(this, config.push);
        }
      }
      chopInput(text, length) {
        return text.substring(length);
      }
      updateLastIndex(regExp, newLastIndex) {
        regExp.lastIndex = newLastIndex;
      }
      // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler
      updateTokenEndLineColumnLocation(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {
        let lastCharIsLT, fixForEndingInLT;
        if (group !== void 0) {
          lastCharIsLT = lastLTIdx === imageLength - 1;
          fixForEndingInLT = lastCharIsLT ? -1 : 0;
          if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {
            newToken.endLine = line + fixForEndingInLT;
            newToken.endColumn = column - 1 + -fixForEndingInLT;
          }
        }
      }
      computeNewColumn(oldColumn, imageLength) {
        return oldColumn + imageLength;
      }
      createOffsetOnlyToken(image, startOffset, tokenTypeIdx, tokenType) {
        return {
          image,
          startOffset,
          tokenTypeIdx,
          tokenType
        };
      }
      createStartOnlyToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {
        return {
          image,
          startOffset,
          startLine,
          startColumn,
          tokenTypeIdx,
          tokenType
        };
      }
      createFullToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {
        return {
          image,
          startOffset,
          endOffset: startOffset + imageLength - 1,
          startLine,
          endLine: startLine,
          startColumn,
          endColumn: startColumn + imageLength - 1,
          tokenTypeIdx,
          tokenType
        };
      }
      addTokenUsingPush(tokenVector, index, tokenToAdd) {
        tokenVector.push(tokenToAdd);
        return index;
      }
      addTokenUsingMemberAccess(tokenVector, index, tokenToAdd) {
        tokenVector[index] = tokenToAdd;
        index++;
        return index;
      }
      handlePayloadNoCustom(token, payload) {
      }
      handlePayloadWithCustom(token, payload) {
        if (payload !== null) {
          token.payload = payload;
        }
      }
      matchWithTest(pattern, text, offset) {
        const found = pattern.test(text);
        if (found === true) {
          return text.substring(offset, pattern.lastIndex);
        }
        return null;
      }
      matchWithExec(pattern, text) {
        const regExpArray = pattern.exec(text);
        return regExpArray !== null ? regExpArray[0] : null;
      }
    };
    Lexer.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";
    Lexer.NA = /NOT_APPLICABLE/;
  }
});

// node_modules/chevrotain/lib/src/scan/tokens_public.js
function tokenLabel2(tokType) {
  if (hasTokenLabel2(tokType)) {
    return tokType.LABEL;
  } else {
    return tokType.name;
  }
}
function hasTokenLabel2(obj) {
  return isString_default(obj.LABEL) && obj.LABEL !== "";
}
function createToken(config) {
  return createTokenInternal(config);
}
function createTokenInternal(config) {
  const pattern = config.pattern;
  const tokenType = {};
  tokenType.name = config.name;
  if (!isUndefined_default(pattern)) {
    tokenType.PATTERN = pattern;
  }
  if (has_default(config, PARENT)) {
    throw "The parent property is no longer supported.\nSee: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.";
  }
  if (has_default(config, CATEGORIES)) {
    tokenType.CATEGORIES = config[CATEGORIES];
  }
  augmentTokenTypes([tokenType]);
  if (has_default(config, LABEL)) {
    tokenType.LABEL = config[LABEL];
  }
  if (has_default(config, GROUP)) {
    tokenType.GROUP = config[GROUP];
  }
  if (has_default(config, POP_MODE)) {
    tokenType.POP_MODE = config[POP_MODE];
  }
  if (has_default(config, PUSH_MODE)) {
    tokenType.PUSH_MODE = config[PUSH_MODE];
  }
  if (has_default(config, LONGER_ALT)) {
    tokenType.LONGER_ALT = config[LONGER_ALT];
  }
  if (has_default(config, LINE_BREAKS)) {
    tokenType.LINE_BREAKS = config[LINE_BREAKS];
  }
  if (has_default(config, START_CHARS_HINT)) {
    tokenType.START_CHARS_HINT = config[START_CHARS_HINT];
  }
  return tokenType;
}
function createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {
  return {
    image,
    startOffset,
    endOffset,
    startLine,
    endLine,
    startColumn,
    endColumn,
    tokenTypeIdx: tokType.tokenTypeIdx,
    tokenType: tokType
  };
}
function tokenMatcher(token, tokType) {
  return tokenStructuredMatcher(token, tokType);
}
var PARENT, CATEGORIES, LABEL, GROUP, PUSH_MODE, POP_MODE, LONGER_ALT, LINE_BREAKS, START_CHARS_HINT, EOF;
var init_tokens_public = __esm({
  "node_modules/chevrotain/lib/src/scan/tokens_public.js"() {
    init_lodash();
    init_lexer_public();
    init_tokens();
    PARENT = "parent";
    CATEGORIES = "categories";
    LABEL = "label";
    GROUP = "group";
    PUSH_MODE = "push_mode";
    POP_MODE = "pop_mode";
    LONGER_ALT = "longer_alt";
    LINE_BREAKS = "line_breaks";
    START_CHARS_HINT = "start_chars_hint";
    EOF = createToken({ name: "EOF", pattern: Lexer.NA });
    augmentTokenTypes([EOF]);
  }
});

// node_modules/chevrotain/lib/src/parse/errors_public.js
var defaultParserErrorProvider, defaultGrammarResolverErrorProvider, defaultGrammarValidatorErrorProvider;
var init_errors_public = __esm({
  "node_modules/chevrotain/lib/src/parse/errors_public.js"() {
    init_tokens_public();
    init_lodash();
    init_api2();
    defaultParserErrorProvider = {
      buildMismatchTokenMessage({ expected, actual, previous, ruleName }) {
        const hasLabel = hasTokenLabel2(expected);
        const expectedMsg = hasLabel ? `--> ${tokenLabel2(expected)} <--` : `token of type --> ${expected.name} <--`;
        const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`;
        return msg;
      },
      buildNotAllInputParsedMessage({ firstRedundant, ruleName }) {
        return "Redundant input, expecting EOF but found: " + firstRedundant.image;
      },
      buildNoViableAltMessage({ expectedPathsPerAlt, actual, previous, customUserDescription, ruleName }) {
        const errPrefix = "Expecting: ";
        const actualText = head_default(actual).image;
        const errSuffix = "\nbut found: '" + actualText + "'";
        if (customUserDescription) {
          return errPrefix + customUserDescription + errSuffix;
        } else {
          const allLookAheadPaths = reduce_default(expectedPathsPerAlt, (result, currAltPaths) => result.concat(currAltPaths), []);
          const nextValidTokenSequences = map_default(allLookAheadPaths, (currPath) => `[${map_default(currPath, (currTokenType) => tokenLabel2(currTokenType)).join(", ")}]`);
          const nextValidSequenceItems = map_default(nextValidTokenSequences, (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`);
          const calculatedDescription = `one of these possible Token sequences:
${nextValidSequenceItems.join("\n")}`;
          return errPrefix + calculatedDescription + errSuffix;
        }
      },
      buildEarlyExitMessage({ expectedIterationPaths, actual, customUserDescription, ruleName }) {
        const errPrefix = "Expecting: ";
        const actualText = head_default(actual).image;
        const errSuffix = "\nbut found: '" + actualText + "'";
        if (customUserDescription) {
          return errPrefix + customUserDescription + errSuffix;
        } else {
          const nextValidTokenSequences = map_default(expectedIterationPaths, (currPath) => `[${map_default(currPath, (currTokenType) => tokenLabel2(currTokenType)).join(",")}]`);
          const calculatedDescription = `expecting at least one iteration which starts with one of these possible Token sequences::
  <${nextValidTokenSequences.join(" ,")}>`;
          return errPrefix + calculatedDescription + errSuffix;
        }
      }
    };
    Object.freeze(defaultParserErrorProvider);
    defaultGrammarResolverErrorProvider = {
      buildRuleNotFoundError(topLevelRule, undefinedRule) {
        const msg = "Invalid grammar, reference to a rule which is not defined: ->" + undefinedRule.nonTerminalName + "<-\ninside top level rule: ->" + topLevelRule.name + "<-";
        return msg;
      }
    };
    defaultGrammarValidatorErrorProvider = {
      buildDuplicateFoundError(topLevelRule, duplicateProds) {
        function getExtraProductionArgument2(prod) {
          if (prod instanceof Terminal) {
            return prod.terminalType.name;
          } else if (prod instanceof NonTerminal) {
            return prod.nonTerminalName;
          } else {
            return "";
          }
        }
        const topLevelName = topLevelRule.name;
        const duplicateProd = head_default(duplicateProds);
        const index = duplicateProd.idx;
        const dslName = getProductionDslName(duplicateProd);
        const extraArgument = getExtraProductionArgument2(duplicateProd);
        const hasExplicitIndex = index > 0;
        let msg = `->${dslName}${hasExplicitIndex ? index : ""}<- ${extraArgument ? `with argument: ->${extraArgument}<-` : ""}
                  appears more than once (${duplicateProds.length} times) in the top level rule: ->${topLevelName}<-.                  
                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES 
                  `;
        msg = msg.replace(/[ \t]+/g, " ");
        msg = msg.replace(/\s\s+/g, "\n");
        return msg;
      },
      buildNamespaceConflictError(rule) {
        const errMsg = `Namespace conflict found in grammar.
The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.
To resolve this make sure each Terminal and Non-Terminal names are unique
This is easy to accomplish by using the convention that Terminal names start with an uppercase letter
and Non-Terminal names start with a lower case letter.`;
        return errMsg;
      },
      buildAlternationPrefixAmbiguityError(options) {
        const pathMsg = map_default(options.prefixPath, (currTok) => tokenLabel2(currTok)).join(", ");
        const occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
        const errMsg = `Ambiguous alternatives: <${options.ambiguityIndices.join(" ,")}> due to common lookahead prefix
in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,
<${pathMsg}> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX
For Further details.`;
        return errMsg;
      },
      buildAlternationAmbiguityError(options) {
        const pathMsg = map_default(options.prefixPath, (currtok) => tokenLabel2(currtok)).join(", ");
        const occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
        let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(" ,")}> in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,
<${pathMsg}> may appears as a prefix path in all these alternatives.
`;
        currMessage = currMessage + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`;
        return currMessage;
      },
      buildEmptyRepetitionError(options) {
        let dslName = getProductionDslName(options.repetition);
        if (options.repetition.idx !== 0) {
          dslName += options.repetition.idx;
        }
        const errMsg = `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.
This could lead to an infinite loop.`;
        return errMsg;
      },
      // TODO: remove - `errors_public` from nyc.config.js exclude
      //       once this method is fully removed from this file
      buildTokenNameError(options) {
        return "deprecated";
      },
      buildEmptyAlternationError(options) {
        const errMsg = `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}> in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.
Only the last alternative may be an empty alternative.`;
        return errMsg;
      },
      buildTooManyAlternativesError(options) {
        const errMsg = `An Alternation cannot have more than 256 alternatives:
<OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.
 has ${options.alternation.definition.length + 1} alternatives.`;
        return errMsg;
      },
      buildLeftRecursionError(options) {
        const ruleName = options.topLevelRule.name;
        const pathNames = map_default(options.leftRecursionPath, (currRule) => currRule.name);
        const leftRecursivePath = `${ruleName} --> ${pathNames.concat([ruleName]).join(" --> ")}`;
        const errMsg = `Left Recursion found in grammar.
rule: <${ruleName}> can be invoked from itself (directly or indirectly)
without consuming any Tokens. The grammar path that causes this is: 
 ${leftRecursivePath}
 To fix this refactor your grammar to remove the left recursion.
see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;
        return errMsg;
      },
      // TODO: remove - `errors_public` from nyc.config.js exclude
      //       once this method is fully removed from this file
      buildInvalidRuleNameError(options) {
        return "deprecated";
      },
      buildDuplicateRuleNameError(options) {
        let ruleName;
        if (options.topLevelRule instanceof Rule) {
          ruleName = options.topLevelRule.name;
        } else {
          ruleName = options.topLevelRule;
        }
        const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`;
        return errMsg;
      }
    };
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/resolver.js
function resolveGrammar(topLevels, errMsgProvider) {
  const refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);
  refResolver.resolveRefs();
  return refResolver.errors;
}
var GastRefResolverVisitor;
var init_resolver = __esm({
  "node_modules/chevrotain/lib/src/parse/grammar/resolver.js"() {
    init_parser();
    init_lodash();
    init_api2();
    GastRefResolverVisitor = class extends GAstVisitor {
      constructor(nameToTopRule, errMsgProvider) {
        super();
        this.nameToTopRule = nameToTopRule;
        this.errMsgProvider = errMsgProvider;
        this.errors = [];
      }
      resolveRefs() {
        forEach_default(values_default(this.nameToTopRule), (prod) => {
          this.currTopLevel = prod;
          prod.accept(this);
        });
      }
      visitNonTerminal(node) {
        const ref = this.nameToTopRule[node.nonTerminalName];
        if (!ref) {
          const msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);
          this.errors.push({
            message: msg,
            type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,
            ruleName: this.currTopLevel.name,
            unresolvedRefName: node.nonTerminalName
          });
        } else {
          node.referencedRule = ref;
        }
      }
    };
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/interpreter.js
function possiblePathsFrom(targetDef, maxLength, currPath = []) {
  currPath = clone_default(currPath);
  let result = [];
  let i = 0;
  function remainingPathWith(nextDef) {
    return nextDef.concat(drop_default(targetDef, i + 1));
  }
  function getAlternativesForProd(definition) {
    const alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);
    return result.concat(alternatives);
  }
  while (currPath.length < maxLength && i < targetDef.length) {
    const prod = targetDef[i];
    if (prod instanceof Alternative) {
      return getAlternativesForProd(prod.definition);
    } else if (prod instanceof NonTerminal) {
      return getAlternativesForProd(prod.definition);
    } else if (prod instanceof Option) {
      result = getAlternativesForProd(prod.definition);
    } else if (prod instanceof RepetitionMandatory) {
      const newDef = prod.definition.concat([
        new Repetition({
          definition: prod.definition
        })
      ]);
      return getAlternativesForProd(newDef);
    } else if (prod instanceof RepetitionMandatoryWithSeparator) {
      const newDef = [
        new Alternative({ definition: prod.definition }),
        new Repetition({
          definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition)
        })
      ];
      return getAlternativesForProd(newDef);
    } else if (prod instanceof RepetitionWithSeparator) {
      const newDef = prod.definition.concat([
        new Repetition({
          definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition)
        })
      ]);
      result = getAlternativesForProd(newDef);
    } else if (prod instanceof Repetition) {
      const newDef = prod.definition.concat([
        new Repetition({
          definition: prod.definition
        })
      ]);
      result = getAlternativesForProd(newDef);
    } else if (prod instanceof Alternation) {
      forEach_default(prod.definition, (currAlt) => {
        if (isEmpty_default(currAlt.definition) === false) {
          result = getAlternativesForProd(currAlt.definition);
        }
      });
      return result;
    } else if (prod instanceof Terminal) {
      currPath.push(prod.terminalType);
    } else {
      throw Error("non exhaustive match");
    }
    i++;
  }
  result.push({
    partialPath: currPath,
    suffixDef: drop_default(targetDef, i)
  });
  return result;
}
function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {
  const EXIT_NON_TERMINAL = "EXIT_NONE_TERMINAL";
  const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];
  const EXIT_ALTERNATIVE = "EXIT_ALTERNATIVE";
  let foundCompletePath = false;
  const tokenVectorLength = tokenVector.length;
  const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;
  const result = [];
  const possiblePaths = [];
  possiblePaths.push({
    idx: -1,
    def: initialDef,
    ruleStack: [],
    occurrenceStack: []
  });
  while (!isEmpty_default(possiblePaths)) {
    const currPath = possiblePaths.pop();
    if (currPath === EXIT_ALTERNATIVE) {
      if (foundCompletePath && last_default(possiblePaths).idx <= minimalAlternativesIndex) {
        possiblePaths.pop();
      }
      continue;
    }
    const currDef = currPath.def;
    const currIdx = currPath.idx;
    const currRuleStack = currPath.ruleStack;
    const currOccurrenceStack = currPath.occurrenceStack;
    if (isEmpty_default(currDef)) {
      continue;
    }
    const prod = currDef[0];
    if (prod === EXIT_NON_TERMINAL) {
      const nextPath = {
        idx: currIdx,
        def: drop_default(currDef),
        ruleStack: dropRight_default(currRuleStack),
        occurrenceStack: dropRight_default(currOccurrenceStack)
      };
      possiblePaths.push(nextPath);
    } else if (prod instanceof Terminal) {
      if (currIdx < tokenVectorLength - 1) {
        const nextIdx = currIdx + 1;
        const actualToken = tokenVector[nextIdx];
        if (tokMatcher(actualToken, prod.terminalType)) {
          const nextPath = {
            idx: nextIdx,
            def: drop_default(currDef),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPath);
        }
      } else if (currIdx === tokenVectorLength - 1) {
        result.push({
          nextTokenType: prod.terminalType,
          nextTokenOccurrence: prod.idx,
          ruleStack: currRuleStack,
          occurrenceStack: currOccurrenceStack
        });
        foundCompletePath = true;
      } else {
        throw Error("non exhaustive match");
      }
    } else if (prod instanceof NonTerminal) {
      const newRuleStack = clone_default(currRuleStack);
      newRuleStack.push(prod.nonTerminalName);
      const newOccurrenceStack = clone_default(currOccurrenceStack);
      newOccurrenceStack.push(prod.idx);
      const nextPath = {
        idx: currIdx,
        def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop_default(currDef)),
        ruleStack: newRuleStack,
        occurrenceStack: newOccurrenceStack
      };
      possiblePaths.push(nextPath);
    } else if (prod instanceof Option) {
      const nextPathWithout = {
        idx: currIdx,
        def: drop_default(currDef),
        ruleStack: currRuleStack,
        occurrenceStack: currOccurrenceStack
      };
      possiblePaths.push(nextPathWithout);
      possiblePaths.push(EXIT_ALTERNATIVE);
      const nextPathWith = {
        idx: currIdx,
        def: prod.definition.concat(drop_default(currDef)),
        ruleStack: currRuleStack,
        occurrenceStack: currOccurrenceStack
      };
      possiblePaths.push(nextPathWith);
    } else if (prod instanceof RepetitionMandatory) {
      const secondIteration = new Repetition({
        definition: prod.definition,
        idx: prod.idx
      });
      const nextDef = prod.definition.concat([secondIteration], drop_default(currDef));
      const nextPath = {
        idx: currIdx,
        def: nextDef,
        ruleStack: currRuleStack,
        occurrenceStack: currOccurrenceStack
      };
      possiblePaths.push(nextPath);
    } else if (prod instanceof RepetitionMandatoryWithSeparator) {
      const separatorGast = new Terminal({
        terminalType: prod.separator
      });
      const secondIteration = new Repetition({
        definition: [separatorGast].concat(prod.definition),
        idx: prod.idx
      });
      const nextDef = prod.definition.concat([secondIteration], drop_default(currDef));
      const nextPath = {
        idx: currIdx,
        def: nextDef,
        ruleStack: currRuleStack,
        occurrenceStack: currOccurrenceStack
      };
      possiblePaths.push(nextPath);
    } else if (prod instanceof RepetitionWithSeparator) {
      const nextPathWithout = {
        idx: currIdx,
        def: drop_default(currDef),
        ruleStack: currRuleStack,
        occurrenceStack: currOccurrenceStack
      };
      possiblePaths.push(nextPathWithout);
      possiblePaths.push(EXIT_ALTERNATIVE);
      const separatorGast = new Terminal({
        terminalType: prod.separator
      });
      const nthRepetition = new Repetition({
        definition: [separatorGast].concat(prod.definition),
        idx: prod.idx
      });
      const nextDef = prod.definition.concat([nthRepetition], drop_default(currDef));
      const nextPathWith = {
        idx: currIdx,
        def: nextDef,
        ruleStack: currRuleStack,
        occurrenceStack: currOccurrenceStack
      };
      possiblePaths.push(nextPathWith);
    } else if (prod instanceof Repetition) {
      const nextPathWithout = {
        idx: currIdx,
        def: drop_default(currDef),
        ruleStack: currRuleStack,
        occurrenceStack: currOccurrenceStack
      };
      possiblePaths.push(nextPathWithout);
      possiblePaths.push(EXIT_ALTERNATIVE);
      const nthRepetition = new Repetition({
        definition: prod.definition,
        idx: prod.idx
      });
      const nextDef = prod.definition.concat([nthRepetition], drop_default(currDef));
      const nextPathWith = {
        idx: currIdx,
        def: nextDef,
        ruleStack: currRuleStack,
        occurrenceStack: currOccurrenceStack
      };
      possiblePaths.push(nextPathWith);
    } else if (prod instanceof Alternation) {
      for (let i = prod.definition.length - 1; i >= 0; i--) {
        const currAlt = prod.definition[i];
        const currAltPath = {
          idx: currIdx,
          def: currAlt.definition.concat(drop_default(currDef)),
          ruleStack: currRuleStack,
          occurrenceStack: currOccurrenceStack
        };
        possiblePaths.push(currAltPath);
        possiblePaths.push(EXIT_ALTERNATIVE);
      }
    } else if (prod instanceof Alternative) {
      possiblePaths.push({
        idx: currIdx,
        def: prod.definition.concat(drop_default(currDef)),
        ruleStack: currRuleStack,
        occurrenceStack: currOccurrenceStack
      });
    } else if (prod instanceof Rule) {
      possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));
    } else {
      throw Error("non exhaustive match");
    }
  }
  return result;
}
function expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {
  const newRuleStack = clone_default(currRuleStack);
  newRuleStack.push(topRule.name);
  const newCurrOccurrenceStack = clone_default(currOccurrenceStack);
  newCurrOccurrenceStack.push(1);
  return {
    idx: currIdx,
    def: topRule.definition,
    ruleStack: newRuleStack,
    occurrenceStack: newCurrOccurrenceStack
  };
}
var AbstractNextPossibleTokensWalker, NextAfterTokenWalker, AbstractNextTerminalAfterProductionWalker, NextTerminalAfterManyWalker, NextTerminalAfterManySepWalker, NextTerminalAfterAtLeastOneWalker, NextTerminalAfterAtLeastOneSepWalker;
var init_interpreter = __esm({
  "node_modules/chevrotain/lib/src/parse/grammar/interpreter.js"() {
    init_lodash();
    init_first2();
    init_rest();
    init_api2();
    AbstractNextPossibleTokensWalker = class extends RestWalker {
      constructor(topProd, path4) {
        super();
        this.topProd = topProd;
        this.path = path4;
        this.possibleTokTypes = [];
        this.nextProductionName = "";
        this.nextProductionOccurrence = 0;
        this.found = false;
        this.isAtEndOfPath = false;
      }
      startWalking() {
        this.found = false;
        if (this.path.ruleStack[0] !== this.topProd.name) {
          throw Error("The path does not start with the walker's top Rule!");
        }
        this.ruleStack = clone_default(this.path.ruleStack).reverse();
        this.occurrenceStack = clone_default(this.path.occurrenceStack).reverse();
        this.ruleStack.pop();
        this.occurrenceStack.pop();
        this.updateExpectedNext();
        this.walk(this.topProd);
        return this.possibleTokTypes;
      }
      walk(prod, prevRest = []) {
        if (!this.found) {
          super.walk(prod, prevRest);
        }
      }
      walkProdRef(refProd, currRest, prevRest) {
        if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {
          const fullRest = currRest.concat(prevRest);
          this.updateExpectedNext();
          this.walk(refProd.referencedRule, fullRest);
        }
      }
      updateExpectedNext() {
        if (isEmpty_default(this.ruleStack)) {
          this.nextProductionName = "";
          this.nextProductionOccurrence = 0;
          this.isAtEndOfPath = true;
        } else {
          this.nextProductionName = this.ruleStack.pop();
          this.nextProductionOccurrence = this.occurrenceStack.pop();
        }
      }
    };
    NextAfterTokenWalker = class extends AbstractNextPossibleTokensWalker {
      constructor(topProd, path4) {
        super(topProd, path4);
        this.path = path4;
        this.nextTerminalName = "";
        this.nextTerminalOccurrence = 0;
        this.nextTerminalName = this.path.lastTok.name;
        this.nextTerminalOccurrence = this.path.lastTokOccurrence;
      }
      walkTerminal(terminal, currRest, prevRest) {
        if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {
          const fullRest = currRest.concat(prevRest);
          const restProd = new Alternative({ definition: fullRest });
          this.possibleTokTypes = first(restProd);
          this.found = true;
        }
      }
    };
    AbstractNextTerminalAfterProductionWalker = class extends RestWalker {
      constructor(topRule, occurrence) {
        super();
        this.topRule = topRule;
        this.occurrence = occurrence;
        this.result = {
          token: void 0,
          occurrence: void 0,
          isEndOfRule: void 0
        };
      }
      startWalking() {
        this.walk(this.topRule);
        return this.result;
      }
    };
    NextTerminalAfterManyWalker = class extends AbstractNextTerminalAfterProductionWalker {
      walkMany(manyProd, currRest, prevRest) {
        if (manyProd.idx === this.occurrence) {
          const firstAfterMany = head_default(currRest.concat(prevRest));
          this.result.isEndOfRule = firstAfterMany === void 0;
          if (firstAfterMany instanceof Terminal) {
            this.result.token = firstAfterMany.terminalType;
            this.result.occurrence = firstAfterMany.idx;
          }
        } else {
          super.walkMany(manyProd, currRest, prevRest);
        }
      }
    };
    NextTerminalAfterManySepWalker = class extends AbstractNextTerminalAfterProductionWalker {
      walkManySep(manySepProd, currRest, prevRest) {
        if (manySepProd.idx === this.occurrence) {
          const firstAfterManySep = head_default(currRest.concat(prevRest));
          this.result.isEndOfRule = firstAfterManySep === void 0;
          if (firstAfterManySep instanceof Terminal) {
            this.result.token = firstAfterManySep.terminalType;
            this.result.occurrence = firstAfterManySep.idx;
          }
        } else {
          super.walkManySep(manySepProd, currRest, prevRest);
        }
      }
    };
    NextTerminalAfterAtLeastOneWalker = class extends AbstractNextTerminalAfterProductionWalker {
      walkAtLeastOne(atLeastOneProd, currRest, prevRest) {
        if (atLeastOneProd.idx === this.occurrence) {
          const firstAfterAtLeastOne = head_default(currRest.concat(prevRest));
          this.result.isEndOfRule = firstAfterAtLeastOne === void 0;
          if (firstAfterAtLeastOne instanceof Terminal) {
            this.result.token = firstAfterAtLeastOne.terminalType;
            this.result.occurrence = firstAfterAtLeastOne.idx;
          }
        } else {
          super.walkAtLeastOne(atLeastOneProd, currRest, prevRest);
        }
      }
    };
    NextTerminalAfterAtLeastOneSepWalker = class extends AbstractNextTerminalAfterProductionWalker {
      walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest) {
        if (atleastOneSepProd.idx === this.occurrence) {
          const firstAfterfirstAfterAtLeastOneSep = head_default(currRest.concat(prevRest));
          this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === void 0;
          if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {
            this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;
            this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;
          }
        } else {
          super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest);
        }
      }
    };
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/lookahead.js
function getProdType(prod) {
  if (prod instanceof Option || prod === "Option") {
    return PROD_TYPE.OPTION;
  } else if (prod instanceof Repetition || prod === "Repetition") {
    return PROD_TYPE.REPETITION;
  } else if (prod instanceof RepetitionMandatory || prod === "RepetitionMandatory") {
    return PROD_TYPE.REPETITION_MANDATORY;
  } else if (prod instanceof RepetitionMandatoryWithSeparator || prod === "RepetitionMandatoryWithSeparator") {
    return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;
  } else if (prod instanceof RepetitionWithSeparator || prod === "RepetitionWithSeparator") {
    return PROD_TYPE.REPETITION_WITH_SEPARATOR;
  } else if (prod instanceof Alternation || prod === "Alternation") {
    return PROD_TYPE.ALTERNATION;
  } else {
    throw Error("non exhaustive match");
  }
}
function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {
  const lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);
  const tokenMatcher2 = areTokenCategoriesNotUsed(lookAheadPaths) ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;
  return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher2, dynamicTokensEnabled);
}
function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {
  const lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);
  const tokenMatcher2 = areTokenCategoriesNotUsed(lookAheadPaths) ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;
  return lookaheadBuilder(lookAheadPaths[0], tokenMatcher2, dynamicTokensEnabled);
}
function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher2, dynamicTokensEnabled) {
  const numOfAlts = alts.length;
  const areAllOneTokenLookahead = every_default(alts, (currAlt) => {
    return every_default(currAlt, (currPath) => {
      return currPath.length === 1;
    });
  });
  if (hasPredicates) {
    return function(orAlts) {
      const predicates = map_default(orAlts, (currAlt) => currAlt.GATE);
      for (let t = 0; t < numOfAlts; t++) {
        const currAlt = alts[t];
        const currNumOfPaths = currAlt.length;
        const currPredicate = predicates[t];
        if (currPredicate !== void 0 && currPredicate.call(this) === false) {
          continue;
        }
        nextPath:
          for (let j = 0; j < currNumOfPaths; j++) {
            const currPath = currAlt[j];
            const currPathLength = currPath.length;
            for (let i = 0; i < currPathLength; i++) {
              const nextToken = this.LA(i + 1);
              if (tokenMatcher2(nextToken, currPath[i]) === false) {
                continue nextPath;
              }
            }
            return t;
          }
      }
      return void 0;
    };
  } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
    const singleTokenAlts = map_default(alts, (currAlt) => {
      return flatten_default(currAlt);
    });
    const choiceToAlt = reduce_default(singleTokenAlts, (result, currAlt, idx) => {
      forEach_default(currAlt, (currTokType) => {
        if (!has_default(result, currTokType.tokenTypeIdx)) {
          result[currTokType.tokenTypeIdx] = idx;
        }
        forEach_default(currTokType.categoryMatches, (currExtendingType) => {
          if (!has_default(result, currExtendingType)) {
            result[currExtendingType] = idx;
          }
        });
      });
      return result;
    }, {});
    return function() {
      const nextToken = this.LA(1);
      return choiceToAlt[nextToken.tokenTypeIdx];
    };
  } else {
    return function() {
      for (let t = 0; t < numOfAlts; t++) {
        const currAlt = alts[t];
        const currNumOfPaths = currAlt.length;
        nextPath:
          for (let j = 0; j < currNumOfPaths; j++) {
            const currPath = currAlt[j];
            const currPathLength = currPath.length;
            for (let i = 0; i < currPathLength; i++) {
              const nextToken = this.LA(i + 1);
              if (tokenMatcher2(nextToken, currPath[i]) === false) {
                continue nextPath;
              }
            }
            return t;
          }
      }
      return void 0;
    };
  }
}
function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher2, dynamicTokensEnabled) {
  const areAllOneTokenLookahead = every_default(alt, (currPath) => {
    return currPath.length === 1;
  });
  const numOfPaths = alt.length;
  if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
    const singleTokensTypes = flatten_default(alt);
    if (singleTokensTypes.length === 1 && isEmpty_default(singleTokensTypes[0].categoryMatches)) {
      const expectedTokenType = singleTokensTypes[0];
      const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;
      return function() {
        return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;
      };
    } else {
      const choiceToAlt = reduce_default(singleTokensTypes, (result, currTokType, idx) => {
        result[currTokType.tokenTypeIdx] = true;
        forEach_default(currTokType.categoryMatches, (currExtendingType) => {
          result[currExtendingType] = true;
        });
        return result;
      }, []);
      return function() {
        const nextToken = this.LA(1);
        return choiceToAlt[nextToken.tokenTypeIdx] === true;
      };
    }
  } else {
    return function() {
      nextPath:
        for (let j = 0; j < numOfPaths; j++) {
          const currPath = alt[j];
          const currPathLength = currPath.length;
          for (let i = 0; i < currPathLength; i++) {
            const nextToken = this.LA(i + 1);
            if (tokenMatcher2(nextToken, currPath[i]) === false) {
              continue nextPath;
            }
          }
          return true;
        }
      return false;
    };
  }
}
function initializeArrayOfArrays(size) {
  const result = new Array(size);
  for (let i = 0; i < size; i++) {
    result[i] = [];
  }
  return result;
}
function pathToHashKeys(path4) {
  let keys2 = [""];
  for (let i = 0; i < path4.length; i++) {
    const tokType = path4[i];
    const longerKeys = [];
    for (let j = 0; j < keys2.length; j++) {
      const currShorterKey = keys2[j];
      longerKeys.push(currShorterKey + "_" + tokType.tokenTypeIdx);
      for (let t = 0; t < tokType.categoryMatches.length; t++) {
        const categoriesKeySuffix = "_" + tokType.categoryMatches[t];
        longerKeys.push(currShorterKey + categoriesKeySuffix);
      }
    }
    keys2 = longerKeys;
  }
  return keys2;
}
function isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {
  for (let currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {
    if (currAltIdx === idx) {
      continue;
    }
    const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];
    for (let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {
      const searchKey = searchPathKeys[searchIdx];
      if (otherAltKnownPathsKeys[searchKey] === true) {
        return false;
      }
    }
  }
  return true;
}
function lookAheadSequenceFromAlternatives(altsDefs, k) {
  const partialAlts = map_default(altsDefs, (currAlt) => possiblePathsFrom([currAlt], 1));
  const finalResult = initializeArrayOfArrays(partialAlts.length);
  const altsHashes = map_default(partialAlts, (currAltPaths) => {
    const dict = {};
    forEach_default(currAltPaths, (item) => {
      const keys2 = pathToHashKeys(item.partialPath);
      forEach_default(keys2, (currKey) => {
        dict[currKey] = true;
      });
    });
    return dict;
  });
  let newData = partialAlts;
  for (let pathLength = 1; pathLength <= k; pathLength++) {
    const currDataset = newData;
    newData = initializeArrayOfArrays(currDataset.length);
    for (let altIdx = 0; altIdx < currDataset.length; altIdx++) {
      const currAltPathsAndSuffixes = currDataset[altIdx];
      for (let currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {
        const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;
        const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;
        const prefixKeys = pathToHashKeys(currPathPrefix);
        const isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);
        if (isUnique || isEmpty_default(suffixDef) || currPathPrefix.length === k) {
          const currAltResult = finalResult[altIdx];
          if (containsPath(currAltResult, currPathPrefix) === false) {
            currAltResult.push(currPathPrefix);
            for (let j = 0; j < prefixKeys.length; j++) {
              const currKey = prefixKeys[j];
              altsHashes[altIdx][currKey] = true;
            }
          }
        } else {
          const newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);
          newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);
          forEach_default(newPartialPathsAndSuffixes, (item) => {
            const prefixKeys2 = pathToHashKeys(item.partialPath);
            forEach_default(prefixKeys2, (key) => {
              altsHashes[altIdx][key] = true;
            });
          });
        }
      }
    }
  }
  return finalResult;
}
function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {
  const visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);
  ruleGrammar.accept(visitor);
  return lookAheadSequenceFromAlternatives(visitor.result, k);
}
function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {
  const insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);
  ruleGrammar.accept(insideDefVisitor);
  const insideDef = insideDefVisitor.result;
  const afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);
  const afterDef = afterDefWalker.startWalking();
  const insideFlat = new Alternative({ definition: insideDef });
  const afterFlat = new Alternative({ definition: afterDef });
  return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);
}
function containsPath(alternative, searchPath) {
  compareOtherPath:
    for (let i = 0; i < alternative.length; i++) {
      const otherPath = alternative[i];
      if (otherPath.length !== searchPath.length) {
        continue;
      }
      for (let j = 0; j < otherPath.length; j++) {
        const searchTok = searchPath[j];
        const otherTok = otherPath[j];
        const matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== void 0;
        if (matchingTokens === false) {
          continue compareOtherPath;
        }
      }
      return true;
    }
  return false;
}
function isStrictPrefixOfPath(prefix, other) {
  return prefix.length < other.length && every_default(prefix, (tokType, idx) => {
    const otherTokType = other[idx];
    return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];
  });
}
function areTokenCategoriesNotUsed(lookAheadPaths) {
  return every_default(lookAheadPaths, (singleAltPaths) => every_default(singleAltPaths, (singlePath) => every_default(singlePath, (token) => isEmpty_default(token.categoryMatches))));
}
var PROD_TYPE, RestDefinitionFinderWalker, InsideDefinitionFinderVisitor;
var init_lookahead = __esm({
  "node_modules/chevrotain/lib/src/parse/grammar/lookahead.js"() {
    init_lodash();
    init_interpreter();
    init_rest();
    init_tokens();
    init_api2();
    (function(PROD_TYPE2) {
      PROD_TYPE2[PROD_TYPE2["OPTION"] = 0] = "OPTION";
      PROD_TYPE2[PROD_TYPE2["REPETITION"] = 1] = "REPETITION";
      PROD_TYPE2[PROD_TYPE2["REPETITION_MANDATORY"] = 2] = "REPETITION_MANDATORY";
      PROD_TYPE2[PROD_TYPE2["REPETITION_MANDATORY_WITH_SEPARATOR"] = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR";
      PROD_TYPE2[PROD_TYPE2["REPETITION_WITH_SEPARATOR"] = 4] = "REPETITION_WITH_SEPARATOR";
      PROD_TYPE2[PROD_TYPE2["ALTERNATION"] = 5] = "ALTERNATION";
    })(PROD_TYPE || (PROD_TYPE = {}));
    RestDefinitionFinderWalker = class extends RestWalker {
      constructor(topProd, targetOccurrence, targetProdType) {
        super();
        this.topProd = topProd;
        this.targetOccurrence = targetOccurrence;
        this.targetProdType = targetProdType;
      }
      startWalking() {
        this.walk(this.topProd);
        return this.restDef;
      }
      checkIsTarget(node, expectedProdType, currRest, prevRest) {
        if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {
          this.restDef = currRest.concat(prevRest);
          return true;
        }
        return false;
      }
      walkOption(optionProd, currRest, prevRest) {
        if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {
          super.walkOption(optionProd, currRest, prevRest);
        }
      }
      walkAtLeastOne(atLeastOneProd, currRest, prevRest) {
        if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {
          super.walkOption(atLeastOneProd, currRest, prevRest);
        }
      }
      walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {
        if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {
          super.walkOption(atLeastOneSepProd, currRest, prevRest);
        }
      }
      walkMany(manyProd, currRest, prevRest) {
        if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {
          super.walkOption(manyProd, currRest, prevRest);
        }
      }
      walkManySep(manySepProd, currRest, prevRest) {
        if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {
          super.walkOption(manySepProd, currRest, prevRest);
        }
      }
    };
    InsideDefinitionFinderVisitor = class extends GAstVisitor {
      constructor(targetOccurrence, targetProdType, targetRef) {
        super();
        this.targetOccurrence = targetOccurrence;
        this.targetProdType = targetProdType;
        this.targetRef = targetRef;
        this.result = [];
      }
      checkIsTarget(node, expectedProdName) {
        if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === void 0 || node === this.targetRef)) {
          this.result = node.definition;
        }
      }
      visitOption(node) {
        this.checkIsTarget(node, PROD_TYPE.OPTION);
      }
      visitRepetition(node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION);
      }
      visitRepetitionMandatory(node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);
      }
      visitRepetitionMandatoryWithSeparator(node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);
      }
      visitRepetitionWithSeparator(node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);
      }
      visitAlternation(node) {
        this.checkIsTarget(node, PROD_TYPE.ALTERNATION);
      }
    };
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/checks.js
function validateLookahead(options) {
  const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({
    rules: options.rules,
    tokenTypes: options.tokenTypes,
    grammarName: options.grammarName
  });
  return map_default(lookaheadValidationErrorMessages, (errorMessage) => Object.assign({ type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, errorMessage));
}
function validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {
  const duplicateErrors = flatMap_default(topLevels, (currTopLevel) => validateDuplicateProductions(currTopLevel, errMsgProvider));
  const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);
  const tooManyAltsErrors = flatMap_default(topLevels, (curRule) => validateTooManyAlts(curRule, errMsgProvider));
  const duplicateRulesError = flatMap_default(topLevels, (curRule) => validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider));
  return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);
}
function validateDuplicateProductions(topLevelRule, errMsgProvider) {
  const collectorVisitor2 = new OccurrenceValidationCollector();
  topLevelRule.accept(collectorVisitor2);
  const allRuleProductions = collectorVisitor2.allProductions;
  const productionGroups = groupBy_default(allRuleProductions, identifyProductionForDuplicates);
  const duplicates = pickBy_default(productionGroups, (currGroup) => {
    return currGroup.length > 1;
  });
  const errors = map_default(values_default(duplicates), (currDuplicates) => {
    const firstProd = head_default(currDuplicates);
    const msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);
    const dslName = getProductionDslName(firstProd);
    const defError = {
      message: msg,
      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,
      ruleName: topLevelRule.name,
      dslName,
      occurrence: firstProd.idx
    };
    const param = getExtraProductionArgument(firstProd);
    if (param) {
      defError.parameter = param;
    }
    return defError;
  });
  return errors;
}
function identifyProductionForDuplicates(prod) {
  return `${getProductionDslName(prod)}_#_${prod.idx}_#_${getExtraProductionArgument(prod)}`;
}
function getExtraProductionArgument(prod) {
  if (prod instanceof Terminal) {
    return prod.terminalType.name;
  } else if (prod instanceof NonTerminal) {
    return prod.nonTerminalName;
  } else {
    return "";
  }
}
function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {
  const errors = [];
  const occurrences = reduce_default(allRules, (result, curRule) => {
    if (curRule.name === rule.name) {
      return result + 1;
    }
    return result;
  }, 0);
  if (occurrences > 1) {
    const errMsg = errMsgProvider.buildDuplicateRuleNameError({
      topLevelRule: rule,
      grammarName: className
    });
    errors.push({
      message: errMsg,
      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
      ruleName: rule.name
    });
  }
  return errors;
}
function validateRuleIsOverridden(ruleName, definedRulesNames, className) {
  const errors = [];
  let errMsg;
  if (!includes_default(definedRulesNames, ruleName)) {
    errMsg = `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-as it is not defined in any of the super grammars `;
    errors.push({
      message: errMsg,
      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,
      ruleName
    });
  }
  return errors;
}
function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path4 = []) {
  const errors = [];
  const nextNonTerminals = getFirstNoneTerminal(currRule.definition);
  if (isEmpty_default(nextNonTerminals)) {
    return [];
  } else {
    const ruleName = topRule.name;
    const foundLeftRecursion = includes_default(nextNonTerminals, topRule);
    if (foundLeftRecursion) {
      errors.push({
        message: errMsgProvider.buildLeftRecursionError({
          topLevelRule: topRule,
          leftRecursionPath: path4
        }),
        type: ParserDefinitionErrorType.LEFT_RECURSION,
        ruleName
      });
    }
    const validNextSteps = difference_default(nextNonTerminals, path4.concat([topRule]));
    const errorsFromNextSteps = flatMap_default(validNextSteps, (currRefRule) => {
      const newPath = clone_default(path4);
      newPath.push(currRefRule);
      return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);
    });
    return errors.concat(errorsFromNextSteps);
  }
}
function getFirstNoneTerminal(definition) {
  let result = [];
  if (isEmpty_default(definition)) {
    return result;
  }
  const firstProd = head_default(definition);
  if (firstProd instanceof NonTerminal) {
    result.push(firstProd.referencedRule);
  } else if (firstProd instanceof Alternative || firstProd instanceof Option || firstProd instanceof RepetitionMandatory || firstProd instanceof RepetitionMandatoryWithSeparator || firstProd instanceof RepetitionWithSeparator || firstProd instanceof Repetition) {
    result = result.concat(getFirstNoneTerminal(firstProd.definition));
  } else if (firstProd instanceof Alternation) {
    result = flatten_default(map_default(firstProd.definition, (currSubDef) => getFirstNoneTerminal(currSubDef.definition)));
  } else if (firstProd instanceof Terminal) {
  } else {
    throw Error("non exhaustive match");
  }
  const isFirstOptional = isOptionalProd(firstProd);
  const hasMore = definition.length > 1;
  if (isFirstOptional && hasMore) {
    const rest = drop_default(definition);
    return result.concat(getFirstNoneTerminal(rest));
  } else {
    return result;
  }
}
function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {
  const orCollector = new OrCollector();
  topLevelRule.accept(orCollector);
  const ors = orCollector.alternations;
  const errors = flatMap_default(ors, (currOr) => {
    const exceptLast = dropRight_default(currOr.definition);
    return flatMap_default(exceptLast, (currAlternative, currAltIdx) => {
      const possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], tokenStructuredMatcher, 1);
      if (isEmpty_default(possibleFirstInAlt)) {
        return [
          {
            message: errMsgProvider.buildEmptyAlternationError({
              topLevelRule,
              alternation: currOr,
              emptyChoiceIdx: currAltIdx
            }),
            type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,
            ruleName: topLevelRule.name,
            occurrence: currOr.idx,
            alternative: currAltIdx + 1
          }
        ];
      } else {
        return [];
      }
    });
  });
  return errors;
}
function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {
  const orCollector = new OrCollector();
  topLevelRule.accept(orCollector);
  let ors = orCollector.alternations;
  ors = reject_default(ors, (currOr) => currOr.ignoreAmbiguities === true);
  const errors = flatMap_default(ors, (currOr) => {
    const currOccurrence = currOr.idx;
    const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;
    const alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);
    const altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
    const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);
  });
  return errors;
}
function validateTooManyAlts(topLevelRule, errMsgProvider) {
  const orCollector = new OrCollector();
  topLevelRule.accept(orCollector);
  const ors = orCollector.alternations;
  const errors = flatMap_default(ors, (currOr) => {
    if (currOr.definition.length > 255) {
      return [
        {
          message: errMsgProvider.buildTooManyAlternativesError({
            topLevelRule,
            alternation: currOr
          }),
          type: ParserDefinitionErrorType.TOO_MANY_ALTS,
          ruleName: topLevelRule.name,
          occurrence: currOr.idx
        }
      ];
    } else {
      return [];
    }
  });
  return errors;
}
function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {
  const errors = [];
  forEach_default(topLevelRules, (currTopRule) => {
    const collectorVisitor2 = new RepetitionCollector();
    currTopRule.accept(collectorVisitor2);
    const allRuleProductions = collectorVisitor2.allProductions;
    forEach_default(allRuleProductions, (currProd) => {
      const prodType = getProdType(currProd);
      const actualMaxLookahead = currProd.maxLookahead || maxLookahead;
      const currOccurrence = currProd.idx;
      const paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);
      const pathsInsideProduction = paths[0];
      if (isEmpty_default(flatten_default(pathsInsideProduction))) {
        const errMsg = errMsgProvider.buildEmptyRepetitionError({
          topLevelRule: currTopRule,
          repetition: currProd
        });
        errors.push({
          message: errMsg,
          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,
          ruleName: currTopRule.name
        });
      }
    });
  });
  return errors;
}
function checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
  const foundAmbiguousPaths = [];
  const identicalAmbiguities = reduce_default(alternatives, (result, currAlt, currAltIdx) => {
    if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {
      return result;
    }
    forEach_default(currAlt, (currPath) => {
      const altsCurrPathAppearsIn = [currAltIdx];
      forEach_default(alternatives, (currOtherAlt, currOtherAltIdx) => {
        if (currAltIdx !== currOtherAltIdx && containsPath(currOtherAlt, currPath) && // ignore (skip) ambiguities with this "other" alternative
        alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {
          altsCurrPathAppearsIn.push(currOtherAltIdx);
        }
      });
      if (altsCurrPathAppearsIn.length > 1 && !containsPath(foundAmbiguousPaths, currPath)) {
        foundAmbiguousPaths.push(currPath);
        result.push({
          alts: altsCurrPathAppearsIn,
          path: currPath
        });
      }
    });
    return result;
  }, []);
  const currErrors = map_default(identicalAmbiguities, (currAmbDescriptor) => {
    const ambgIndices = map_default(currAmbDescriptor.alts, (currAltIdx) => currAltIdx + 1);
    const currMessage = errMsgProvider.buildAlternationAmbiguityError({
      topLevelRule: rule,
      alternation,
      ambiguityIndices: ambgIndices,
      prefixPath: currAmbDescriptor.path
    });
    return {
      message: currMessage,
      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,
      ruleName: rule.name,
      occurrence: alternation.idx,
      alternatives: currAmbDescriptor.alts
    };
  });
  return currErrors;
}
function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
  const pathsAndIndices = reduce_default(alternatives, (result, currAlt, idx) => {
    const currPathsAndIdx = map_default(currAlt, (currPath) => {
      return { idx, path: currPath };
    });
    return result.concat(currPathsAndIdx);
  }, []);
  const errors = compact_default(flatMap_default(pathsAndIndices, (currPathAndIdx) => {
    const alternativeGast = alternation.definition[currPathAndIdx.idx];
    if (alternativeGast.ignoreAmbiguities === true) {
      return [];
    }
    const targetIdx = currPathAndIdx.idx;
    const targetPath = currPathAndIdx.path;
    const prefixAmbiguitiesPathsAndIndices = filter_default(pathsAndIndices, (searchPathAndIdx) => {
      return (
        // ignore (skip) ambiguities with this "other" alternative
        alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads
        // will be be detected using a different validation.
        isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)
      );
    });
    const currPathPrefixErrors = map_default(prefixAmbiguitiesPathsAndIndices, (currAmbPathAndIdx) => {
      const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];
      const occurrence = alternation.idx === 0 ? "" : alternation.idx;
      const message = errMsgProvider.buildAlternationPrefixAmbiguityError({
        topLevelRule: rule,
        alternation,
        ambiguityIndices: ambgIndices,
        prefixPath: currAmbPathAndIdx.path
      });
      return {
        message,
        type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,
        ruleName: rule.name,
        occurrence,
        alternatives: ambgIndices
      };
    });
    return currPathPrefixErrors;
  }));
  return errors;
}
function checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {
  const errors = [];
  const tokenNames = map_default(tokenTypes, (currToken) => currToken.name);
  forEach_default(topLevels, (currRule) => {
    const currRuleName = currRule.name;
    if (includes_default(tokenNames, currRuleName)) {
      const errMsg = errMsgProvider.buildNamespaceConflictError(currRule);
      errors.push({
        message: errMsg,
        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,
        ruleName: currRuleName
      });
    }
  });
  return errors;
}
var OccurrenceValidationCollector, OrCollector, RepetitionCollector;
var init_checks = __esm({
  "node_modules/chevrotain/lib/src/parse/grammar/checks.js"() {
    init_lodash();
    init_parser();
    init_api2();
    init_lookahead();
    init_interpreter();
    init_tokens();
    OccurrenceValidationCollector = class extends GAstVisitor {
      constructor() {
        super(...arguments);
        this.allProductions = [];
      }
      visitNonTerminal(subrule) {
        this.allProductions.push(subrule);
      }
      visitOption(option) {
        this.allProductions.push(option);
      }
      visitRepetitionWithSeparator(manySep) {
        this.allProductions.push(manySep);
      }
      visitRepetitionMandatory(atLeastOne) {
        this.allProductions.push(atLeastOne);
      }
      visitRepetitionMandatoryWithSeparator(atLeastOneSep) {
        this.allProductions.push(atLeastOneSep);
      }
      visitRepetition(many) {
        this.allProductions.push(many);
      }
      visitAlternation(or) {
        this.allProductions.push(or);
      }
      visitTerminal(terminal) {
        this.allProductions.push(terminal);
      }
    };
    OrCollector = class extends GAstVisitor {
      constructor() {
        super(...arguments);
        this.alternations = [];
      }
      visitAlternation(node) {
        this.alternations.push(node);
      }
    };
    RepetitionCollector = class extends GAstVisitor {
      constructor() {
        super(...arguments);
        this.allProductions = [];
      }
      visitRepetitionWithSeparator(manySep) {
        this.allProductions.push(manySep);
      }
      visitRepetitionMandatory(atLeastOne) {
        this.allProductions.push(atLeastOne);
      }
      visitRepetitionMandatoryWithSeparator(atLeastOneSep) {
        this.allProductions.push(atLeastOneSep);
      }
      visitRepetition(many) {
        this.allProductions.push(many);
      }
    };
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js
function resolveGrammar2(options) {
  const actualOptions = defaults_default(options, {
    errMsgProvider: defaultGrammarResolverErrorProvider
  });
  const topRulesTable = {};
  forEach_default(options.rules, (rule) => {
    topRulesTable[rule.name] = rule;
  });
  return resolveGrammar(topRulesTable, actualOptions.errMsgProvider);
}
function validateGrammar2(options) {
  options = defaults_default(options, {
    errMsgProvider: defaultGrammarValidatorErrorProvider
  });
  return validateGrammar(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName);
}
var init_gast_resolver_public = __esm({
  "node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js"() {
    init_lodash();
    init_resolver();
    init_checks();
    init_errors_public();
  }
});

// node_modules/chevrotain/lib/src/parse/exceptions_public.js
function isRecognitionException(error) {
  return includes_default(RECOGNITION_EXCEPTION_NAMES, error.name);
}
var MISMATCHED_TOKEN_EXCEPTION, NO_VIABLE_ALT_EXCEPTION, EARLY_EXIT_EXCEPTION, NOT_ALL_INPUT_PARSED_EXCEPTION, RECOGNITION_EXCEPTION_NAMES, RecognitionException, MismatchedTokenException, NoViableAltException, NotAllInputParsedException, EarlyExitException;
var init_exceptions_public = __esm({
  "node_modules/chevrotain/lib/src/parse/exceptions_public.js"() {
    init_lodash();
    MISMATCHED_TOKEN_EXCEPTION = "MismatchedTokenException";
    NO_VIABLE_ALT_EXCEPTION = "NoViableAltException";
    EARLY_EXIT_EXCEPTION = "EarlyExitException";
    NOT_ALL_INPUT_PARSED_EXCEPTION = "NotAllInputParsedException";
    RECOGNITION_EXCEPTION_NAMES = [
      MISMATCHED_TOKEN_EXCEPTION,
      NO_VIABLE_ALT_EXCEPTION,
      EARLY_EXIT_EXCEPTION,
      NOT_ALL_INPUT_PARSED_EXCEPTION
    ];
    Object.freeze(RECOGNITION_EXCEPTION_NAMES);
    RecognitionException = class extends Error {
      constructor(message, token) {
        super(message);
        this.token = token;
        this.resyncedTokens = [];
        Object.setPrototypeOf(this, new.target.prototype);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
    };
    MismatchedTokenException = class extends RecognitionException {
      constructor(message, token, previousToken) {
        super(message, token);
        this.previousToken = previousToken;
        this.name = MISMATCHED_TOKEN_EXCEPTION;
      }
    };
    NoViableAltException = class extends RecognitionException {
      constructor(message, token, previousToken) {
        super(message, token);
        this.previousToken = previousToken;
        this.name = NO_VIABLE_ALT_EXCEPTION;
      }
    };
    NotAllInputParsedException = class extends RecognitionException {
      constructor(message, token) {
        super(message, token);
        this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;
      }
    };
    EarlyExitException = class extends RecognitionException {
      constructor(message, token, previousToken) {
        super(message, token);
        this.previousToken = previousToken;
        this.name = EARLY_EXIT_EXCEPTION;
      }
    };
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js
function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
  const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);
  let firstAfterRepInfo = this.firstAfterRepMap[key];
  if (firstAfterRepInfo === void 0) {
    const currRuleName = this.getCurrRuleFullName();
    const ruleGrammar = this.getGAstProductions()[currRuleName];
    const walker = new nextToksWalker(ruleGrammar, prodOccurrence);
    firstAfterRepInfo = walker.startWalking();
    this.firstAfterRepMap[key] = firstAfterRepInfo;
  }
  let expectTokAfterLastMatch = firstAfterRepInfo.token;
  let nextTokIdx = firstAfterRepInfo.occurrence;
  const isEndOfRule = firstAfterRepInfo.isEndOfRule;
  if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === void 0) {
    expectTokAfterLastMatch = EOF;
    nextTokIdx = 1;
  }
  if (expectTokAfterLastMatch === void 0 || nextTokIdx === void 0) {
    return;
  }
  if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {
    this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);
  }
}
var EOF_FOLLOW_KEY, IN_RULE_RECOVERY_EXCEPTION, InRuleRecoveryException, Recoverable;
var init_recoverable = __esm({
  "node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js"() {
    init_tokens_public();
    init_lodash();
    init_exceptions_public();
    init_constants();
    init_parser();
    EOF_FOLLOW_KEY = {};
    IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException";
    InRuleRecoveryException = class extends Error {
      constructor(message) {
        super(message);
        this.name = IN_RULE_RECOVERY_EXCEPTION;
      }
    };
    Recoverable = class {
      initRecoverable(config) {
        this.firstAfterRepMap = {};
        this.resyncFollows = {};
        this.recoveryEnabled = has_default(config, "recoveryEnabled") ? config.recoveryEnabled : DEFAULT_PARSER_CONFIG.recoveryEnabled;
        if (this.recoveryEnabled) {
          this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
        }
      }
      getTokenToInsert(tokType) {
        const tokToInsert = createTokenInstance(tokType, "", NaN, NaN, NaN, NaN, NaN, NaN);
        tokToInsert.isInsertedInRecovery = true;
        return tokToInsert;
      }
      canTokenTypeBeInsertedInRecovery(tokType) {
        return true;
      }
      canTokenTypeBeDeletedInRecovery(tokType) {
        return true;
      }
      tryInRepetitionRecovery(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {
        const reSyncTokType = this.findReSyncTokenType();
        const savedLexerState = this.exportLexerState();
        const resyncedTokens = [];
        let passedResyncPoint = false;
        const nextTokenWithoutResync = this.LA(1);
        let currToken = this.LA(1);
        const generateErrorMessage = () => {
          const previousToken = this.LA(0);
          const msg = this.errorMessageProvider.buildMismatchTokenMessage({
            expected: expectedTokType,
            actual: nextTokenWithoutResync,
            previous: previousToken,
            ruleName: this.getCurrRuleFullName()
          });
          const error = new MismatchedTokenException(msg, nextTokenWithoutResync, this.LA(0));
          error.resyncedTokens = dropRight_default(resyncedTokens);
          this.SAVE_ERROR(error);
        };
        while (!passedResyncPoint) {
          if (this.tokenMatcher(currToken, expectedTokType)) {
            generateErrorMessage();
            return;
          } else if (lookAheadFunc.call(this)) {
            generateErrorMessage();
            grammarRule.apply(this, grammarRuleArgs);
            return;
          } else if (this.tokenMatcher(currToken, reSyncTokType)) {
            passedResyncPoint = true;
          } else {
            currToken = this.SKIP_TOKEN();
            this.addToResyncTokens(currToken, resyncedTokens);
          }
        }
        this.importLexerState(savedLexerState);
      }
      shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck) {
        if (notStuck === false) {
          return false;
        }
        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {
          return false;
        }
        if (this.isBackTracking()) {
          return false;
        }
        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {
          return false;
        }
        return true;
      }
      // Error Recovery functionality
      getFollowsForInRuleRecovery(tokType, tokIdxInRule) {
        const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);
        const follows = this.getNextPossibleTokenTypes(grammarPath);
        return follows;
      }
      tryInRuleRecovery(expectedTokType, follows) {
        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {
          const tokToInsert = this.getTokenToInsert(expectedTokType);
          return tokToInsert;
        }
        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {
          const nextTok = this.SKIP_TOKEN();
          this.consumeToken();
          return nextTok;
        }
        throw new InRuleRecoveryException("sad sad panda");
      }
      canPerformInRuleRecovery(expectedToken, follows) {
        return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);
      }
      canRecoverWithSingleTokenInsertion(expectedTokType, follows) {
        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {
          return false;
        }
        if (isEmpty_default(follows)) {
          return false;
        }
        const mismatchedTok = this.LA(1);
        const isMisMatchedTokInFollows = find_default(follows, (possibleFollowsTokType) => {
          return this.tokenMatcher(mismatchedTok, possibleFollowsTokType);
        }) !== void 0;
        return isMisMatchedTokInFollows;
      }
      canRecoverWithSingleTokenDeletion(expectedTokType) {
        if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {
          return false;
        }
        const isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);
        return isNextTokenWhatIsExpected;
      }
      isInCurrentRuleReSyncSet(tokenTypeIdx) {
        const followKey = this.getCurrFollowKey();
        const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);
        return includes_default(currentRuleReSyncSet, tokenTypeIdx);
      }
      findReSyncTokenType() {
        const allPossibleReSyncTokTypes = this.flattenFollowSet();
        let nextToken = this.LA(1);
        let k = 2;
        while (true) {
          const foundMatch = find_default(allPossibleReSyncTokTypes, (resyncTokType) => {
            const canMatch = tokenMatcher(nextToken, resyncTokType);
            return canMatch;
          });
          if (foundMatch !== void 0) {
            return foundMatch;
          }
          nextToken = this.LA(k);
          k++;
        }
      }
      getCurrFollowKey() {
        if (this.RULE_STACK.length === 1) {
          return EOF_FOLLOW_KEY;
        }
        const currRuleShortName = this.getLastExplicitRuleShortName();
        const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();
        const prevRuleShortName = this.getPreviousExplicitRuleShortName();
        return {
          ruleName: this.shortRuleNameToFullName(currRuleShortName),
          idxInCallingRule: currRuleIdx,
          inRule: this.shortRuleNameToFullName(prevRuleShortName)
        };
      }
      buildFullFollowKeyStack() {
        const explicitRuleStack = this.RULE_STACK;
        const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;
        return map_default(explicitRuleStack, (ruleName, idx) => {
          if (idx === 0) {
            return EOF_FOLLOW_KEY;
          }
          return {
            ruleName: this.shortRuleNameToFullName(ruleName),
            idxInCallingRule: explicitOccurrenceStack[idx],
            inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1])
          };
        });
      }
      flattenFollowSet() {
        const followStack = map_default(this.buildFullFollowKeyStack(), (currKey) => {
          return this.getFollowSetFromFollowKey(currKey);
        });
        return flatten_default(followStack);
      }
      getFollowSetFromFollowKey(followKey) {
        if (followKey === EOF_FOLLOW_KEY) {
          return [EOF];
        }
        const followName = followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule;
        return this.resyncFollows[followName];
      }
      // It does not make any sense to include a virtual EOF token in the list of resynced tokens
      // as EOF does not really exist and thus does not contain any useful information (line/column numbers)
      addToResyncTokens(token, resyncTokens) {
        if (!this.tokenMatcher(token, EOF)) {
          resyncTokens.push(token);
        }
        return resyncTokens;
      }
      reSyncTo(tokType) {
        const resyncedTokens = [];
        let nextTok = this.LA(1);
        while (this.tokenMatcher(nextTok, tokType) === false) {
          nextTok = this.SKIP_TOKEN();
          this.addToResyncTokens(nextTok, resyncedTokens);
        }
        return dropRight_default(resyncedTokens);
      }
      attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
      }
      getCurrentGrammarPath(tokType, tokIdxInRule) {
        const pathRuleStack = this.getHumanReadableRuleStack();
        const pathOccurrenceStack = clone_default(this.RULE_OCCURRENCE_STACK);
        const grammarPath = {
          ruleStack: pathRuleStack,
          occurrenceStack: pathOccurrenceStack,
          lastTok: tokType,
          lastTokOccurrence: tokIdxInRule
        };
        return grammarPath;
      }
      getHumanReadableRuleStack() {
        return map_default(this.RULE_STACK, (currShortName) => this.shortRuleNameToFullName(currShortName));
      }
    };
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/keys.js
function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {
  return occurrence | dslMethodIdx | ruleIdx;
}
var BITS_FOR_METHOD_TYPE, BITS_FOR_OCCURRENCE_IDX, BITS_FOR_ALT_IDX, OR_IDX, OPTION_IDX, MANY_IDX, AT_LEAST_ONE_IDX, MANY_SEP_IDX, AT_LEAST_ONE_SEP_IDX, BITS_START_FOR_ALT_IDX;
var init_keys2 = __esm({
  "node_modules/chevrotain/lib/src/parse/grammar/keys.js"() {
    BITS_FOR_METHOD_TYPE = 4;
    BITS_FOR_OCCURRENCE_IDX = 8;
    BITS_FOR_ALT_IDX = 8;
    OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;
    OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;
    MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;
    AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;
    MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;
    AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;
    BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX;
  }
});

// node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js
var LLkLookaheadStrategy;
var init_llk_lookahead = __esm({
  "node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js"() {
    init_lodash();
    init_errors_public();
    init_parser();
    init_checks();
    init_lookahead();
    LLkLookaheadStrategy = class {
      constructor(options) {
        var _a;
        this.maxLookahead = (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : DEFAULT_PARSER_CONFIG.maxLookahead;
      }
      validate(options) {
        const leftRecursionErrors = this.validateNoLeftRecursion(options.rules);
        if (isEmpty_default(leftRecursionErrors)) {
          const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);
          const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);
          const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);
          const allErrors = [
            ...leftRecursionErrors,
            ...emptyAltErrors,
            ...ambiguousAltsErrors,
            ...emptyRepetitionErrors
          ];
          return allErrors;
        }
        return leftRecursionErrors;
      }
      validateNoLeftRecursion(rules3) {
        return flatMap_default(rules3, (currTopRule) => validateNoLeftRecursion(currTopRule, currTopRule, defaultGrammarValidatorErrorProvider));
      }
      validateEmptyOrAlternatives(rules3) {
        return flatMap_default(rules3, (currTopRule) => validateEmptyOrAlternative(currTopRule, defaultGrammarValidatorErrorProvider));
      }
      validateAmbiguousAlternationAlternatives(rules3, maxLookahead) {
        return flatMap_default(rules3, (currTopRule) => validateAmbiguousAlternationAlternatives(currTopRule, maxLookahead, defaultGrammarValidatorErrorProvider));
      }
      validateSomeNonEmptyLookaheadPath(rules3, maxLookahead) {
        return validateSomeNonEmptyLookaheadPath(rules3, maxLookahead, defaultGrammarValidatorErrorProvider);
      }
      buildLookaheadForAlternation(options) {
        return buildLookaheadFuncForOr(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, buildAlternativesLookAheadFunc);
      }
      buildLookaheadForOptional(options) {
        return buildLookaheadFuncForOptionalProd(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, getProdType(options.prodType), buildSingleAlternativeLookaheadFunction);
      }
    };
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js
function collectMethods(rule) {
  collectorVisitor.reset();
  rule.accept(collectorVisitor);
  const dslMethods = collectorVisitor.dslMethods;
  collectorVisitor.reset();
  return dslMethods;
}
var LooksAhead, DslMethodsCollectorVisitor, collectorVisitor;
var init_looksahead = __esm({
  "node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js"() {
    init_lodash();
    init_parser();
    init_keys2();
    init_api2();
    init_llk_lookahead();
    LooksAhead = class {
      initLooksAhead(config) {
        this.dynamicTokensEnabled = has_default(config, "dynamicTokensEnabled") ? config.dynamicTokensEnabled : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;
        this.maxLookahead = has_default(config, "maxLookahead") ? config.maxLookahead : DEFAULT_PARSER_CONFIG.maxLookahead;
        this.lookaheadStrategy = has_default(config, "lookaheadStrategy") ? config.lookaheadStrategy : new LLkLookaheadStrategy({ maxLookahead: this.maxLookahead });
        this.lookAheadFuncsCache = /* @__PURE__ */ new Map();
      }
      preComputeLookaheadFunctions(rules3) {
        forEach_default(rules3, (currRule) => {
          this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {
            const { alternation, repetition, option, repetitionMandatory, repetitionMandatoryWithSeparator, repetitionWithSeparator } = collectMethods(currRule);
            forEach_default(alternation, (currProd) => {
              const prodIdx = currProd.idx === 0 ? "" : currProd.idx;
              this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {
                const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({
                  prodOccurrence: currProd.idx,
                  rule: currRule,
                  maxLookahead: currProd.maxLookahead || this.maxLookahead,
                  hasPredicates: currProd.hasPredicates,
                  dynamicTokensEnabled: this.dynamicTokensEnabled
                });
                const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[currRule.name], OR_IDX, currProd.idx);
                this.setLaFuncCache(key, laFunc);
              });
            });
            forEach_default(repetition, (currProd) => {
              this.computeLookaheadFunc(currRule, currProd.idx, MANY_IDX, "Repetition", currProd.maxLookahead, getProductionDslName(currProd));
            });
            forEach_default(option, (currProd) => {
              this.computeLookaheadFunc(currRule, currProd.idx, OPTION_IDX, "Option", currProd.maxLookahead, getProductionDslName(currProd));
            });
            forEach_default(repetitionMandatory, (currProd) => {
              this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_IDX, "RepetitionMandatory", currProd.maxLookahead, getProductionDslName(currProd));
            });
            forEach_default(repetitionMandatoryWithSeparator, (currProd) => {
              this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_SEP_IDX, "RepetitionMandatoryWithSeparator", currProd.maxLookahead, getProductionDslName(currProd));
            });
            forEach_default(repetitionWithSeparator, (currProd) => {
              this.computeLookaheadFunc(currRule, currProd.idx, MANY_SEP_IDX, "RepetitionWithSeparator", currProd.maxLookahead, getProductionDslName(currProd));
            });
          });
        });
      }
      computeLookaheadFunc(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {
        this.TRACE_INIT(`${dslMethodName}${prodOccurrence === 0 ? "" : prodOccurrence}`, () => {
          const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({
            prodOccurrence,
            rule,
            maxLookahead: prodMaxLookahead || this.maxLookahead,
            dynamicTokensEnabled: this.dynamicTokensEnabled,
            prodType
          });
          const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);
          this.setLaFuncCache(key, laFunc);
        });
      }
      // this actually returns a number, but it is always used as a string (object prop key)
      getKeyForAutomaticLookahead(dslMethodIdx, occurrence) {
        const currRuleShortName = this.getLastExplicitRuleShortName();
        return getKeyForAutomaticLookahead(currRuleShortName, dslMethodIdx, occurrence);
      }
      getLaFuncFromCache(key) {
        return this.lookAheadFuncsCache.get(key);
      }
      /* istanbul ignore next */
      setLaFuncCache(key, value) {
        this.lookAheadFuncsCache.set(key, value);
      }
    };
    DslMethodsCollectorVisitor = class extends GAstVisitor {
      constructor() {
        super(...arguments);
        this.dslMethods = {
          option: [],
          alternation: [],
          repetition: [],
          repetitionWithSeparator: [],
          repetitionMandatory: [],
          repetitionMandatoryWithSeparator: []
        };
      }
      reset() {
        this.dslMethods = {
          option: [],
          alternation: [],
          repetition: [],
          repetitionWithSeparator: [],
          repetitionMandatory: [],
          repetitionMandatoryWithSeparator: []
        };
      }
      visitOption(option) {
        this.dslMethods.option.push(option);
      }
      visitRepetitionWithSeparator(manySep) {
        this.dslMethods.repetitionWithSeparator.push(manySep);
      }
      visitRepetitionMandatory(atLeastOne) {
        this.dslMethods.repetitionMandatory.push(atLeastOne);
      }
      visitRepetitionMandatoryWithSeparator(atLeastOneSep) {
        this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);
      }
      visitRepetition(many) {
        this.dslMethods.repetition.push(many);
      }
      visitAlternation(or) {
        this.dslMethods.alternation.push(or);
      }
    };
    collectorVisitor = new DslMethodsCollectorVisitor();
  }
});

// node_modules/chevrotain/lib/src/parse/cst/cst.js
function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {
  if (isNaN(currNodeLocation.startOffset) === true) {
    currNodeLocation.startOffset = newLocationInfo.startOffset;
    currNodeLocation.endOffset = newLocationInfo.endOffset;
  } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
    currNodeLocation.endOffset = newLocationInfo.endOffset;
  }
}
function setNodeLocationFull(currNodeLocation, newLocationInfo) {
  if (isNaN(currNodeLocation.startOffset) === true) {
    currNodeLocation.startOffset = newLocationInfo.startOffset;
    currNodeLocation.startColumn = newLocationInfo.startColumn;
    currNodeLocation.startLine = newLocationInfo.startLine;
    currNodeLocation.endOffset = newLocationInfo.endOffset;
    currNodeLocation.endColumn = newLocationInfo.endColumn;
    currNodeLocation.endLine = newLocationInfo.endLine;
  } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
    currNodeLocation.endOffset = newLocationInfo.endOffset;
    currNodeLocation.endColumn = newLocationInfo.endColumn;
    currNodeLocation.endLine = newLocationInfo.endLine;
  }
}
function addTerminalToCst(node, token, tokenTypeName) {
  if (node.children[tokenTypeName] === void 0) {
    node.children[tokenTypeName] = [token];
  } else {
    node.children[tokenTypeName].push(token);
  }
}
function addNoneTerminalToCst(node, ruleName, ruleResult) {
  if (node.children[ruleName] === void 0) {
    node.children[ruleName] = [ruleResult];
  } else {
    node.children[ruleName].push(ruleResult);
  }
}
var init_cst = __esm({
  "node_modules/chevrotain/lib/src/parse/cst/cst.js"() {
  }
});

// node_modules/chevrotain/lib/src/lang/lang_extensions.js
function defineNameProp(obj, nameValue) {
  Object.defineProperty(obj, NAME, {
    enumerable: false,
    configurable: true,
    writable: false,
    value: nameValue
  });
}
var NAME;
var init_lang_extensions = __esm({
  "node_modules/chevrotain/lib/src/lang/lang_extensions.js"() {
    NAME = "name";
  }
});

// node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js
function defaultVisit(ctx, param) {
  const childrenNames = keys_default(ctx);
  const childrenNamesLength = childrenNames.length;
  for (let i = 0; i < childrenNamesLength; i++) {
    const currChildName = childrenNames[i];
    const currChildArray = ctx[currChildName];
    const currChildArrayLength = currChildArray.length;
    for (let j = 0; j < currChildArrayLength; j++) {
      const currChild = currChildArray[j];
      if (currChild.tokenTypeIdx === void 0) {
        this[currChild.name](currChild.children, param);
      }
    }
  }
}
function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {
  const derivedConstructor = function() {
  };
  defineNameProp(derivedConstructor, grammarName + "BaseSemantics");
  const semanticProto = {
    visit: function(cstNode, param) {
      if (isArray_default(cstNode)) {
        cstNode = cstNode[0];
      }
      if (isUndefined_default(cstNode)) {
        return void 0;
      }
      return this[cstNode.name](cstNode.children, param);
    },
    validateVisitor: function() {
      const semanticDefinitionErrors = validateVisitor(this, ruleNames);
      if (!isEmpty_default(semanticDefinitionErrors)) {
        const errorMessages = map_default(semanticDefinitionErrors, (currDefError) => currDefError.msg);
        throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:
	${errorMessages.join("\n\n").replace(/\n/g, "\n	")}`);
      }
    }
  };
  derivedConstructor.prototype = semanticProto;
  derivedConstructor.prototype.constructor = derivedConstructor;
  derivedConstructor._RULE_NAMES = ruleNames;
  return derivedConstructor;
}
function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {
  const derivedConstructor = function() {
  };
  defineNameProp(derivedConstructor, grammarName + "BaseSemanticsWithDefaults");
  const withDefaultsProto = Object.create(baseConstructor.prototype);
  forEach_default(ruleNames, (ruleName) => {
    withDefaultsProto[ruleName] = defaultVisit;
  });
  derivedConstructor.prototype = withDefaultsProto;
  derivedConstructor.prototype.constructor = derivedConstructor;
  return derivedConstructor;
}
function validateVisitor(visitorInstance, ruleNames) {
  const missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);
  return missingErrors;
}
function validateMissingCstMethods(visitorInstance, ruleNames) {
  const missingRuleNames = filter_default(ruleNames, (currRuleName) => {
    return isFunction_default(visitorInstance[currRuleName]) === false;
  });
  const errors = map_default(missingRuleNames, (currRuleName) => {
    return {
      msg: `Missing visitor method: <${currRuleName}> on ${visitorInstance.constructor.name} CST Visitor.`,
      type: CstVisitorDefinitionError.MISSING_METHOD,
      methodName: currRuleName
    };
  });
  return compact_default(errors);
}
var CstVisitorDefinitionError;
var init_cst_visitor = __esm({
  "node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js"() {
    init_lodash();
    init_lang_extensions();
    (function(CstVisitorDefinitionError2) {
      CstVisitorDefinitionError2[CstVisitorDefinitionError2["REDUNDANT_METHOD"] = 0] = "REDUNDANT_METHOD";
      CstVisitorDefinitionError2[CstVisitorDefinitionError2["MISSING_METHOD"] = 1] = "MISSING_METHOD";
    })(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js
var TreeBuilder;
var init_tree_builder = __esm({
  "node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js"() {
    init_cst();
    init_lodash();
    init_cst_visitor();
    init_parser();
    TreeBuilder = class {
      initTreeBuilder(config) {
        this.CST_STACK = [];
        this.outputCst = config.outputCst;
        this.nodeLocationTracking = has_default(config, "nodeLocationTracking") ? config.nodeLocationTracking : DEFAULT_PARSER_CONFIG.nodeLocationTracking;
        if (!this.outputCst) {
          this.cstInvocationStateUpdate = noop_default;
          this.cstFinallyStateUpdate = noop_default;
          this.cstPostTerminal = noop_default;
          this.cstPostNonTerminal = noop_default;
          this.cstPostRule = noop_default;
        } else {
          if (/full/i.test(this.nodeLocationTracking)) {
            if (this.recoveryEnabled) {
              this.setNodeLocationFromToken = setNodeLocationFull;
              this.setNodeLocationFromNode = setNodeLocationFull;
              this.cstPostRule = noop_default;
              this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;
            } else {
              this.setNodeLocationFromToken = noop_default;
              this.setNodeLocationFromNode = noop_default;
              this.cstPostRule = this.cstPostRuleFull;
              this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;
            }
          } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {
            if (this.recoveryEnabled) {
              this.setNodeLocationFromToken = setNodeLocationOnlyOffset;
              this.setNodeLocationFromNode = setNodeLocationOnlyOffset;
              this.cstPostRule = noop_default;
              this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;
            } else {
              this.setNodeLocationFromToken = noop_default;
              this.setNodeLocationFromNode = noop_default;
              this.cstPostRule = this.cstPostRuleOnlyOffset;
              this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;
            }
          } else if (/none/i.test(this.nodeLocationTracking)) {
            this.setNodeLocationFromToken = noop_default;
            this.setNodeLocationFromNode = noop_default;
            this.cstPostRule = noop_default;
            this.setInitialNodeLocation = noop_default;
          } else {
            throw Error(`Invalid <nodeLocationTracking> config option: "${config.nodeLocationTracking}"`);
          }
        }
      }
      setInitialNodeLocationOnlyOffsetRecovery(cstNode) {
        cstNode.location = {
          startOffset: NaN,
          endOffset: NaN
        };
      }
      setInitialNodeLocationOnlyOffsetRegular(cstNode) {
        cstNode.location = {
          // without error recovery the starting Location of a new CstNode is guaranteed
          // To be the next Token's startOffset (for valid inputs).
          // For invalid inputs there won't be any CSTOutput so this potential
          // inaccuracy does not matter
          startOffset: this.LA(1).startOffset,
          endOffset: NaN
        };
      }
      setInitialNodeLocationFullRecovery(cstNode) {
        cstNode.location = {
          startOffset: NaN,
          startLine: NaN,
          startColumn: NaN,
          endOffset: NaN,
          endLine: NaN,
          endColumn: NaN
        };
      }
      /**
           *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work
      
           * @param cstNode
           */
      setInitialNodeLocationFullRegular(cstNode) {
        const nextToken = this.LA(1);
        cstNode.location = {
          startOffset: nextToken.startOffset,
          startLine: nextToken.startLine,
          startColumn: nextToken.startColumn,
          endOffset: NaN,
          endLine: NaN,
          endColumn: NaN
        };
      }
      cstInvocationStateUpdate(fullRuleName) {
        const cstNode = {
          name: fullRuleName,
          children: /* @__PURE__ */ Object.create(null)
        };
        this.setInitialNodeLocation(cstNode);
        this.CST_STACK.push(cstNode);
      }
      cstFinallyStateUpdate() {
        this.CST_STACK.pop();
      }
      cstPostRuleFull(ruleCstNode) {
        const prevToken = this.LA(0);
        const loc = ruleCstNode.location;
        if (loc.startOffset <= prevToken.startOffset === true) {
          loc.endOffset = prevToken.endOffset;
          loc.endLine = prevToken.endLine;
          loc.endColumn = prevToken.endColumn;
        } else {
          loc.startOffset = NaN;
          loc.startLine = NaN;
          loc.startColumn = NaN;
        }
      }
      cstPostRuleOnlyOffset(ruleCstNode) {
        const prevToken = this.LA(0);
        const loc = ruleCstNode.location;
        if (loc.startOffset <= prevToken.startOffset === true) {
          loc.endOffset = prevToken.endOffset;
        } else {
          loc.startOffset = NaN;
        }
      }
      cstPostTerminal(key, consumedToken) {
        const rootCst = this.CST_STACK[this.CST_STACK.length - 1];
        addTerminalToCst(rootCst, consumedToken, key);
        this.setNodeLocationFromToken(rootCst.location, consumedToken);
      }
      cstPostNonTerminal(ruleCstResult, ruleName) {
        const preCstNode = this.CST_STACK[this.CST_STACK.length - 1];
        addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);
        this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);
      }
      getBaseCstVisitorConstructor() {
        if (isUndefined_default(this.baseCstVisitorConstructor)) {
          const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(this.className, keys_default(this.gastProductionsCache));
          this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;
          return newBaseCstVisitorConstructor;
        }
        return this.baseCstVisitorConstructor;
      }
      getBaseCstVisitorConstructorWithDefaults() {
        if (isUndefined_default(this.baseCstVisitorWithDefaultsConstructor)) {
          const newConstructor = createBaseVisitorConstructorWithDefaults(this.className, keys_default(this.gastProductionsCache), this.getBaseCstVisitorConstructor());
          this.baseCstVisitorWithDefaultsConstructor = newConstructor;
          return newConstructor;
        }
        return this.baseCstVisitorWithDefaultsConstructor;
      }
      getLastExplicitRuleShortName() {
        const ruleStack = this.RULE_STACK;
        return ruleStack[ruleStack.length - 1];
      }
      getPreviousExplicitRuleShortName() {
        const ruleStack = this.RULE_STACK;
        return ruleStack[ruleStack.length - 2];
      }
      getLastExplicitRuleOccurrenceIndex() {
        const occurrenceStack = this.RULE_OCCURRENCE_STACK;
        return occurrenceStack[occurrenceStack.length - 1];
      }
    };
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js
var LexerAdapter;
var init_lexer_adapter = __esm({
  "node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js"() {
    init_parser();
    LexerAdapter = class {
      initLexerAdapter() {
        this.tokVector = [];
        this.tokVectorLength = 0;
        this.currIdx = -1;
      }
      set input(newInput) {
        if (this.selfAnalysisDone !== true) {
          throw Error(`Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`);
        }
        this.reset();
        this.tokVector = newInput;
        this.tokVectorLength = newInput.length;
      }
      get input() {
        return this.tokVector;
      }
      // skips a token and returns the next token
      SKIP_TOKEN() {
        if (this.currIdx <= this.tokVector.length - 2) {
          this.consumeToken();
          return this.LA(1);
        } else {
          return END_OF_FILE;
        }
      }
      // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers
      // or lexers dependent on parser context.
      LA(howMuch) {
        const soughtIdx = this.currIdx + howMuch;
        if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {
          return END_OF_FILE;
        } else {
          return this.tokVector[soughtIdx];
        }
      }
      consumeToken() {
        this.currIdx++;
      }
      exportLexerState() {
        return this.currIdx;
      }
      importLexerState(newState) {
        this.currIdx = newState;
      }
      resetLexerState() {
        this.currIdx = -1;
      }
      moveToTerminatedState() {
        this.currIdx = this.tokVector.length - 1;
      }
      getLexerPosition() {
        return this.exportLexerState();
      }
    };
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js
var RecognizerApi;
var init_recognizer_api = __esm({
  "node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js"() {
    init_lodash();
    init_exceptions_public();
    init_parser();
    init_errors_public();
    init_checks();
    init_api2();
    RecognizerApi = class {
      ACTION(impl) {
        return impl.call(this);
      }
      consume(idx, tokType, options) {
        return this.consumeInternal(tokType, idx, options);
      }
      subrule(idx, ruleToCall, options) {
        return this.subruleInternal(ruleToCall, idx, options);
      }
      option(idx, actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, idx);
      }
      or(idx, altsOrOpts) {
        return this.orInternal(altsOrOpts, idx);
      }
      many(idx, actionORMethodDef) {
        return this.manyInternal(idx, actionORMethodDef);
      }
      atLeastOne(idx, actionORMethodDef) {
        return this.atLeastOneInternal(idx, actionORMethodDef);
      }
      CONSUME(tokType, options) {
        return this.consumeInternal(tokType, 0, options);
      }
      CONSUME1(tokType, options) {
        return this.consumeInternal(tokType, 1, options);
      }
      CONSUME2(tokType, options) {
        return this.consumeInternal(tokType, 2, options);
      }
      CONSUME3(tokType, options) {
        return this.consumeInternal(tokType, 3, options);
      }
      CONSUME4(tokType, options) {
        return this.consumeInternal(tokType, 4, options);
      }
      CONSUME5(tokType, options) {
        return this.consumeInternal(tokType, 5, options);
      }
      CONSUME6(tokType, options) {
        return this.consumeInternal(tokType, 6, options);
      }
      CONSUME7(tokType, options) {
        return this.consumeInternal(tokType, 7, options);
      }
      CONSUME8(tokType, options) {
        return this.consumeInternal(tokType, 8, options);
      }
      CONSUME9(tokType, options) {
        return this.consumeInternal(tokType, 9, options);
      }
      SUBRULE(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 0, options);
      }
      SUBRULE1(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 1, options);
      }
      SUBRULE2(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 2, options);
      }
      SUBRULE3(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 3, options);
      }
      SUBRULE4(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 4, options);
      }
      SUBRULE5(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 5, options);
      }
      SUBRULE6(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 6, options);
      }
      SUBRULE7(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 7, options);
      }
      SUBRULE8(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 8, options);
      }
      SUBRULE9(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 9, options);
      }
      OPTION(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 0);
      }
      OPTION1(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 1);
      }
      OPTION2(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 2);
      }
      OPTION3(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 3);
      }
      OPTION4(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 4);
      }
      OPTION5(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 5);
      }
      OPTION6(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 6);
      }
      OPTION7(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 7);
      }
      OPTION8(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 8);
      }
      OPTION9(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 9);
      }
      OR(altsOrOpts) {
        return this.orInternal(altsOrOpts, 0);
      }
      OR1(altsOrOpts) {
        return this.orInternal(altsOrOpts, 1);
      }
      OR2(altsOrOpts) {
        return this.orInternal(altsOrOpts, 2);
      }
      OR3(altsOrOpts) {
        return this.orInternal(altsOrOpts, 3);
      }
      OR4(altsOrOpts) {
        return this.orInternal(altsOrOpts, 4);
      }
      OR5(altsOrOpts) {
        return this.orInternal(altsOrOpts, 5);
      }
      OR6(altsOrOpts) {
        return this.orInternal(altsOrOpts, 6);
      }
      OR7(altsOrOpts) {
        return this.orInternal(altsOrOpts, 7);
      }
      OR8(altsOrOpts) {
        return this.orInternal(altsOrOpts, 8);
      }
      OR9(altsOrOpts) {
        return this.orInternal(altsOrOpts, 9);
      }
      MANY(actionORMethodDef) {
        this.manyInternal(0, actionORMethodDef);
      }
      MANY1(actionORMethodDef) {
        this.manyInternal(1, actionORMethodDef);
      }
      MANY2(actionORMethodDef) {
        this.manyInternal(2, actionORMethodDef);
      }
      MANY3(actionORMethodDef) {
        this.manyInternal(3, actionORMethodDef);
      }
      MANY4(actionORMethodDef) {
        this.manyInternal(4, actionORMethodDef);
      }
      MANY5(actionORMethodDef) {
        this.manyInternal(5, actionORMethodDef);
      }
      MANY6(actionORMethodDef) {
        this.manyInternal(6, actionORMethodDef);
      }
      MANY7(actionORMethodDef) {
        this.manyInternal(7, actionORMethodDef);
      }
      MANY8(actionORMethodDef) {
        this.manyInternal(8, actionORMethodDef);
      }
      MANY9(actionORMethodDef) {
        this.manyInternal(9, actionORMethodDef);
      }
      MANY_SEP(options) {
        this.manySepFirstInternal(0, options);
      }
      MANY_SEP1(options) {
        this.manySepFirstInternal(1, options);
      }
      MANY_SEP2(options) {
        this.manySepFirstInternal(2, options);
      }
      MANY_SEP3(options) {
        this.manySepFirstInternal(3, options);
      }
      MANY_SEP4(options) {
        this.manySepFirstInternal(4, options);
      }
      MANY_SEP5(options) {
        this.manySepFirstInternal(5, options);
      }
      MANY_SEP6(options) {
        this.manySepFirstInternal(6, options);
      }
      MANY_SEP7(options) {
        this.manySepFirstInternal(7, options);
      }
      MANY_SEP8(options) {
        this.manySepFirstInternal(8, options);
      }
      MANY_SEP9(options) {
        this.manySepFirstInternal(9, options);
      }
      AT_LEAST_ONE(actionORMethodDef) {
        this.atLeastOneInternal(0, actionORMethodDef);
      }
      AT_LEAST_ONE1(actionORMethodDef) {
        return this.atLeastOneInternal(1, actionORMethodDef);
      }
      AT_LEAST_ONE2(actionORMethodDef) {
        this.atLeastOneInternal(2, actionORMethodDef);
      }
      AT_LEAST_ONE3(actionORMethodDef) {
        this.atLeastOneInternal(3, actionORMethodDef);
      }
      AT_LEAST_ONE4(actionORMethodDef) {
        this.atLeastOneInternal(4, actionORMethodDef);
      }
      AT_LEAST_ONE5(actionORMethodDef) {
        this.atLeastOneInternal(5, actionORMethodDef);
      }
      AT_LEAST_ONE6(actionORMethodDef) {
        this.atLeastOneInternal(6, actionORMethodDef);
      }
      AT_LEAST_ONE7(actionORMethodDef) {
        this.atLeastOneInternal(7, actionORMethodDef);
      }
      AT_LEAST_ONE8(actionORMethodDef) {
        this.atLeastOneInternal(8, actionORMethodDef);
      }
      AT_LEAST_ONE9(actionORMethodDef) {
        this.atLeastOneInternal(9, actionORMethodDef);
      }
      AT_LEAST_ONE_SEP(options) {
        this.atLeastOneSepFirstInternal(0, options);
      }
      AT_LEAST_ONE_SEP1(options) {
        this.atLeastOneSepFirstInternal(1, options);
      }
      AT_LEAST_ONE_SEP2(options) {
        this.atLeastOneSepFirstInternal(2, options);
      }
      AT_LEAST_ONE_SEP3(options) {
        this.atLeastOneSepFirstInternal(3, options);
      }
      AT_LEAST_ONE_SEP4(options) {
        this.atLeastOneSepFirstInternal(4, options);
      }
      AT_LEAST_ONE_SEP5(options) {
        this.atLeastOneSepFirstInternal(5, options);
      }
      AT_LEAST_ONE_SEP6(options) {
        this.atLeastOneSepFirstInternal(6, options);
      }
      AT_LEAST_ONE_SEP7(options) {
        this.atLeastOneSepFirstInternal(7, options);
      }
      AT_LEAST_ONE_SEP8(options) {
        this.atLeastOneSepFirstInternal(8, options);
      }
      AT_LEAST_ONE_SEP9(options) {
        this.atLeastOneSepFirstInternal(9, options);
      }
      RULE(name, implementation, config = DEFAULT_RULE_CONFIG) {
        if (includes_default(this.definedRulesNames, name)) {
          const errMsg = defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({
            topLevelRule: name,
            grammarName: this.className
          });
          const error = {
            message: errMsg,
            type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
            ruleName: name
          };
          this.definitionErrors.push(error);
        }
        this.definedRulesNames.push(name);
        const ruleImplementation = this.defineRule(name, implementation, config);
        this[name] = ruleImplementation;
        return ruleImplementation;
      }
      OVERRIDE_RULE(name, impl, config = DEFAULT_RULE_CONFIG) {
        const ruleErrors = validateRuleIsOverridden(name, this.definedRulesNames, this.className);
        this.definitionErrors = this.definitionErrors.concat(ruleErrors);
        const ruleImplementation = this.defineRule(name, impl, config);
        this[name] = ruleImplementation;
        return ruleImplementation;
      }
      BACKTRACK(grammarRule, args) {
        return function() {
          this.isBackTrackingStack.push(1);
          const orgState = this.saveRecogState();
          try {
            grammarRule.apply(this, args);
            return true;
          } catch (e) {
            if (isRecognitionException(e)) {
              return false;
            } else {
              throw e;
            }
          } finally {
            this.reloadRecogState(orgState);
            this.isBackTrackingStack.pop();
          }
        };
      }
      // GAST export APIs
      getGAstProductions() {
        return this.gastProductionsCache;
      }
      getSerializedGastProductions() {
        return serializeGrammar(values_default(this.gastProductionsCache));
      }
    };
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js
var RecognizerEngine;
var init_recognizer_engine = __esm({
  "node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js"() {
    init_lodash();
    init_keys2();
    init_exceptions_public();
    init_lookahead();
    init_interpreter();
    init_parser();
    init_recoverable();
    init_tokens_public();
    init_tokens();
    RecognizerEngine = class {
      initRecognizerEngine(tokenVocabulary, config) {
        this.className = this.constructor.name;
        this.shortRuleNameToFull = {};
        this.fullRuleNameToShort = {};
        this.ruleShortNameIdx = 256;
        this.tokenMatcher = tokenStructuredMatcherNoCategories;
        this.subruleIdx = 0;
        this.definedRulesNames = [];
        this.tokensMap = {};
        this.isBackTrackingStack = [];
        this.RULE_STACK = [];
        this.RULE_OCCURRENCE_STACK = [];
        this.gastProductionsCache = {};
        if (has_default(config, "serializedGrammar")) {
          throw Error("The Parser's configuration can no longer contain a <serializedGrammar> property.\n	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\n	For Further details.");
        }
        if (isArray_default(tokenVocabulary)) {
          if (isEmpty_default(tokenVocabulary)) {
            throw Error("A Token Vocabulary cannot be empty.\n	Note that the first argument for the parser constructor\n	is no longer a Token vector (since v4.0).");
          }
          if (typeof tokenVocabulary[0].startOffset === "number") {
            throw Error("The Parser constructor no longer accepts a token vector as the first argument.\n	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\n	For Further details.");
          }
        }
        if (isArray_default(tokenVocabulary)) {
          this.tokensMap = reduce_default(tokenVocabulary, (acc, tokType) => {
            acc[tokType.name] = tokType;
            return acc;
          }, {});
        } else if (has_default(tokenVocabulary, "modes") && every_default(flatten_default(values_default(tokenVocabulary.modes)), isTokenType)) {
          const allTokenTypes2 = flatten_default(values_default(tokenVocabulary.modes));
          const uniqueTokens = uniq_default(allTokenTypes2);
          this.tokensMap = reduce_default(uniqueTokens, (acc, tokType) => {
            acc[tokType.name] = tokType;
            return acc;
          }, {});
        } else if (isObject_default(tokenVocabulary)) {
          this.tokensMap = clone_default(tokenVocabulary);
        } else {
          throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");
        }
        this.tokensMap["EOF"] = EOF;
        const allTokenTypes = has_default(tokenVocabulary, "modes") ? flatten_default(values_default(tokenVocabulary.modes)) : values_default(tokenVocabulary);
        const noTokenCategoriesUsed = every_default(allTokenTypes, (tokenConstructor) => isEmpty_default(tokenConstructor.categoryMatches));
        this.tokenMatcher = noTokenCategoriesUsed ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;
        augmentTokenTypes(values_default(this.tokensMap));
      }
      defineRule(ruleName, impl, config) {
        if (this.selfAnalysisDone) {
          throw Error(`Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'
Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);
        }
        const resyncEnabled = has_default(config, "resyncEnabled") ? config.resyncEnabled : DEFAULT_RULE_CONFIG.resyncEnabled;
        const recoveryValueFunc = has_default(config, "recoveryValueFunc") ? config.recoveryValueFunc : DEFAULT_RULE_CONFIG.recoveryValueFunc;
        const shortName = this.ruleShortNameIdx << BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX;
        this.ruleShortNameIdx++;
        this.shortRuleNameToFull[shortName] = ruleName;
        this.fullRuleNameToShort[ruleName] = shortName;
        let invokeRuleWithTry;
        if (this.outputCst === true) {
          invokeRuleWithTry = function invokeRuleWithTry2(...args) {
            try {
              this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);
              impl.apply(this, args);
              const cst = this.CST_STACK[this.CST_STACK.length - 1];
              this.cstPostRule(cst);
              return cst;
            } catch (e) {
              return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
            } finally {
              this.ruleFinallyStateUpdate();
            }
          };
        } else {
          invokeRuleWithTry = function invokeRuleWithTryCst(...args) {
            try {
              this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);
              return impl.apply(this, args);
            } catch (e) {
              return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
            } finally {
              this.ruleFinallyStateUpdate();
            }
          };
        }
        const wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl });
        return wrappedGrammarRule;
      }
      invokeRuleCatch(e, resyncEnabledConfig, recoveryValueFunc) {
        const isFirstInvokedRule = this.RULE_STACK.length === 1;
        const reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;
        if (isRecognitionException(e)) {
          const recogError = e;
          if (reSyncEnabled) {
            const reSyncTokType = this.findReSyncTokenType();
            if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {
              recogError.resyncedTokens = this.reSyncTo(reSyncTokType);
              if (this.outputCst) {
                const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                partialCstResult.recoveredNode = true;
                return partialCstResult;
              } else {
                return recoveryValueFunc(e);
              }
            } else {
              if (this.outputCst) {
                const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                partialCstResult.recoveredNode = true;
                recogError.partialCstResult = partialCstResult;
              }
              throw recogError;
            }
          } else if (isFirstInvokedRule) {
            this.moveToTerminatedState();
            return recoveryValueFunc(e);
          } else {
            throw recogError;
          }
        } else {
          throw e;
        }
      }
      // Implementation of parsing DSL
      optionInternal(actionORMethodDef, occurrence) {
        const key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);
        return this.optionInternalLogic(actionORMethodDef, occurrence, key);
      }
      optionInternalLogic(actionORMethodDef, occurrence, key) {
        let lookAheadFunc = this.getLaFuncFromCache(key);
        let action;
        if (typeof actionORMethodDef !== "function") {
          action = actionORMethodDef.DEF;
          const predicate = actionORMethodDef.GATE;
          if (predicate !== void 0) {
            const orgLookaheadFunction = lookAheadFunc;
            lookAheadFunc = () => {
              return predicate.call(this) && orgLookaheadFunction.call(this);
            };
          }
        } else {
          action = actionORMethodDef;
        }
        if (lookAheadFunc.call(this) === true) {
          return action.call(this);
        }
        return void 0;
      }
      atLeastOneInternal(prodOccurrence, actionORMethodDef) {
        const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);
        return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);
      }
      atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key) {
        let lookAheadFunc = this.getLaFuncFromCache(key);
        let action;
        if (typeof actionORMethodDef !== "function") {
          action = actionORMethodDef.DEF;
          const predicate = actionORMethodDef.GATE;
          if (predicate !== void 0) {
            const orgLookaheadFunction = lookAheadFunc;
            lookAheadFunc = () => {
              return predicate.call(this) && orgLookaheadFunction.call(this);
            };
          }
        } else {
          action = actionORMethodDef;
        }
        if (lookAheadFunc.call(this) === true) {
          let notStuck = this.doSingleRepetition(action);
          while (lookAheadFunc.call(this) === true && notStuck === true) {
            notStuck = this.doSingleRepetition(action);
          }
        } else {
          throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);
        }
        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, AT_LEAST_ONE_IDX, prodOccurrence, NextTerminalAfterAtLeastOneWalker);
      }
      atLeastOneSepFirstInternal(prodOccurrence, options) {
        const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);
        this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);
      }
      atLeastOneSepFirstInternalLogic(prodOccurrence, options, key) {
        const action = options.DEF;
        const separator = options.SEP;
        const firstIterationLookaheadFunc = this.getLaFuncFromCache(key);
        if (firstIterationLookaheadFunc.call(this) === true) {
          action.call(this);
          const separatorLookAheadFunc = () => {
            return this.tokenMatcher(this.LA(1), separator);
          };
          while (this.tokenMatcher(this.LA(1), separator) === true) {
            this.CONSUME(separator);
            action.call(this);
          }
          this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
            prodOccurrence,
            separator,
            separatorLookAheadFunc,
            action,
            NextTerminalAfterAtLeastOneSepWalker
          ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, NextTerminalAfterAtLeastOneSepWalker);
        } else {
          throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);
        }
      }
      manyInternal(prodOccurrence, actionORMethodDef) {
        const laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);
        return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);
      }
      manyInternalLogic(prodOccurrence, actionORMethodDef, key) {
        let lookaheadFunction = this.getLaFuncFromCache(key);
        let action;
        if (typeof actionORMethodDef !== "function") {
          action = actionORMethodDef.DEF;
          const predicate = actionORMethodDef.GATE;
          if (predicate !== void 0) {
            const orgLookaheadFunction = lookaheadFunction;
            lookaheadFunction = () => {
              return predicate.call(this) && orgLookaheadFunction.call(this);
            };
          }
        } else {
          action = actionORMethodDef;
        }
        let notStuck = true;
        while (lookaheadFunction.call(this) === true && notStuck === true) {
          notStuck = this.doSingleRepetition(action);
        }
        this.attemptInRepetitionRecovery(
          this.manyInternal,
          [prodOccurrence, actionORMethodDef],
          lookaheadFunction,
          MANY_IDX,
          prodOccurrence,
          NextTerminalAfterManyWalker,
          // The notStuck parameter is only relevant when "attemptInRepetitionRecovery"
          // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]
          // An infinite loop cannot occur as:
          // - Either the lookahead is guaranteed to consume something (Single Token Separator)
          // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).
          notStuck
        );
      }
      manySepFirstInternal(prodOccurrence, options) {
        const laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);
        this.manySepFirstInternalLogic(prodOccurrence, options, laKey);
      }
      manySepFirstInternalLogic(prodOccurrence, options, key) {
        const action = options.DEF;
        const separator = options.SEP;
        const firstIterationLaFunc = this.getLaFuncFromCache(key);
        if (firstIterationLaFunc.call(this) === true) {
          action.call(this);
          const separatorLookAheadFunc = () => {
            return this.tokenMatcher(this.LA(1), separator);
          };
          while (this.tokenMatcher(this.LA(1), separator) === true) {
            this.CONSUME(separator);
            action.call(this);
          }
          this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
            prodOccurrence,
            separator,
            separatorLookAheadFunc,
            action,
            NextTerminalAfterManySepWalker
          ], separatorLookAheadFunc, MANY_SEP_IDX, prodOccurrence, NextTerminalAfterManySepWalker);
        }
      }
      repetitionSepSecondInternal(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {
        while (separatorLookAheadFunc()) {
          this.CONSUME(separator);
          action.call(this);
        }
        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
          prodOccurrence,
          separator,
          separatorLookAheadFunc,
          action,
          nextTerminalAfterWalker
        ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);
      }
      doSingleRepetition(action) {
        const beforeIteration = this.getLexerPosition();
        action.call(this);
        const afterIteration = this.getLexerPosition();
        return afterIteration > beforeIteration;
      }
      orInternal(altsOrOpts, occurrence) {
        const laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);
        const alts = isArray_default(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;
        const laFunc = this.getLaFuncFromCache(laKey);
        const altIdxToTake = laFunc.call(this, alts);
        if (altIdxToTake !== void 0) {
          const chosenAlternative = alts[altIdxToTake];
          return chosenAlternative.ALT.call(this);
        }
        this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);
      }
      ruleFinallyStateUpdate() {
        this.RULE_STACK.pop();
        this.RULE_OCCURRENCE_STACK.pop();
        this.cstFinallyStateUpdate();
        if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {
          const firstRedundantTok = this.LA(1);
          const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({
            firstRedundant: firstRedundantTok,
            ruleName: this.getCurrRuleFullName()
          });
          this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok));
        }
      }
      subruleInternal(ruleToCall, idx, options) {
        let ruleResult;
        try {
          const args = options !== void 0 ? options.ARGS : void 0;
          this.subruleIdx = idx;
          ruleResult = ruleToCall.apply(this, args);
          this.cstPostNonTerminal(ruleResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleToCall.ruleName);
          return ruleResult;
        } catch (e) {
          throw this.subruleInternalError(e, options, ruleToCall.ruleName);
        }
      }
      subruleInternalError(e, options, ruleName) {
        if (isRecognitionException(e) && e.partialCstResult !== void 0) {
          this.cstPostNonTerminal(e.partialCstResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleName);
          delete e.partialCstResult;
        }
        throw e;
      }
      consumeInternal(tokType, idx, options) {
        let consumedToken;
        try {
          const nextToken = this.LA(1);
          if (this.tokenMatcher(nextToken, tokType) === true) {
            this.consumeToken();
            consumedToken = nextToken;
          } else {
            this.consumeInternalError(tokType, nextToken, options);
          }
        } catch (eFromConsumption) {
          consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);
        }
        this.cstPostTerminal(options !== void 0 && options.LABEL !== void 0 ? options.LABEL : tokType.name, consumedToken);
        return consumedToken;
      }
      consumeInternalError(tokType, nextToken, options) {
        let msg;
        const previousToken = this.LA(0);
        if (options !== void 0 && options.ERR_MSG) {
          msg = options.ERR_MSG;
        } else {
          msg = this.errorMessageProvider.buildMismatchTokenMessage({
            expected: tokType,
            actual: nextToken,
            previous: previousToken,
            ruleName: this.getCurrRuleFullName()
          });
        }
        throw this.SAVE_ERROR(new MismatchedTokenException(msg, nextToken, previousToken));
      }
      consumeInternalRecovery(tokType, idx, eFromConsumption) {
        if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?
        eFromConsumption.name === "MismatchedTokenException" && !this.isBackTracking()) {
          const follows = this.getFollowsForInRuleRecovery(tokType, idx);
          try {
            return this.tryInRuleRecovery(tokType, follows);
          } catch (eFromInRuleRecovery) {
            if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {
              throw eFromConsumption;
            } else {
              throw eFromInRuleRecovery;
            }
          }
        } else {
          throw eFromConsumption;
        }
      }
      saveRecogState() {
        const savedErrors = this.errors;
        const savedRuleStack = clone_default(this.RULE_STACK);
        return {
          errors: savedErrors,
          lexerState: this.exportLexerState(),
          RULE_STACK: savedRuleStack,
          CST_STACK: this.CST_STACK
        };
      }
      reloadRecogState(newState) {
        this.errors = newState.errors;
        this.importLexerState(newState.lexerState);
        this.RULE_STACK = newState.RULE_STACK;
      }
      ruleInvocationStateUpdate(shortName, fullName, idxInCallingRule) {
        this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);
        this.RULE_STACK.push(shortName);
        this.cstInvocationStateUpdate(fullName);
      }
      isBackTracking() {
        return this.isBackTrackingStack.length !== 0;
      }
      getCurrRuleFullName() {
        const shortName = this.getLastExplicitRuleShortName();
        return this.shortRuleNameToFull[shortName];
      }
      shortRuleNameToFullName(shortName) {
        return this.shortRuleNameToFull[shortName];
      }
      isAtEndOfInput() {
        return this.tokenMatcher(this.LA(1), EOF);
      }
      reset() {
        this.resetLexerState();
        this.subruleIdx = 0;
        this.isBackTrackingStack = [];
        this.errors = [];
        this.RULE_STACK = [];
        this.CST_STACK = [];
        this.RULE_OCCURRENCE_STACK = [];
      }
    };
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js
var ErrorHandler;
var init_error_handler = __esm({
  "node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js"() {
    init_exceptions_public();
    init_lodash();
    init_lookahead();
    init_parser();
    ErrorHandler = class {
      initErrorHandler(config) {
        this._errors = [];
        this.errorMessageProvider = has_default(config, "errorMessageProvider") ? config.errorMessageProvider : DEFAULT_PARSER_CONFIG.errorMessageProvider;
      }
      SAVE_ERROR(error) {
        if (isRecognitionException(error)) {
          error.context = {
            ruleStack: this.getHumanReadableRuleStack(),
            ruleOccurrenceStack: clone_default(this.RULE_OCCURRENCE_STACK)
          };
          this._errors.push(error);
          return error;
        } else {
          throw Error("Trying to save an Error which is not a RecognitionException");
        }
      }
      get errors() {
        return clone_default(this._errors);
      }
      set errors(newErrors) {
        this._errors = newErrors;
      }
      // TODO: consider caching the error message computed information
      raiseEarlyExitException(occurrence, prodType, userDefinedErrMsg) {
        const ruleName = this.getCurrRuleFullName();
        const ruleGrammar = this.getGAstProductions()[ruleName];
        const lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, this.maxLookahead);
        const insideProdPaths = lookAheadPathsPerAlternative[0];
        const actualTokens = [];
        for (let i = 1; i <= this.maxLookahead; i++) {
          actualTokens.push(this.LA(i));
        }
        const msg = this.errorMessageProvider.buildEarlyExitMessage({
          expectedIterationPaths: insideProdPaths,
          actual: actualTokens,
          previous: this.LA(0),
          customUserDescription: userDefinedErrMsg,
          ruleName
        });
        throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));
      }
      // TODO: consider caching the error message computed information
      raiseNoAltException(occurrence, errMsgTypes) {
        const ruleName = this.getCurrRuleFullName();
        const ruleGrammar = this.getGAstProductions()[ruleName];
        const lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead);
        const actualTokens = [];
        for (let i = 1; i <= this.maxLookahead; i++) {
          actualTokens.push(this.LA(i));
        }
        const previousToken = this.LA(0);
        const errMsg = this.errorMessageProvider.buildNoViableAltMessage({
          expectedPathsPerAlt: lookAheadPathsPerAlternative,
          actual: actualTokens,
          previous: previousToken,
          customUserDescription: errMsgTypes,
          ruleName: this.getCurrRuleFullName()
        });
        throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken));
      }
    };
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js
var ContentAssist;
var init_context_assist = __esm({
  "node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js"() {
    init_interpreter();
    init_lodash();
    ContentAssist = class {
      initContentAssist() {
      }
      computeContentAssist(startRuleName, precedingInput) {
        const startRuleGast = this.gastProductionsCache[startRuleName];
        if (isUndefined_default(startRuleGast)) {
          throw Error(`Rule ->${startRuleName}<- does not exist in this grammar.`);
        }
        return nextPossibleTokensAfter([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);
      }
      // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...
      // TODO: should this be more explicitly part of the public API?
      getNextPossibleTokenTypes(grammarPath) {
        const topRuleName = head_default(grammarPath.ruleStack);
        const gastProductions = this.getGAstProductions();
        const topProduction = gastProductions[topRuleName];
        const nextPossibleTokenTypes = new NextAfterTokenWalker(topProduction, grammarPath).startWalking();
        return nextPossibleTokenTypes;
      }
    };
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js
function recordProd(prodConstructor, mainProdArg, occurrence, handleSep = false) {
  assertMethodIdxIsValid(occurrence);
  const prevProd = last_default(this.recordingProdStack);
  const grammarAction = isFunction_default(mainProdArg) ? mainProdArg : mainProdArg.DEF;
  const newProd = new prodConstructor({ definition: [], idx: occurrence });
  if (handleSep) {
    newProd.separator = mainProdArg.SEP;
  }
  if (has_default(mainProdArg, "MAX_LOOKAHEAD")) {
    newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
  }
  this.recordingProdStack.push(newProd);
  grammarAction.call(this);
  prevProd.definition.push(newProd);
  this.recordingProdStack.pop();
  return RECORDING_NULL_OBJECT;
}
function recordOrProd(mainProdArg, occurrence) {
  assertMethodIdxIsValid(occurrence);
  const prevProd = last_default(this.recordingProdStack);
  const hasOptions = isArray_default(mainProdArg) === false;
  const alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;
  const newOrProd = new Alternation({
    definition: [],
    idx: occurrence,
    ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true
  });
  if (has_default(mainProdArg, "MAX_LOOKAHEAD")) {
    newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
  }
  const hasPredicates = some_default(alts, (currAlt) => isFunction_default(currAlt.GATE));
  newOrProd.hasPredicates = hasPredicates;
  prevProd.definition.push(newOrProd);
  forEach_default(alts, (currAlt) => {
    const currAltFlat = new Alternative({ definition: [] });
    newOrProd.definition.push(currAltFlat);
    if (has_default(currAlt, "IGNORE_AMBIGUITIES")) {
      currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;
    } else if (has_default(currAlt, "GATE")) {
      currAltFlat.ignoreAmbiguities = true;
    }
    this.recordingProdStack.push(currAltFlat);
    currAlt.ALT.call(this);
    this.recordingProdStack.pop();
  });
  return RECORDING_NULL_OBJECT;
}
function getIdxSuffix(idx) {
  return idx === 0 ? "" : `${idx}`;
}
function assertMethodIdxIsValid(idx) {
  if (idx < 0 || idx > MAX_METHOD_IDX) {
    const error = new Error(
      // The stack trace will contain all the needed details
      `Invalid DSL Method idx value: <${idx}>
	Idx value must be a none negative value smaller than ${MAX_METHOD_IDX + 1}`
    );
    error.KNOWN_RECORDER_ERROR = true;
    throw error;
  }
}
var RECORDING_NULL_OBJECT, HANDLE_SEPARATOR, MAX_METHOD_IDX, RFT, RECORDING_PHASE_TOKEN, RECORDING_PHASE_CSTNODE, GastRecorder;
var init_gast_recorder = __esm({
  "node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js"() {
    init_lodash();
    init_api2();
    init_lexer_public();
    init_tokens();
    init_tokens_public();
    init_parser();
    init_keys2();
    RECORDING_NULL_OBJECT = {
      description: "This Object indicates the Parser is during Recording Phase"
    };
    Object.freeze(RECORDING_NULL_OBJECT);
    HANDLE_SEPARATOR = true;
    MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1;
    RFT = createToken({ name: "RECORDING_PHASE_TOKEN", pattern: Lexer.NA });
    augmentTokenTypes([RFT]);
    RECORDING_PHASE_TOKEN = createTokenInstance(
      RFT,
      "This IToken indicates the Parser is in Recording Phase\n	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",
      // Using "-1" instead of NaN (as in EOF) because an actual number is less likely to
      // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.
      -1,
      -1,
      -1,
      -1,
      -1,
      -1
    );
    Object.freeze(RECORDING_PHASE_TOKEN);
    RECORDING_PHASE_CSTNODE = {
      name: "This CSTNode indicates the Parser is in Recording Phase\n	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",
      children: {}
    };
    GastRecorder = class {
      initGastRecorder(config) {
        this.recordingProdStack = [];
        this.RECORDING_PHASE = false;
      }
      enableRecording() {
        this.RECORDING_PHASE = true;
        this.TRACE_INIT("Enable Recording", () => {
          for (let i = 0; i < 10; i++) {
            const idx = i > 0 ? i : "";
            this[`CONSUME${idx}`] = function(arg1, arg2) {
              return this.consumeInternalRecord(arg1, i, arg2);
            };
            this[`SUBRULE${idx}`] = function(arg1, arg2) {
              return this.subruleInternalRecord(arg1, i, arg2);
            };
            this[`OPTION${idx}`] = function(arg1) {
              return this.optionInternalRecord(arg1, i);
            };
            this[`OR${idx}`] = function(arg1) {
              return this.orInternalRecord(arg1, i);
            };
            this[`MANY${idx}`] = function(arg1) {
              this.manyInternalRecord(i, arg1);
            };
            this[`MANY_SEP${idx}`] = function(arg1) {
              this.manySepFirstInternalRecord(i, arg1);
            };
            this[`AT_LEAST_ONE${idx}`] = function(arg1) {
              this.atLeastOneInternalRecord(i, arg1);
            };
            this[`AT_LEAST_ONE_SEP${idx}`] = function(arg1) {
              this.atLeastOneSepFirstInternalRecord(i, arg1);
            };
          }
          this[`consume`] = function(idx, arg1, arg2) {
            return this.consumeInternalRecord(arg1, idx, arg2);
          };
          this[`subrule`] = function(idx, arg1, arg2) {
            return this.subruleInternalRecord(arg1, idx, arg2);
          };
          this[`option`] = function(idx, arg1) {
            return this.optionInternalRecord(arg1, idx);
          };
          this[`or`] = function(idx, arg1) {
            return this.orInternalRecord(arg1, idx);
          };
          this[`many`] = function(idx, arg1) {
            this.manyInternalRecord(idx, arg1);
          };
          this[`atLeastOne`] = function(idx, arg1) {
            this.atLeastOneInternalRecord(idx, arg1);
          };
          this.ACTION = this.ACTION_RECORD;
          this.BACKTRACK = this.BACKTRACK_RECORD;
          this.LA = this.LA_RECORD;
        });
      }
      disableRecording() {
        this.RECORDING_PHASE = false;
        this.TRACE_INIT("Deleting Recording methods", () => {
          const that = this;
          for (let i = 0; i < 10; i++) {
            const idx = i > 0 ? i : "";
            delete that[`CONSUME${idx}`];
            delete that[`SUBRULE${idx}`];
            delete that[`OPTION${idx}`];
            delete that[`OR${idx}`];
            delete that[`MANY${idx}`];
            delete that[`MANY_SEP${idx}`];
            delete that[`AT_LEAST_ONE${idx}`];
            delete that[`AT_LEAST_ONE_SEP${idx}`];
          }
          delete that[`consume`];
          delete that[`subrule`];
          delete that[`option`];
          delete that[`or`];
          delete that[`many`];
          delete that[`atLeastOne`];
          delete that.ACTION;
          delete that.BACKTRACK;
          delete that.LA;
        });
      }
      //   Parser methods are called inside an ACTION?
      //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?
      // @ts-expect-error -- noop place holder
      ACTION_RECORD(impl) {
      }
      // Executing backtracking logic will break our recording logic assumptions
      BACKTRACK_RECORD(grammarRule, args) {
        return () => true;
      }
      // LA is part of the official API and may be used for custom lookahead logic
      // by end users who may forget to wrap it in ACTION or inside a GATE
      LA_RECORD(howMuch) {
        return END_OF_FILE;
      }
      topLevelRuleRecord(name, def) {
        try {
          const newTopLevelRule = new Rule({ definition: [], name });
          newTopLevelRule.name = name;
          this.recordingProdStack.push(newTopLevelRule);
          def.call(this);
          this.recordingProdStack.pop();
          return newTopLevelRule;
        } catch (originalError) {
          if (originalError.KNOWN_RECORDER_ERROR !== true) {
            try {
              originalError.message = originalError.message + '\n	 This error was thrown during the "grammar recording phase" For more info see:\n	https://chevrotain.io/docs/guide/internals.html#grammar-recording';
            } catch (mutabilityError) {
              throw originalError;
            }
          }
          throw originalError;
        }
      }
      // Implementation of parsing DSL
      optionInternalRecord(actionORMethodDef, occurrence) {
        return recordProd.call(this, Option, actionORMethodDef, occurrence);
      }
      atLeastOneInternalRecord(occurrence, actionORMethodDef) {
        recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence);
      }
      atLeastOneSepFirstInternalRecord(occurrence, options) {
        recordProd.call(this, RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);
      }
      manyInternalRecord(occurrence, actionORMethodDef) {
        recordProd.call(this, Repetition, actionORMethodDef, occurrence);
      }
      manySepFirstInternalRecord(occurrence, options) {
        recordProd.call(this, RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);
      }
      orInternalRecord(altsOrOpts, occurrence) {
        return recordOrProd.call(this, altsOrOpts, occurrence);
      }
      subruleInternalRecord(ruleToCall, occurrence, options) {
        assertMethodIdxIsValid(occurrence);
        if (!ruleToCall || has_default(ruleToCall, "ruleName") === false) {
          const error = new Error(`<SUBRULE${getIdxSuffix(occurrence)}> argument is invalid expecting a Parser method reference but got: <${JSON.stringify(ruleToCall)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`);
          error.KNOWN_RECORDER_ERROR = true;
          throw error;
        }
        const prevProd = last_default(this.recordingProdStack);
        const ruleName = ruleToCall.ruleName;
        const newNoneTerminal = new NonTerminal({
          idx: occurrence,
          nonTerminalName: ruleName,
          label: options === null || options === void 0 ? void 0 : options.LABEL,
          // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created
          referencedRule: void 0
        });
        prevProd.definition.push(newNoneTerminal);
        return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;
      }
      consumeInternalRecord(tokType, occurrence, options) {
        assertMethodIdxIsValid(occurrence);
        if (!hasShortKeyProperty(tokType)) {
          const error = new Error(`<CONSUME${getIdxSuffix(occurrence)}> argument is invalid expecting a TokenType reference but got: <${JSON.stringify(tokType)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`);
          error.KNOWN_RECORDER_ERROR = true;
          throw error;
        }
        const prevProd = last_default(this.recordingProdStack);
        const newNoneTerminal = new Terminal({
          idx: occurrence,
          terminalType: tokType,
          label: options === null || options === void 0 ? void 0 : options.LABEL
        });
        prevProd.definition.push(newNoneTerminal);
        return RECORDING_PHASE_TOKEN;
      }
    };
  }
});

// node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js
var PerformanceTracer;
var init_perf_tracer = __esm({
  "node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js"() {
    init_lodash();
    init_api();
    init_parser();
    PerformanceTracer = class {
      initPerformanceTracer(config) {
        if (has_default(config, "traceInitPerf")) {
          const userTraceInitPerf = config.traceInitPerf;
          const traceIsNumber = typeof userTraceInitPerf === "number";
          this.traceInitMaxIdent = traceIsNumber ? userTraceInitPerf : Infinity;
          this.traceInitPerf = traceIsNumber ? userTraceInitPerf > 0 : userTraceInitPerf;
        } else {
          this.traceInitMaxIdent = 0;
          this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf;
        }
        this.traceInitIndent = -1;
      }
      TRACE_INIT(phaseDesc, phaseImpl) {
        if (this.traceInitPerf === true) {
          this.traceInitIndent++;
          const indent = new Array(this.traceInitIndent + 1).join("	");
          if (this.traceInitIndent < this.traceInitMaxIdent) {
            console.log(`${indent}--> <${phaseDesc}>`);
          }
          const { time, value } = timer(phaseImpl);
          const traceMethod = time > 10 ? console.warn : console.log;
          if (this.traceInitIndent < this.traceInitMaxIdent) {
            traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);
          }
          this.traceInitIndent--;
          return value;
        } else {
          return phaseImpl();
        }
      }
    };
  }
});

// node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js
function applyMixins(derivedCtor, baseCtors) {
  baseCtors.forEach((baseCtor) => {
    const baseProto = baseCtor.prototype;
    Object.getOwnPropertyNames(baseProto).forEach((propName) => {
      if (propName === "constructor") {
        return;
      }
      const basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);
      if (basePropDescriptor && (basePropDescriptor.get || basePropDescriptor.set)) {
        Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);
      } else {
        derivedCtor.prototype[propName] = baseCtor.prototype[propName];
      }
    });
  });
}
var init_apply_mixins = __esm({
  "node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js"() {
  }
});

// node_modules/chevrotain/lib/src/parse/parser/parser.js
var END_OF_FILE, DEFAULT_PARSER_CONFIG, DEFAULT_RULE_CONFIG, ParserDefinitionErrorType, Parser, CstParser;
var init_parser = __esm({
  "node_modules/chevrotain/lib/src/parse/parser/parser.js"() {
    init_lodash();
    init_api();
    init_follow();
    init_tokens_public();
    init_errors_public();
    init_gast_resolver_public();
    init_recoverable();
    init_looksahead();
    init_tree_builder();
    init_lexer_adapter();
    init_recognizer_api();
    init_recognizer_engine();
    init_error_handler();
    init_context_assist();
    init_gast_recorder();
    init_perf_tracer();
    init_apply_mixins();
    init_checks();
    END_OF_FILE = createTokenInstance(EOF, "", NaN, NaN, NaN, NaN, NaN, NaN);
    Object.freeze(END_OF_FILE);
    DEFAULT_PARSER_CONFIG = Object.freeze({
      recoveryEnabled: false,
      maxLookahead: 3,
      dynamicTokensEnabled: false,
      outputCst: true,
      errorMessageProvider: defaultParserErrorProvider,
      nodeLocationTracking: "none",
      traceInitPerf: false,
      skipValidations: false
    });
    DEFAULT_RULE_CONFIG = Object.freeze({
      recoveryValueFunc: () => void 0,
      resyncEnabled: true
    });
    (function(ParserDefinitionErrorType2) {
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["INVALID_RULE_NAME"] = 0] = "INVALID_RULE_NAME";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["DUPLICATE_RULE_NAME"] = 1] = "DUPLICATE_RULE_NAME";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["INVALID_RULE_OVERRIDE"] = 2] = "INVALID_RULE_OVERRIDE";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["DUPLICATE_PRODUCTIONS"] = 3] = "DUPLICATE_PRODUCTIONS";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["UNRESOLVED_SUBRULE_REF"] = 4] = "UNRESOLVED_SUBRULE_REF";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["LEFT_RECURSION"] = 5] = "LEFT_RECURSION";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["NONE_LAST_EMPTY_ALT"] = 6] = "NONE_LAST_EMPTY_ALT";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["AMBIGUOUS_ALTS"] = 7] = "AMBIGUOUS_ALTS";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["CONFLICT_TOKENS_RULES_NAMESPACE"] = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["INVALID_TOKEN_NAME"] = 9] = "INVALID_TOKEN_NAME";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["NO_NON_EMPTY_LOOKAHEAD"] = 10] = "NO_NON_EMPTY_LOOKAHEAD";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["AMBIGUOUS_PREFIX_ALTS"] = 11] = "AMBIGUOUS_PREFIX_ALTS";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["TOO_MANY_ALTS"] = 12] = "TOO_MANY_ALTS";
      ParserDefinitionErrorType2[ParserDefinitionErrorType2["CUSTOM_LOOKAHEAD_VALIDATION"] = 13] = "CUSTOM_LOOKAHEAD_VALIDATION";
    })(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}));
    Parser = class _Parser {
      /**
       *  @deprecated use the **instance** method with the same name instead
       */
      static performSelfAnalysis(parserInstance) {
        throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.");
      }
      performSelfAnalysis() {
        this.TRACE_INIT("performSelfAnalysis", () => {
          let defErrorsMsgs;
          this.selfAnalysisDone = true;
          const className = this.className;
          this.TRACE_INIT("toFastProps", () => {
            toFastProperties(this);
          });
          this.TRACE_INIT("Grammar Recording", () => {
            try {
              this.enableRecording();
              forEach_default(this.definedRulesNames, (currRuleName) => {
                const wrappedRule = this[currRuleName];
                const originalGrammarAction = wrappedRule["originalGrammarAction"];
                let recordedRuleGast;
                this.TRACE_INIT(`${currRuleName} Rule`, () => {
                  recordedRuleGast = this.topLevelRuleRecord(currRuleName, originalGrammarAction);
                });
                this.gastProductionsCache[currRuleName] = recordedRuleGast;
              });
            } finally {
              this.disableRecording();
            }
          });
          let resolverErrors = [];
          this.TRACE_INIT("Grammar Resolving", () => {
            resolverErrors = resolveGrammar2({
              rules: values_default(this.gastProductionsCache)
            });
            this.definitionErrors = this.definitionErrors.concat(resolverErrors);
          });
          this.TRACE_INIT("Grammar Validations", () => {
            if (isEmpty_default(resolverErrors) && this.skipValidations === false) {
              const validationErrors = validateGrammar2({
                rules: values_default(this.gastProductionsCache),
                tokenTypes: values_default(this.tokensMap),
                errMsgProvider: defaultGrammarValidatorErrorProvider,
                grammarName: className
              });
              const lookaheadValidationErrors = validateLookahead({
                lookaheadStrategy: this.lookaheadStrategy,
                rules: values_default(this.gastProductionsCache),
                tokenTypes: values_default(this.tokensMap),
                grammarName: className
              });
              this.definitionErrors = this.definitionErrors.concat(validationErrors, lookaheadValidationErrors);
            }
          });
          if (isEmpty_default(this.definitionErrors)) {
            if (this.recoveryEnabled) {
              this.TRACE_INIT("computeAllProdsFollows", () => {
                const allFollows = computeAllProdsFollows(values_default(this.gastProductionsCache));
                this.resyncFollows = allFollows;
              });
            }
            this.TRACE_INIT("ComputeLookaheadFunctions", () => {
              var _a, _b;
              (_b = (_a = this.lookaheadStrategy).initialize) === null || _b === void 0 ? void 0 : _b.call(_a, {
                rules: values_default(this.gastProductionsCache)
              });
              this.preComputeLookaheadFunctions(values_default(this.gastProductionsCache));
            });
          }
          if (!_Parser.DEFER_DEFINITION_ERRORS_HANDLING && !isEmpty_default(this.definitionErrors)) {
            defErrorsMsgs = map_default(this.definitionErrors, (defError) => defError.message);
            throw new Error(`Parser Definition Errors detected:
 ${defErrorsMsgs.join("\n-------------------------------\n")}`);
          }
        });
      }
      constructor(tokenVocabulary, config) {
        this.definitionErrors = [];
        this.selfAnalysisDone = false;
        const that = this;
        that.initErrorHandler(config);
        that.initLexerAdapter();
        that.initLooksAhead(config);
        that.initRecognizerEngine(tokenVocabulary, config);
        that.initRecoverable(config);
        that.initTreeBuilder(config);
        that.initContentAssist();
        that.initGastRecorder(config);
        that.initPerformanceTracer(config);
        if (has_default(config, "ignoredIssues")) {
          throw new Error("The <ignoredIssues> IParserConfig property has been deprecated.\n	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\n	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\n	For further details.");
        }
        this.skipValidations = has_default(config, "skipValidations") ? config.skipValidations : DEFAULT_PARSER_CONFIG.skipValidations;
      }
    };
    Parser.DEFER_DEFINITION_ERRORS_HANDLING = false;
    applyMixins(Parser, [
      Recoverable,
      LooksAhead,
      TreeBuilder,
      LexerAdapter,
      RecognizerEngine,
      RecognizerApi,
      ErrorHandler,
      ContentAssist,
      GastRecorder,
      PerformanceTracer
    ]);
    CstParser = class extends Parser {
      constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {
        const configClone = clone_default(config);
        configClone.outputCst = true;
        super(tokenVocabulary, configClone);
      }
    };
  }
});

// node_modules/@chevrotain/cst-dts-gen/lib/src/model.js
var init_model2 = __esm({
  "node_modules/@chevrotain/cst-dts-gen/lib/src/model.js"() {
    init_api2();
  }
});

// node_modules/@chevrotain/cst-dts-gen/lib/src/generate.js
var init_generate = __esm({
  "node_modules/@chevrotain/cst-dts-gen/lib/src/generate.js"() {
  }
});

// node_modules/@chevrotain/cst-dts-gen/lib/src/api.js
var init_api4 = __esm({
  "node_modules/@chevrotain/cst-dts-gen/lib/src/api.js"() {
    init_model2();
    init_generate();
  }
});

// node_modules/chevrotain/lib/src/diagrams/render_public.js
var init_render_public = __esm({
  "node_modules/chevrotain/lib/src/diagrams/render_public.js"() {
    init_version();
  }
});

// node_modules/chevrotain/lib/src/api.js
var init_api5 = __esm({
  "node_modules/chevrotain/lib/src/api.js"() {
    init_version();
    init_parser();
    init_lexer_public();
    init_tokens_public();
    init_lookahead();
    init_llk_lookahead();
    init_errors_public();
    init_exceptions_public();
    init_lexer_errors_public();
    init_api2();
    init_api2();
    init_api4();
    init_render_public();
  }
});

// node_modules/generator-begcode/dist/jdl/parsing/lexer/shared-tokens.js
var namePattern, nameTokenConfig, nameToken, keywordTokenConfig, keywordToken, unaryOptionCategoryToken, binaryOptionCategoryToken;
var init_shared_tokens = __esm({
  "node_modules/generator-begcode/dist/jdl/parsing/lexer/shared-tokens.js"() {
    init_api5();
    namePattern = /[a-zA-Z_][a-zA-Z_\-\d]*/;
    nameTokenConfig = { name: "NAME", pattern: namePattern };
    nameToken = createToken(nameTokenConfig);
    keywordTokenConfig = {
      name: "KEYWORD",
      pattern: Lexer.NA,
      longer_alt: nameToken,
      categories: [nameToken]
    };
    keywordToken = createToken(keywordTokenConfig);
    unaryOptionCategoryToken = createToken({ name: "UNARY_OPTION", pattern: Lexer.NA });
    binaryOptionCategoryToken = createToken({ name: "BINARY_OPTION", pattern: Lexer.NA });
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/application-types.js
var APPLICATION_TYPE_MONOLITH, APPLICATION_TYPE_MICROSERVICE, APPLICATION_TYPE_GATEWAY, applicationTypes, application_types_default;
var init_application_types = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/application-types.js"() {
    APPLICATION_TYPE_MONOLITH = "monolith";
    APPLICATION_TYPE_MICROSERVICE = "microservice";
    APPLICATION_TYPE_GATEWAY = "gateway";
    applicationTypes = {
      MONOLITH: APPLICATION_TYPE_MONOLITH,
      MICROSERVICE: APPLICATION_TYPE_MICROSERVICE,
      GATEWAY: APPLICATION_TYPE_GATEWAY
    };
    application_types_default = applicationTypes;
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/authentication-types.js
var authenticationTypes, authentication_types_default;
var init_authentication_types = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/authentication-types.js"() {
    authenticationTypes = {
      JWT: "jwt",
      OAUTH2: "oauth2",
      SESSION: "session"
    };
    authentication_types_default = authenticationTypes;
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/database-types.js
function _0xfd35(_0x2588c7, _0x39612e) {
  const _0xfd3572 = _0x3961();
  _0xfd35 = function(_0x21cc79, _0x225283) {
    _0x21cc79 = _0x21cc79 - 0;
    let _0x570d48 = _0xfd3572[_0x21cc79];
    return _0x570d48;
  };
  return _0xfd35(_0x2588c7, _0x39612e);
}
function _0x3961() {
  const _0x262083 = ["687000mgWJjO", "cassandra", "hfgkcB855041".split("").reverse().join(""), "ucKgBR425".split("").reverse().join(""), "gbase", "h2Memory", "bdognom".split("").reverse().join(""), "j4oen".split("").reverse().join(""), "elcaro".split("").reverse().join(""), "mssql", "YBDuii847191".split("").reverse().join(""), "IxQzvq6".split("").reverse().join(""), "isSql", "Ujypig649089".split("").reverse().join(""), "lqs".split("").reverse().join(""), "bdairam".split("").reverse().join(""), "gnotnehs".split("").reverse().join(""), "4896793zMIEEJ", "esabhcuoc".split("").reverse().join(""), "sedulcni".split("").reverse().join(""), "5065kshghM", "35XcQcNR", "openGauss", "postgresql", "gnemad".split("").reverse().join(""), "10AlXYsN", "esabgnik".split("").reverse().join(""), "lqsym".split("").reverse().join(""), "ksiD2h".split("").reverse().join(""), "208438WczCrF"];
  _0x3961 = function() {
    return _0x262083;
  };
  return _0x3961();
}
var _0x5bf3dd, SQL, MYSQL, MARIADB, POSTGRESQL, MSSQL, ORACLE, H2_DISK, H2_MEMORY, DA_MENG, GBASE, KING_BASE, SHEN_TONG, OPEN_GAUSS, databaseTypes, database_types_default;
var init_database_types = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/database-types.js"() {
    _0x5bf3dd = _0xfd35;
    (function(_0x3b8a4b, _0x6699a0) {
      const _0x19b554 = _0xfd35;
      const _0x4e83b5 = _0x3b8a4b();
      while (!![]) {
        try {
          const _0x1a9c1f = parseInt(_0x19b554(16)) / 1 + -parseInt(_0x19b554(13)) / 2 * (-parseInt(_0x19b554(25)) / 3) + -parseInt(_0x19b554(17)) / 4 * (parseInt(_0x19b554(4)) / 5) + parseInt(_0x19b554(24)) / 6 * (parseInt(_0x19b554(5)) / 7) + parseInt(_0x19b554(14)) / 8 + parseInt(_0x19b554(27)) / 9 * (parseInt(_0x19b554(9)) / 10) + -parseInt(_0x19b554(1)) / 11;
          if (_0x1a9c1f === _0x6699a0) {
            break;
          } else {
            _0x4e83b5["push"](_0x4e83b5["shift"]());
          }
        } catch (_0x581bb1) {
          _0x4e83b5["push"](_0x4e83b5["shift"]());
        }
      }
    })(_0x3961, 125789);
    SQL = _0x5bf3dd(28);
    MYSQL = _0x5bf3dd(11);
    MARIADB = _0x5bf3dd(29);
    POSTGRESQL = _0x5bf3dd(7);
    MSSQL = _0x5bf3dd(23);
    ORACLE = _0x5bf3dd(22);
    H2_DISK = _0x5bf3dd(12);
    H2_MEMORY = _0x5bf3dd(19);
    DA_MENG = _0x5bf3dd(8);
    GBASE = _0x5bf3dd(18);
    KING_BASE = _0x5bf3dd(10);
    SHEN_TONG = _0x5bf3dd(0);
    OPEN_GAUSS = _0x5bf3dd(6);
    databaseTypes = { "SQL": SQL, "MYSQL": MYSQL, "MARIADB": MARIADB, "POSTGRESQL": POSTGRESQL, "MSSQL": MSSQL, "ORACLE": ORACLE, "MONGODB": _0x5bf3dd(20), "CASSANDRA": _0x5bf3dd(15), "COUCHBASE": _0x5bf3dd(2), "NEO4J": _0x5bf3dd(21), "H2_DISK": H2_DISK, "H2_MEMORY": H2_MEMORY, "NO": "no", "DA_MENG": DA_MENG, "GBASE": GBASE, "KING_BASE": KING_BASE, "SHEN_TONG": SHEN_TONG, "OPEN_GAUSS": OPEN_GAUSS };
    databaseTypes["isSql"] = (_0x567d79) => [SQL, MYSQL, POSTGRESQL, ORACLE, MARIADB, MSSQL, H2_DISK, H2_MEMORY, DA_MENG, GBASE, KING_BASE, SHEN_TONG, OPEN_GAUSS]["includes"](_0x567d79);
    database_types_default = databaseTypes;
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/cache-types.js
var cacheTypes, cache_types_default;
var init_cache_types = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/cache-types.js"() {
    cacheTypes = {
      CAFFEINE: "caffeine",
      EHCACHE: "ehcache",
      HAZELCAST: "hazelcast",
      INFINISPAN: "infinispan",
      MEMCACHED: "memcached",
      REDIS: "redis",
      NO: "no"
    };
    cache_types_default = cacheTypes;
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/service-discovery-types.js
var serviceDiscoveryTypes, service_discovery_types_default;
var init_service_discovery_types = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/service-discovery-types.js"() {
    serviceDiscoveryTypes = {
      EUREKA: "eureka",
      CONSUL: "consul",
      NO: "no"
    };
    service_discovery_types_default = serviceDiscoveryTypes;
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/client-framework-types.js
var clientFrameworkTypes, client_framework_types_default;
var init_client_framework_types = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/client-framework-types.js"() {
    clientFrameworkTypes = {
      ANGULAR: "angular",
      REACT: "react",
      VUE: "vue",
      SVELTE: "svelte",
      NO: "no",
      MOBILE: "mobile"
    };
    client_framework_types_default = clientFrameworkTypes;
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/build-tool-types.js
var buildToolTypes, build_tool_types_default;
var init_build_tool_types = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/build-tool-types.js"() {
    buildToolTypes = {
      MAVEN: "maven",
      GRADLE: "gradle"
    };
    build_tool_types_default = buildToolTypes;
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/search-engine-types.js
var searchEngineTypes, search_engine_types_default;
var init_search_engine_types = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/search-engine-types.js"() {
    searchEngineTypes = {
      ELASTICSEARCH: "elasticsearch",
      COUCHBASE: "couchbase",
      NO: "no"
    };
    search_engine_types_default = searchEngineTypes;
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/test-framework-types.js
var testFrameworkTypes, test_framework_types_default;
var init_test_framework_types = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/test-framework-types.js"() {
    testFrameworkTypes = {
      CYPRESS: "cypress",
      CUCUMBER: "cucumber",
      GATLING: "gatling",
      NO: "no"
    };
    test_framework_types_default = testFrameworkTypes;
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/websocket-types.js
var websocketTypes, websocket_types_default;
var init_websocket_types = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/websocket-types.js"() {
    websocketTypes = {
      SPRING_WEBSOCKET: "spring-websocket",
      NO: "no"
    };
    websocket_types_default = websocketTypes;
  }
});

// node_modules/generator-begcode/dist/generators/server/options/database-migration.js
var DATABASE_MIGRATION, DATABASE_MIGRATION_LIQUIBASE, ALPHANUMERIC_PATTERN, optionDefinition, database_migration_default;
var init_database_migration = __esm({
  "node_modules/generator-begcode/dist/generators/server/options/database-migration.js"() {
    DATABASE_MIGRATION = "databaseMigration";
    DATABASE_MIGRATION_LIQUIBASE = "liquibase";
    ALPHANUMERIC_PATTERN = /^[A-Za-z][A-Za-z0-9]*$/;
    optionDefinition = {
      name: DATABASE_MIGRATION,
      type: "string",
      tokenType: "NAME",
      tokenValuePattern: ALPHANUMERIC_PATTERN,
      knownChoices: [DATABASE_MIGRATION_LIQUIBASE]
    };
    database_migration_default = optionDefinition;
  }
});

// node_modules/generator-begcode/dist/generators/server/options/message-broker.js
var MESSAGE_BROKER, MESSAGE_BROKER_KAFKA, MESSAGE_BROKER_PULSAR, MESSAGE_BROKER_NO, ALPHANUMERIC_PATTERN2, optionDefinition2, message_broker_default;
var init_message_broker = __esm({
  "node_modules/generator-begcode/dist/generators/server/options/message-broker.js"() {
    MESSAGE_BROKER = "messageBroker";
    MESSAGE_BROKER_KAFKA = "kafka";
    MESSAGE_BROKER_PULSAR = "pulsar";
    MESSAGE_BROKER_NO = "no";
    ALPHANUMERIC_PATTERN2 = /^[A-Za-z][A-Za-z0-9]*$/;
    optionDefinition2 = {
      name: MESSAGE_BROKER,
      type: "string",
      tokenType: "NAME",
      tokenValuePattern: ALPHANUMERIC_PATTERN2,
      knownChoices: [MESSAGE_BROKER_NO, MESSAGE_BROKER_KAFKA, MESSAGE_BROKER_PULSAR]
    };
    message_broker_default = optionDefinition2;
  }
});

// node_modules/generator-begcode/dist/generators/server/options/feign-client.js
var FEIGN_CLIENT, feignClientDefinition;
var init_feign_client = __esm({
  "node_modules/generator-begcode/dist/generators/server/options/feign-client.js"() {
    FEIGN_CLIENT = "feignClient";
    feignClientDefinition = {
      name: FEIGN_CLIENT,
      type: "boolean",
      tokenType: "BOOLEAN"
    };
  }
});

// node_modules/generator-begcode/dist/generators/server/options/sync-user-with-idp.js
var SYNC_USER_WITH_IDP, syncUserWithIdpDefinition;
var init_sync_user_with_idp = __esm({
  "node_modules/generator-begcode/dist/generators/server/options/sync-user-with-idp.js"() {
    SYNC_USER_WITH_IDP = "syncUserWithIdp";
    syncUserWithIdpDefinition = {
      name: SYNC_USER_WITH_IDP,
      type: "boolean",
      tokenType: "BOOLEAN"
    };
  }
});

// node_modules/generator-begcode/dist/generators/server/options/index.js
var init_options = __esm({
  "node_modules/generator-begcode/dist/generators/server/options/index.js"() {
    init_database_migration();
    init_message_broker();
    init_feign_client();
    init_sync_user_with_idp();
  }
});

// node_modules/generator-begcode/dist/generators/server/jdl/application-definition.js
var jdlOptions, applicationConfig, application_definition_default;
var init_application_definition = __esm({
  "node_modules/generator-begcode/dist/generators/server/jdl/application-definition.js"() {
    init_lodash();
    init_database_migration();
    init_message_broker();
    init_options();
    jdlOptions = [
      database_migration_default,
      message_broker_default,
      feignClientDefinition,
      syncUserWithIdpDefinition
    ];
    applicationConfig = {
      tokenConfigs: jdlOptions.map((option) => ({
        name: upperCase_default(snakeCase_default(option.name)),
        pattern: option.name
      })),
      validatorConfig: Object.fromEntries(jdlOptions.map((option) => [
        upperCase_default(snakeCase_default(option.name)),
        {
          type: option.tokenType,
          pattern: option.tokenValuePattern,
          msg: `${option.name} property`
        }
      ])),
      optionsValues: Object.fromEntries(jdlOptions.filter((option) => option.knownChoices).map((option) => [option.name, Object.fromEntries(option.knownChoices.map((choice) => [choice, choice]))])),
      optionsTypes: Object.fromEntries(jdlOptions.map((option) => [
        option.name,
        {
          type: message_broker_default.type
        }
      ]))
    };
    application_definition_default = applicationConfig;
  }
});

// node_modules/generator-begcode/dist/generators/server/jdl/index.js
var init_jdl = __esm({
  "node_modules/generator-begcode/dist/generators/server/jdl/index.js"() {
    init_application_definition();
  }
});

// node_modules/generator-begcode/dist/generators/app/jdl/application-options.js
var init_application_options = __esm({
  "node_modules/generator-begcode/dist/generators/app/jdl/application-options.js"() {
    init_jdl();
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/orm-tool-types.js
var ormToolTypes, orm_tool_types_default;
var init_orm_tool_types = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/orm-tool-types.js"() {
    ormToolTypes = {
      HIBERNATE: "hibernate",
      MYBATIS: "mybatis"
    };
    orm_tool_types_default = ormToolTypes;
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/front-or-back.types.js
var frontOrBackTypes, front_or_back_types_default;
var init_front_or_back_types = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/front-or-back.types.js"() {
    frontOrBackTypes = {
      FRONT: "front",
      BACK: "back"
    };
    front_or_back_types_default = frontOrBackTypes;
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/workflow-types.js
var workflowTypes, workflow_types_default;
var init_workflow_types = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/workflow-types.js"() {
    workflowTypes = {
      FLOWABLE: "flowable",
      CAMUNDA: "camunda"
    };
    workflow_types_default = workflowTypes;
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/application-options.js
var GATEWAY, MONOLITH, MICROSERVICE, CASSANDRA, COUCHBASE, MARIADB2, MONGODB, MSSQL2, MYSQL2, NEO4J, ORACLE2, POSTGRESQL2, SQL2, H2_DISK2, H2_MEMORY2, NO_DATABASE, JWT, OAUTH2, SESSION, MAVEN, GRADLE, CAFFEINE, EHCACHE, HAZELCAST, INFINISPAN, MEMCACHED, REDIS, NO_CACHE_PROVIDER, CYPRESS, CUCUMBER, GATLING, ANGULAR, REACT, VUE, SVELTE, NO, ELASTICSEARCH, NO_SEARCH_ENGINE, COUCHBASE_SEARCH_ENGINE, EUREKA, CONSUL, NO_SERVICE_DISCOVERY, SPRING_WEBSOCKET, NO_WEBSOCKET, HIBERNATE, MYBATIS, FRONT, BACK, FLOWABLE, CAMUNDA, ApplicationOptionTypes, optionNames, jhipsterOptionValues, jhipsterOptionTypes, jhipsterQuotedOptionNames, OptionNames, OptionValues, application_options_default;
var init_application_options2 = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/application-options.js"() {
    init_application_types();
    init_authentication_types();
    init_database_types();
    init_cache_types();
    init_service_discovery_types();
    init_client_framework_types();
    init_build_tool_types();
    init_search_engine_types();
    init_test_framework_types();
    init_websocket_types();
    init_application_options();
    init_orm_tool_types();
    init_front_or_back_types();
    init_workflow_types();
    ({ GATEWAY, MONOLITH, MICROSERVICE } = application_types_default);
    ({ CASSANDRA, COUCHBASE, MARIADB: MARIADB2, MONGODB, MSSQL: MSSQL2, MYSQL: MYSQL2, NEO4J, ORACLE: ORACLE2, POSTGRESQL: POSTGRESQL2, SQL: SQL2, H2_DISK: H2_DISK2, H2_MEMORY: H2_MEMORY2 } = database_types_default);
    NO_DATABASE = database_types_default.NO;
    ({ JWT, OAUTH2, SESSION } = authentication_types_default);
    ({ MAVEN, GRADLE } = build_tool_types_default);
    ({ CAFFEINE, EHCACHE, HAZELCAST, INFINISPAN, MEMCACHED, REDIS } = cache_types_default);
    NO_CACHE_PROVIDER = cache_types_default.NO;
    ({ CYPRESS, CUCUMBER, GATLING } = test_framework_types_default);
    ({ ANGULAR, REACT, VUE, SVELTE, NO } = client_framework_types_default);
    ({ ELASTICSEARCH } = search_engine_types_default);
    NO_SEARCH_ENGINE = search_engine_types_default.NO;
    COUCHBASE_SEARCH_ENGINE = search_engine_types_default.COUCHBASE;
    ({ EUREKA, CONSUL } = service_discovery_types_default);
    NO_SERVICE_DISCOVERY = service_discovery_types_default.NO;
    ({ SPRING_WEBSOCKET } = websocket_types_default);
    NO_WEBSOCKET = websocket_types_default.NO;
    ({ HIBERNATE, MYBATIS } = orm_tool_types_default);
    ({ FRONT, BACK } = front_or_back_types_default);
    ({ FLOWABLE, CAMUNDA } = workflow_types_default);
    ApplicationOptionTypes = {
      STRING: "string",
      INTEGER: "integer",
      BOOLEAN: "boolean",
      LIST: "list"
    };
    optionNames = {
      APPLICATION_TYPE: "applicationType",
      AUTHENTICATION_TYPE: "authenticationType",
      BASE_NAME: "baseName",
      BLUEPRINT: "blueprint",
      BLUEPRINTS: "blueprints",
      BUILD_TOOL: "buildTool",
      CACHE_PROVIDER: "cacheProvider",
      CLIENT_FRAMEWORK: "clientFramework",
      CLIENT_PACKAGE_MANAGER: "clientPackageManager",
      CLIENT_THEME: "clientTheme",
      CLIENT_THEME_VARIANT: "clientThemeVariant",
      WITH_ADMIN_UI: "withAdminUi",
      CREATION_TIMESTAMP: "creationTimestamp",
      DATABASE_TYPE: "databaseType",
      DEV_DATABASE_TYPE: "devDatabaseType",
      DTO_SUFFIX: "dtoSuffix",
      EMBEDDABLE_LAUNCH_SCRIPT: "embeddableLaunchScript",
      ENABLE_HIBERNATE_CACHE: "enableHibernateCache",
      ENABLE_SWAGGER_CODEGEN: "enableSwaggerCodegen",
      ENABLE_TRANSLATION: "enableTranslation",
      ENTITY_SUFFIX: "entitySuffix",
      EXPERIMENTAL: "experimental",
      GATEWAY_SERVER_PORT: "gatewayServerPort",
      I_18_N: "i18N",
      INSTALL_MODULES: "installModules",
      JHI_PREFIX: "jhiPrefix",
      JHIPSTER_VERSION: "jhipsterVersion",
      JWT_SECRET_KEY: "jwtSecretKey",
      LANGUAGES: "languages",
      MICROFRONTEND: "microfrontend",
      MICROFRONTENDS: "microfrontends",
      NATIVE_LANGUAGE: "nativeLanguage",
      NPM: "npm",
      PACKAGE_NAME: "packageName",
      PACKAGE_FOLDER: "packageFolder",
      PROD_DATABASE_TYPE: "prodDatabaseType",
      REACTIVE: "reactive",
      REMEMBER_ME_KEY: "rememberMeKey",
      SEARCH_ENGINE: "searchEngine",
      SERVER_PORT: "serverPort",
      SERVICE_DISCOVERY_TYPE: "serviceDiscoveryType",
      SKIP_CLIENT: "skipClient",
      SKIP_GIT: "skipGit",
      SKIP_INSTALL: "skipInstall",
      SKIP_SERVER: "skipServer",
      SKIP_USER_MANAGEMENT: "skipUserManagement",
      TEST_FRAMEWORKS: "testFrameworks",
      WEBSOCKET: "websocket",
      ENABLE_GRADLE_ENTERPRISE: "enableGradleEnterprise",
      GRADLE_ENTERPRISE_HOST: "gradleEnterpriseHost",
      USER_ID_TYPE: "userIdType",
      SKIP_INIT_JDL: "skipInitJdl",
      MOBILE_FRAMEWORK: "mobileFramework",
      MOBILE_THEME: "mobileTheme",
      WITH_WEBSITE: "withWebsite",
      ORM_TOOL: "ormTool",
      BUILT_IN_SERVICES: "builtInServices",
      FRONT_OR_BACK: "frontOrBack",
      JOB_SCHEDULER: "jobScheduler",
      USE_LOMBOK: "useLombok",
      MULTI_MODULE: "multiModule",
      USE_COMMON_TABLE: "useCommonTable",
      USE_MULTI_TENANT: "useMultiTenant",
      SOFT_DELETE: "softDelete",
      JAVA_VERSION: "javaVersion",
      WORKFLOW: "workflow"
    };
    jhipsterOptionValues = {
      [optionNames.APPLICATION_TYPE]: {
        [MONOLITH]: MONOLITH,
        [MICROSERVICE]: MICROSERVICE,
        [GATEWAY]: GATEWAY
      },
      [optionNames.AUTHENTICATION_TYPE]: {
        [JWT]: JWT,
        [OAUTH2]: OAUTH2,
        [SESSION]: SESSION
      },
      [optionNames.BASE_NAME]: "begcode",
      [optionNames.BLUEPRINT]: void 0,
      [optionNames.BLUEPRINTS]: [],
      [optionNames.BUILD_TOOL]: {
        [MAVEN]: MAVEN,
        [GRADLE]: GRADLE
      },
      [optionNames.CACHE_PROVIDER]: {
        [CAFFEINE]: CAFFEINE,
        [EHCACHE]: EHCACHE,
        [HAZELCAST]: HAZELCAST,
        [INFINISPAN]: INFINISPAN,
        [MEMCACHED]: MEMCACHED,
        [REDIS]: REDIS,
        [NO_CACHE_PROVIDER]: NO_CACHE_PROVIDER
      },
      [optionNames.CLIENT_FRAMEWORK]: {
        [ANGULAR]: ANGULAR,
        [REACT]: REACT,
        [VUE]: VUE,
        [SVELTE]: SVELTE,
        [NO]: NO
      },
      [optionNames.CLIENT_PACKAGE_MANAGER]: {
        npm: "npm",
        pnpm: "pnpm"
      },
      [optionNames.CLIENT_THEME]: "vben",
      [optionNames.DATABASE_TYPE]: {
        [SQL2]: SQL2,
        [MONGODB]: MONGODB,
        [CASSANDRA]: CASSANDRA,
        [COUCHBASE]: COUCHBASE,
        [NEO4J]: NEO4J,
        [NO_DATABASE]: NO_DATABASE
      },
      [optionNames.DEV_DATABASE_TYPE]: {
        [H2_DISK2]: H2_DISK2,
        [H2_MEMORY2]: H2_MEMORY2,
        [MYSQL2]: MYSQL2,
        [MARIADB2]: MARIADB2,
        [POSTGRESQL2]: POSTGRESQL2,
        [ORACLE2]: ORACLE2,
        [MSSQL2]: MSSQL2
      },
      [optionNames.DTO_SUFFIX]: "DTO",
      [optionNames.EMBEDDABLE_LAUNCH_SCRIPT]: true,
      [optionNames.ENABLE_HIBERNATE_CACHE]: true,
      [optionNames.ENABLE_SWAGGER_CODEGEN]: false,
      [optionNames.ENABLE_TRANSLATION]: true,
      [optionNames.ENTITY_SUFFIX]: "",
      [optionNames.EXPERIMENTAL]: false,
      [optionNames.I_18_N]: true,
      [optionNames.INSTALL_MODULES]: false,
      [optionNames.JHI_PREFIX]: "jhi",
      [optionNames.JHIPSTER_VERSION]: "",
      [optionNames.JWT_SECRET_KEY]: "",
      [optionNames.LANGUAGES]: [],
      [optionNames.MICROFRONTEND]: false,
      [optionNames.MICROFRONTENDS]: [],
      [optionNames.NPM]: true,
      [optionNames.PACKAGE_FOLDER]: "com/mycompany/myapp",
      [optionNames.PACKAGE_NAME]: "com.mycompany.myapp",
      [optionNames.PROD_DATABASE_TYPE]: {
        [MYSQL2]: MYSQL2,
        [MARIADB2]: MARIADB2,
        [POSTGRESQL2]: POSTGRESQL2,
        [ORACLE2]: ORACLE2,
        [MSSQL2]: MSSQL2,
        [NO_DATABASE]: NO_DATABASE
      },
      [optionNames.REACTIVE]: false,
      [optionNames.REMEMBER_ME_KEY]: "",
      [optionNames.SEARCH_ENGINE]: {
        [ELASTICSEARCH]: ELASTICSEARCH,
        [COUCHBASE_SEARCH_ENGINE]: COUCHBASE_SEARCH_ENGINE,
        [NO_SEARCH_ENGINE]: NO_SEARCH_ENGINE
      },
      [optionNames.SERVER_PORT]: 8080,
      [optionNames.SERVICE_DISCOVERY_TYPE]: {
        [EUREKA]: EUREKA,
        [CONSUL]: CONSUL,
        [NO_SERVICE_DISCOVERY]: NO_SERVICE_DISCOVERY
      },
      [optionNames.SKIP_CLIENT]: false,
      [optionNames.SKIP_GIT]: false,
      [optionNames.SKIP_INSTALL]: false,
      [optionNames.SKIP_SERVER]: false,
      [optionNames.SKIP_USER_MANAGEMENT]: false,
      [optionNames.TEST_FRAMEWORKS]: {
        [CYPRESS]: CYPRESS,
        [CUCUMBER]: CUCUMBER,
        [GATLING]: GATLING
      },
      [optionNames.WEBSOCKET]: {
        [SPRING_WEBSOCKET]: SPRING_WEBSOCKET,
        no: NO_WEBSOCKET
      },
      [optionNames.WITH_ADMIN_UI]: true,
      [optionNames.ENABLE_GRADLE_ENTERPRISE]: false,
      [optionNames.GRADLE_ENTERPRISE_HOST]: "",
      [optionNames.SKIP_INIT_JDL]: false,
      [optionNames.WITH_WEBSITE]: false,
      [optionNames.ORM_TOOL]: {
        [HIBERNATE]: HIBERNATE,
        [MYBATIS]: MYBATIS
      },
      [optionNames.BUILT_IN_SERVICES]: [],
      [optionNames.USER_ID_TYPE]: {
        long: "long",
        string: "string",
        uuid: "uuid"
      },
      [optionNames.FRONT_OR_BACK]: {
        [FRONT]: FRONT,
        [BACK]: BACK
      },
      [optionNames.USE_LOMBOK]: true,
      [optionNames.MULTI_MODULE]: false,
      [optionNames.USE_COMMON_TABLE]: false,
      [optionNames.USE_MULTI_TENANT]: false,
      [optionNames.SOFT_DELETE]: false,
      [optionNames.JAVA_VERSION]: "17",
      [optionNames.WORKFLOW]: {
        [FLOWABLE]: FLOWABLE,
        [CAMUNDA]: CAMUNDA
      },
      ...application_definition_default.optionsValues
    };
    jhipsterOptionTypes = {
      [optionNames.APPLICATION_TYPE]: { type: ApplicationOptionTypes.STRING },
      [optionNames.AUTHENTICATION_TYPE]: { type: ApplicationOptionTypes.STRING },
      [optionNames.BASE_NAME]: { type: ApplicationOptionTypes.STRING },
      [optionNames.BLUEPRINT]: { type: ApplicationOptionTypes.STRING },
      [optionNames.BLUEPRINTS]: { type: ApplicationOptionTypes.LIST },
      [optionNames.BUILD_TOOL]: { type: ApplicationOptionTypes.STRING },
      [optionNames.CACHE_PROVIDER]: { type: ApplicationOptionTypes.STRING },
      [optionNames.CLIENT_FRAMEWORK]: { type: ApplicationOptionTypes.STRING },
      [optionNames.CLIENT_PACKAGE_MANAGER]: { type: ApplicationOptionTypes.STRING },
      [optionNames.CLIENT_THEME]: { type: ApplicationOptionTypes.STRING },
      [optionNames.CLIENT_THEME_VARIANT]: { type: ApplicationOptionTypes.STRING },
      [optionNames.CREATION_TIMESTAMP]: { type: ApplicationOptionTypes.INTEGER },
      [optionNames.DATABASE_TYPE]: { type: ApplicationOptionTypes.STRING },
      [optionNames.DEV_DATABASE_TYPE]: { type: ApplicationOptionTypes.STRING },
      [optionNames.DTO_SUFFIX]: { type: ApplicationOptionTypes.STRING },
      [optionNames.EMBEDDABLE_LAUNCH_SCRIPT]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.ENABLE_HIBERNATE_CACHE]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.ENABLE_SWAGGER_CODEGEN]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.ENABLE_TRANSLATION]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.ENTITY_SUFFIX]: { type: ApplicationOptionTypes.STRING },
      [optionNames.EXPERIMENTAL]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.GATEWAY_SERVER_PORT]: { type: ApplicationOptionTypes.INTEGER },
      [optionNames.I_18_N]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.INSTALL_MODULES]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.JHI_PREFIX]: { type: ApplicationOptionTypes.STRING },
      [optionNames.JHIPSTER_VERSION]: { type: ApplicationOptionTypes.STRING },
      [optionNames.JWT_SECRET_KEY]: { type: ApplicationOptionTypes.STRING },
      [optionNames.LANGUAGES]: { type: ApplicationOptionTypes.LIST },
      [optionNames.MICROFRONTEND]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.MICROFRONTENDS]: { type: ApplicationOptionTypes.LIST },
      [optionNames.NATIVE_LANGUAGE]: { type: ApplicationOptionTypes.STRING },
      [optionNames.NPM]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.PACKAGE_NAME]: { type: ApplicationOptionTypes.STRING },
      [optionNames.PACKAGE_FOLDER]: { type: ApplicationOptionTypes.STRING },
      [optionNames.PROD_DATABASE_TYPE]: { type: ApplicationOptionTypes.STRING },
      [optionNames.REACTIVE]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.REMEMBER_ME_KEY]: { type: ApplicationOptionTypes.STRING },
      [optionNames.SEARCH_ENGINE]: { type: ApplicationOptionTypes.STRING },
      [optionNames.SERVER_PORT]: { type: ApplicationOptionTypes.INTEGER },
      [optionNames.SERVICE_DISCOVERY_TYPE]: { type: ApplicationOptionTypes.STRING },
      [optionNames.SKIP_CLIENT]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.SKIP_GIT]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.SKIP_INSTALL]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.SKIP_SERVER]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.SKIP_USER_MANAGEMENT]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.TEST_FRAMEWORKS]: { type: ApplicationOptionTypes.LIST },
      [optionNames.WEBSOCKET]: { type: ApplicationOptionTypes.STRING },
      [optionNames.WITH_ADMIN_UI]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.ENABLE_GRADLE_ENTERPRISE]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.GRADLE_ENTERPRISE_HOST]: { type: ApplicationOptionTypes.STRING },
      [optionNames.WITH_WEBSITE]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.ORM_TOOL]: { type: ApplicationOptionTypes.STRING },
      [optionNames.BUILT_IN_SERVICES]: { type: ApplicationOptionTypes.LIST },
      [optionNames.USER_ID_TYPE]: { type: ApplicationOptionTypes.STRING },
      [optionNames.SKIP_INIT_JDL]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.FRONT_OR_BACK]: { type: ApplicationOptionTypes.STRING },
      [optionNames.WORKFLOW]: { type: ApplicationOptionTypes.STRING },
      [optionNames.USE_COMMON_TABLE]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.USE_MULTI_TENANT]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.ORM_TOOL]: { type: ApplicationOptionTypes.STRING },
      [optionNames.SOFT_DELETE]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.JAVA_VERSION]: { type: ApplicationOptionTypes.STRING },
      [optionNames.JOB_SCHEDULER]: { type: ApplicationOptionTypes.STRING },
      [optionNames.MULTI_MODULE]: { type: ApplicationOptionTypes.BOOLEAN },
      [optionNames.USE_LOMBOK]: { type: ApplicationOptionTypes.BOOLEAN },
      ...application_definition_default.optionsTypes
    };
    jhipsterQuotedOptionNames = [
      optionNames.JHIPSTER_VERSION,
      optionNames.REMEMBER_ME_KEY,
      optionNames.JWT_SECRET_KEY,
      optionNames.GRADLE_ENTERPRISE_HOST
    ];
    OptionNames = optionNames;
    OptionValues = jhipsterOptionValues;
    application_options_default = {
      OptionNames,
      OptionValues,
      QuotedOptionNames: jhipsterQuotedOptionNames
    };
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/default-application-options.js
var default_application_options_exports = {};
__export(default_application_options_exports, {
  getConfigForAuthenticationType: () => getConfigForAuthenticationType,
  getConfigForCacheProvider: () => getConfigForCacheProvider,
  getConfigForClientApplication: () => getConfigForClientApplication,
  getConfigForDatabaseType: () => getConfigForDatabaseType,
  getConfigForGatewayApplication: () => getConfigForGatewayApplication,
  getConfigForMicroserviceApplication: () => getConfigForMicroserviceApplication,
  getConfigForMonolithApplication: () => getConfigForMonolithApplication,
  getConfigForPackageName: () => getConfigForPackageName,
  getConfigForReactive: () => getConfigForReactive,
  getConfigForTranslation: () => getConfigForTranslation,
  getConfigWithDefaults: () => getConfigWithDefaults,
  getDefaultConfigForNewApplication: () => getDefaultConfigForNewApplication,
  getServerConfigForGatewayApplication: () => getServerConfigForGatewayApplication,
  getServerConfigForMicroserviceApplication: () => getServerConfigForMicroserviceApplication,
  getServerConfigForMonolithApplication: () => getServerConfigForMonolithApplication
});
function getConfigWithDefaults(customOptions = {}) {
  const applicationType = typeof customOptions === "string" ? customOptions : customOptions.applicationType;
  if (applicationType === GATEWAY2) {
    return getConfigForGatewayApplication(customOptions);
  }
  if (applicationType === MICROSERVICE2) {
    return getConfigForMicroserviceApplication(customOptions);
  }
  return getConfigForMonolithApplication(customOptions);
}
function getConfigForClientApplication(options = {}) {
  if (options[SKIP_CLIENT]) {
    options[CLIENT_FRAMEWORK] = NO_CLIENT_FRAMEWORK;
  }
  if (options[OptionNames2.MICROFRONTEND] === void 0) {
    options[OptionNames2.MICROFRONTEND] = Boolean(options[OptionNames2.MICROFRONTENDS]?.length);
  }
  const clientFramework = options[CLIENT_FRAMEWORK];
  if (clientFramework !== NO_CLIENT_FRAMEWORK) {
    if (!options[CLIENT_THEME]) {
      options[CLIENT_THEME] = OptionValues2[CLIENT_THEME];
      options[CLIENT_THEME_VARIANT] = "";
    } else if (options[CLIENT_THEME] !== OptionValues2[CLIENT_THEME] && !options[CLIENT_THEME_VARIANT]) {
      options[CLIENT_THEME_VARIANT] = "primary";
    }
  }
  return options;
}
function getConfigForAuthenticationType(options = {}) {
  if (typeof options[SKIP_USER_MANAGEMENT] !== "boolean") {
    if (options[AUTHENTICATION_TYPE] === OAUTH22) {
      options[SKIP_USER_MANAGEMENT] = true;
    } else {
      options[SKIP_USER_MANAGEMENT] = OptionValues2[SKIP_USER_MANAGEMENT];
    }
  }
  return options;
}
function getConfigForPackageName(options = {}) {
  if (!options[PACKAGE_NAME] && !options[PACKAGE_FOLDER]) {
    options[PACKAGE_FOLDER] = OptionValues2[PACKAGE_FOLDER];
  }
  if (!options[PACKAGE_NAME] && options[PACKAGE_FOLDER]) {
    options[PACKAGE_NAME] = options[PACKAGE_FOLDER].replace(/\//g, ".");
  }
  if (!options[PACKAGE_FOLDER] && options[PACKAGE_NAME]) {
    options[PACKAGE_FOLDER] = options[PACKAGE_NAME].replace(/\./g, "/");
  }
  return options;
}
function getConfigForCacheProvider(options = {}) {
  if (options[REACTIVE]) {
    options[CACHE_PROVIDER] = NO_CACHE_PROVIDER2;
  }
  return options;
}
function getConfigForReactive(options = {}) {
  if (options[REACTIVE] === void 0) {
    options[REACTIVE] = false;
  }
  return options;
}
function getConfigForTranslation(options = {}) {
  if (options[ENABLE_TRANSLATION] === void 0) {
    options[ENABLE_TRANSLATION] = true;
  }
  if (options[NATIVE_LANGUAGE] === void 0) {
    options[NATIVE_LANGUAGE] = "zh-cn";
  }
  if (options[ENABLE_TRANSLATION] && options[LANGUAGES] === void 0) {
    options[LANGUAGES] = [];
  }
  return options;
}
function getConfigForDatabaseType(options = {}) {
  if (options[DATABASE_TYPE] === void 0) {
    options[DATABASE_TYPE] = SQL3;
  }
  if (options[DATABASE_TYPE] === SQL3) {
    if (options[PROD_DATABASE_TYPE] === void 0) {
      options[PROD_DATABASE_TYPE] = POSTGRESQL3;
    }
    if (options[DEV_DATABASE_TYPE] === void 0) {
      options[DEV_DATABASE_TYPE] = options[PROD_DATABASE_TYPE];
    }
  } else if ([MONGODB2, COUCHBASE2, CASSANDRA2, NEO4J2, NO_DATABASE_TYPE].includes(options[DATABASE_TYPE])) {
    if (NO_DATABASE_TYPE !== options[DATABASE_TYPE]) {
      options[ENABLE_HIBERNATE_CACHE] = false;
    }
  }
  if (options[REACTIVE]) {
    options[ENABLE_HIBERNATE_CACHE] = false;
  }
  if (options[ENABLE_HIBERNATE_CACHE] === void 0) {
    options[ENABLE_HIBERNATE_CACHE] = true;
  }
  return options;
}
function getServerConfigForMonolithApplication(customOptions = {}) {
  const options = {
    ...commonDefaultOptions,
    [CACHE_PROVIDER]: EHCACHE2,
    [CLIENT_FRAMEWORK]: VUE2,
    [MOBILE_FRAMEWORK]: MOBILE,
    [SERVER_PORT]: OptionValues2[SERVER_PORT],
    [SERVICE_DISCOVERY_TYPE]: NO_SERVICE_DISCOVERY2,
    [WITH_ADMIN_UI]: true,
    [WITH_WEBSITE]: false,
    [ORM_TOOL]: orm_tool_types_default.MYBATIS,
    [USER_ID_TYPE]: "Long",
    ...customOptions
  };
  return {
    ...options,
    [APPLICATION_TYPE]: MONOLITH2
  };
}
function getConfigForMonolithApplication(customOptions = {}) {
  let options = getServerConfigForMonolithApplication(customOptions);
  options = getConfigForClientApplication(options);
  options = getConfigForPackageName(options);
  options = getConfigForCacheProvider(options);
  options = getConfigForDatabaseType(options);
  options = getConfigForReactive(options);
  options = getConfigForTranslation(options);
  return getConfigForAuthenticationType(options);
}
function getServerConfigForGatewayApplication(customOptions = {}) {
  const options = {
    ...commonDefaultOptions,
    [CLIENT_FRAMEWORK]: VUE2,
    [MOBILE_FRAMEWORK]: MOBILE,
    [SERVER_PORT]: OptionValues2[SERVER_PORT],
    [SERVICE_DISCOVERY_TYPE]: CONSUL2,
    [WITH_ADMIN_UI]: true,
    [WITH_WEBSITE]: false,
    [ORM_TOOL]: orm_tool_types_default.HIBERNATE,
    ...customOptions
  };
  options[CACHE_PROVIDER] = NO_CACHE_PROVIDER2;
  options[ENABLE_HIBERNATE_CACHE] = false;
  return {
    [REACTIVE]: true,
    ...options,
    [APPLICATION_TYPE]: GATEWAY2
  };
}
function getConfigForGatewayApplication(customOptions = {}) {
  let options = getServerConfigForGatewayApplication(customOptions);
  options = getConfigForClientApplication(options);
  options = getConfigForPackageName(options);
  options = getConfigForCacheProvider(options);
  options = getConfigForDatabaseType(options);
  options = getConfigForReactive(options);
  options = getConfigForTranslation(options);
  return getConfigForAuthenticationType(options);
}
function getServerConfigForMicroserviceApplication(customOptions = {}) {
  const DEFAULT_SERVER_PORT = 8081;
  const options = {
    ...commonDefaultOptions,
    [CACHE_PROVIDER]: HAZELCAST2,
    [SERVER_PORT]: DEFAULT_SERVER_PORT,
    [SERVICE_DISCOVERY_TYPE]: CONSUL2,
    [SKIP_USER_MANAGEMENT]: true,
    [CLIENT_FRAMEWORK]: NO_CLIENT_FRAMEWORK,
    [ORM_TOOL]: orm_tool_types_default.MYBATIS,
    [USER_ID_TYPE]: "Long",
    ...customOptions
  };
  options[WITH_ADMIN_UI] = false;
  options[WITH_WEBSITE] = false;
  return {
    ...options,
    [APPLICATION_TYPE]: MICROSERVICE2
  };
}
function getConfigForMicroserviceApplication(customOptions = {}) {
  let options = getServerConfigForMicroserviceApplication(customOptions);
  options = getConfigForClientApplication(options);
  options = getConfigForPackageName(options);
  options = getConfigForCacheProvider(options);
  options = getConfigForDatabaseType(options);
  options = getConfigForReactive(options);
  options = getConfigForTranslation(options);
  return getConfigForAuthenticationType(options);
}
function getDefaultConfigForNewApplication(customOptions = {}) {
  const options = {
    ...commonDefaultOptions,
    [BASE_NAME]: OptionValues2[BASE_NAME],
    [LANGUAGES]: OptionValues2[LANGUAGES],
    [TEST_FRAMEWORKS]: [],
    [ENABLE_GRADLE_ENTERPRISE]: OptionValues2[ENABLE_GRADLE_ENTERPRISE],
    [GRADLE_ENTERPRISE_HOST]: OptionValues2[GRADLE_ENTERPRISE_HOST],
    ...customOptions
  };
  return getConfigWithDefaults(options);
}
var MONOLITH2, MICROSERVICE2, GATEWAY2, CONSUL2, COUCHBASE2, CASSANDRA2, MONGODB2, NEO4J2, SQL3, POSTGRESQL3, NO_DATABASE_TYPE, OptionNames2, OptionValues2, JWT2, OAUTH22, NO_CLIENT_FRAMEWORK, VUE2, MOBILE, EHCACHE2, HAZELCAST2, NO_CACHE_PROVIDER2, NO_SERVICE_DISCOVERY2, MAVEN2, APPLICATION_TYPE, AUTHENTICATION_TYPE, BASE_NAME, BUILD_TOOL, CACHE_PROVIDER, CLIENT_FRAMEWORK, CLIENT_THEME, CLIENT_THEME_VARIANT, WITH_ADMIN_UI, WITH_WEBSITE, DATABASE_TYPE, DEV_DATABASE_TYPE, DTO_SUFFIX, ENABLE_HIBERNATE_CACHE, ENABLE_SWAGGER_CODEGEN, ENABLE_TRANSLATION, ENTITY_SUFFIX, JHI_PREFIX, LANGUAGES, NATIVE_LANGUAGE, PACKAGE_FOLDER, PACKAGE_NAME, PROD_DATABASE_TYPE, REACTIVE, SEARCH_ENGINE, SERVER_PORT, SERVICE_DISCOVERY_TYPE, SKIP_CLIENT, SKIP_USER_MANAGEMENT, TEST_FRAMEWORKS, WEBSOCKET, ENABLE_GRADLE_ENTERPRISE, GRADLE_ENTERPRISE_HOST, MOBILE_FRAMEWORK, MOBILE_THEME, ORM_TOOL, USER_ID_TYPE, BUILT_IN_SERVICES, USE_LOMBOK, MULTI_MODULE, USE_COMMON_TABLE, USE_MULTI_TENANT, SOFT_DELETE, JAVA_VERSION, CLIENT_PACKAGE_MANAGER, commonDefaultOptions;
var init_default_application_options = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/default-application-options.js"() {
    init_application_types();
    init_authentication_types();
    init_database_types();
    init_application_options2();
    init_cache_types();
    init_service_discovery_types();
    init_client_framework_types();
    init_build_tool_types();
    init_options();
    init_orm_tool_types();
    ({ MONOLITH: MONOLITH2, MICROSERVICE: MICROSERVICE2, GATEWAY: GATEWAY2 } = application_types_default);
    ({ CONSUL: CONSUL2 } = service_discovery_types_default);
    ({ COUCHBASE: COUCHBASE2, CASSANDRA: CASSANDRA2, MONGODB: MONGODB2, NEO4J: NEO4J2, SQL: SQL3, POSTGRESQL: POSTGRESQL3 } = database_types_default);
    NO_DATABASE_TYPE = database_types_default.NO;
    ({ OptionNames: OptionNames2, OptionValues: OptionValues2 } = application_options_default);
    ({ JWT: JWT2, OAUTH2: OAUTH22 } = authentication_types_default);
    ({ NO: NO_CLIENT_FRAMEWORK, VUE: VUE2, MOBILE } = client_framework_types_default);
    ({ EHCACHE: EHCACHE2, HAZELCAST: HAZELCAST2 } = cache_types_default);
    NO_CACHE_PROVIDER2 = cache_types_default.NO;
    NO_SERVICE_DISCOVERY2 = service_discovery_types_default.NO;
    ({ MAVEN: MAVEN2 } = build_tool_types_default);
    ({ APPLICATION_TYPE, AUTHENTICATION_TYPE, BASE_NAME, BUILD_TOOL, CACHE_PROVIDER, CLIENT_FRAMEWORK, CLIENT_THEME, CLIENT_THEME_VARIANT, WITH_ADMIN_UI, WITH_WEBSITE, DATABASE_TYPE, DEV_DATABASE_TYPE, DTO_SUFFIX, ENABLE_HIBERNATE_CACHE, ENABLE_SWAGGER_CODEGEN, ENABLE_TRANSLATION, ENTITY_SUFFIX, JHI_PREFIX, LANGUAGES, NATIVE_LANGUAGE, PACKAGE_FOLDER, PACKAGE_NAME, PROD_DATABASE_TYPE, REACTIVE, SEARCH_ENGINE, SERVER_PORT, SERVICE_DISCOVERY_TYPE, SKIP_CLIENT, SKIP_USER_MANAGEMENT, TEST_FRAMEWORKS, WEBSOCKET, ENABLE_GRADLE_ENTERPRISE, GRADLE_ENTERPRISE_HOST, MOBILE_FRAMEWORK, MOBILE_THEME, ORM_TOOL, USER_ID_TYPE, BUILT_IN_SERVICES, USE_LOMBOK, MULTI_MODULE, USE_COMMON_TABLE, USE_MULTI_TENANT, SOFT_DELETE, JAVA_VERSION, CLIENT_PACKAGE_MANAGER } = OptionNames2);
    commonDefaultOptions = {
      [AUTHENTICATION_TYPE]: JWT2,
      [BUILD_TOOL]: MAVEN2,
      [DTO_SUFFIX]: OptionValues2[DTO_SUFFIX],
      [ENABLE_SWAGGER_CODEGEN]: OptionValues2[ENABLE_SWAGGER_CODEGEN],
      [ENABLE_TRANSLATION]: OptionValues2[ENABLE_TRANSLATION],
      [ENTITY_SUFFIX]: OptionValues2[ENTITY_SUFFIX],
      [JHI_PREFIX]: OptionValues2[JHI_PREFIX],
      [MESSAGE_BROKER]: MESSAGE_BROKER_NO,
      [SEARCH_ENGINE]: OptionValues2[SEARCH_ENGINE].no,
      [WEBSOCKET]: OptionValues2[WEBSOCKET].no,
      [ORM_TOOL]: orm_tool_types_default.MYBATIS,
      [USER_ID_TYPE]: "Long",
      [BUILT_IN_SERVICES]: [],
      [USE_LOMBOK]: true,
      [MULTI_MODULE]: false,
      [USE_COMMON_TABLE]: false,
      [USE_MULTI_TENANT]: false,
      [SOFT_DELETE]: false,
      [JAVA_VERSION]: "17",
      [CLIENT_PACKAGE_MANAGER]: "pnpm",
      skipJhipsterDependencies: true
    };
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/entity-options.js
var MapperTypes, ServiceTypes, PaginationTypes, SearchTypes, FilteringTypes, entity_options_default;
var init_entity_options = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/entity-options.js"() {
    MapperTypes = {
      MAPSTRUCT: "mapstruct",
      NO: "no"
    };
    ServiceTypes = {
      SERVICE_CLASS: "serviceClass",
      SERVICE_IMPL: "serviceImpl",
      NO: "no"
    };
    PaginationTypes = {
      PAGINATION: "pagination",
      INFINITE_SCROLL: "infinite-scroll",
      NO: "no"
    };
    SearchTypes = {
      ELASTICSEARCH: "elasticsearch",
      COUCHBASE: "couchbase",
      NO: "no"
    };
    FilteringTypes = {
      JPA_METAMODEL: "jpaMetamodel",
      NO: "no"
    };
    entity_options_default = {
      MapperTypes,
      ServiceTypes,
      PaginationTypes,
      SearchTypes,
      FilteringTypes
    };
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/binary-options.js
function getOptionName(optionValue) {
  return optionNames2.find((optionName) => Values[optionName] && Values[optionName][optionValue]);
}
function forEach2(passedFunction) {
  if (!passedFunction) {
    throw new Error("A function has to be passed to loop over the binary options.");
  }
  optionNames2.forEach(passedFunction);
}
function exists(passedOption, passedValue) {
  return !Object.values(Options).includes(passedOption) || Object.values(Options).some((option) => passedOption === option && (passedOption === Options.MICROSERVICE || passedOption === Options.ANGULAR_SUFFIX || passedOption === Options.CLIENT_ROOT_FOLDER || Object.values(Values[option]).includes(passedValue)));
}
var MapperTypes2, PaginationTypes2, SearchTypes2, ServiceTypes2, MAPSTRUCT, NO_MAPPER, SERVICE_CLASS, SERVICE_IMPL, NO_SERVICE, ELASTICSEARCH2, COUCHBASE3, NO_SEARCH, Options, optionNames2, Values, DefaultValues, OptionValues3, binary_options_default;
var init_binary_options = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/binary-options.js"() {
    init_entity_options();
    ({ MapperTypes: MapperTypes2, PaginationTypes: PaginationTypes2, SearchTypes: SearchTypes2, ServiceTypes: ServiceTypes2 } = entity_options_default);
    ({ MAPSTRUCT } = MapperTypes2);
    NO_MAPPER = MapperTypes2.NO;
    ({ SERVICE_CLASS, SERVICE_IMPL } = ServiceTypes2);
    NO_SERVICE = ServiceTypes2.NO;
    ({ ELASTICSEARCH: ELASTICSEARCH2, COUCHBASE: COUCHBASE3, NO: NO_SEARCH } = SearchTypes2);
    Options = {
      DTO: "dto",
      SERVICE: "service",
      PAGINATION: "pagination",
      MICROSERVICE: "microservice",
      SEARCH: "search",
      ANGULAR_SUFFIX: "angularSuffix",
      CLIENT_ROOT_FOLDER: "clientRootFolder"
    };
    optionNames2 = Object.values(Options);
    Values = {
      [Options.DTO]: { MAPSTRUCT, NO: NO_MAPPER },
      [Options.SERVICE]: { SERVICE_CLASS, SERVICE_IMPL, NO: NO_SERVICE },
      [Options.PAGINATION]: {
        PAGINATION: PaginationTypes2.PAGINATION,
        "INFINITE-SCROLL": PaginationTypes2.INFINITE_SCROLL,
        NO: PaginationTypes2.NO
      },
      [Options.SEARCH]: { ELASTICSEARCH: ELASTICSEARCH2, COUCHBASE: COUCHBASE3, NO: NO_SEARCH }
    };
    DefaultValues = {
      [Options.DTO]: Values[Options.DTO].NO,
      [Options.SERVICE]: Values[Options.SERVICE].NO,
      [Options.PAGINATION]: Values[Options.PAGINATION].NO
    };
    OptionValues3 = {
      mapstruct: "MAPSTRUCT",
      serviceClass: "SERVICE_CLASS",
      serviceImpl: "SERVICE_IMPL",
      pagination: "PAGINATION",
      "infinite-scroll": "INFINITE-SCROLL",
      elasticsearch: "ELASTICSEARCH",
      couchbase: "COUCHBASE"
    };
    binary_options_default = {
      Options,
      DefaultValues,
      OptionValues: OptionValues3,
      Values,
      exists,
      forEach: forEach2,
      getOptionName
    };
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/kubernetes-platform-types.js
var ServiceTypes3, IngressTypes, GeneratorTypes, kubernetes_platform_types_default;
var init_kubernetes_platform_types = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/kubernetes-platform-types.js"() {
    ServiceTypes3 = {
      LOAD_BALANCER: "LoadBalancer",
      INGRESS: "Ingress",
      NODE_PORT: "NodePort"
    };
    IngressTypes = {
      NGINX: "nginx",
      GKE: "gke"
    };
    GeneratorTypes = {
      K8S: "k8s",
      HELM: "helm"
    };
    kubernetes_platform_types_default = {
      GeneratorTypes,
      IngressTypes,
      ServiceTypes: ServiceTypes3
    };
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/openshift-platform-types.js
var StorageTypes, openshift_platform_types_default;
var init_openshift_platform_types = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/openshift-platform-types.js"() {
    StorageTypes = {
      EPHEMERAL: "ephemeral",
      PERSISTENT: "persistent"
    };
    openshift_platform_types_default = {
      StorageTypes
    };
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/monitoring-types.js
var monitoringTypes, monitoring_types_default;
var init_monitoring_types = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/monitoring-types.js"() {
    monitoringTypes = {
      PROMETHEUS: "prometheus",
      ELK: "elk",
      NO: "no"
    };
    monitoring_types_default = monitoringTypes;
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/deployment-options.js
var LOAD_BALANCER, NODE_PORT, INGRESS, NGINX, GKE, EPHEMERAL, PERSISTENT, EUREKA2, CONSUL3, NO_SERVICE_DISCOVERY3, NO_MONITORING, PROMETHEUS, DeploymentTypes, DOCKERCOMPOSE, KUBERNETES, OPENSHIFT, kubernetesRelatedOptions, openshiftRelatedOptions, dockerComposeRelatedOptions, baseOptions, Options2, deployment_options_default;
var init_deployment_options = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/deployment-options.js"() {
    init_kubernetes_platform_types();
    init_openshift_platform_types();
    init_monitoring_types();
    init_service_discovery_types();
    ({ LOAD_BALANCER, NODE_PORT, INGRESS } = kubernetes_platform_types_default.ServiceTypes);
    ({ NGINX, GKE } = kubernetes_platform_types_default.IngressTypes);
    ({ EPHEMERAL, PERSISTENT } = openshift_platform_types_default.StorageTypes);
    ({ EUREKA: EUREKA2, CONSUL: CONSUL3 } = service_discovery_types_default);
    NO_SERVICE_DISCOVERY3 = service_discovery_types_default.NO;
    NO_MONITORING = monitoring_types_default.NO;
    ({ PROMETHEUS } = monitoring_types_default);
    DeploymentTypes = {
      DOCKERCOMPOSE: "docker-compose",
      KUBERNETES: "kubernetes",
      OPENSHIFT: "openshift",
      exists: (deploymentType) => !!deploymentType && !!DeploymentTypes[deploymentType.toUpperCase().replace("-", "")]
    };
    DOCKERCOMPOSE = DeploymentTypes.DOCKERCOMPOSE;
    KUBERNETES = DeploymentTypes.KUBERNETES;
    OPENSHIFT = DeploymentTypes.OPENSHIFT;
    kubernetesRelatedOptions = {
      kubernetesNamespace: "default",
      kubernetesServiceType: {
        loadBalancer: LOAD_BALANCER,
        nodePort: NODE_PORT,
        ingress: INGRESS
      },
      kubernetesStorageClassName: "",
      kubernetesUseDynamicStorage: {
        false: false,
        true: true
      },
      ingressDomain: "",
      ingressType: {
        nginx: NGINX,
        gke: GKE
      },
      istio: {
        false: false,
        true: true
      }
    };
    openshiftRelatedOptions = {
      openshiftNamespace: "default",
      registryReplicas: {
        two: 2
      },
      storageType: {
        ephemeral: EPHEMERAL,
        persistent: PERSISTENT
      }
    };
    dockerComposeRelatedOptions = {
      gatewayType: {
        springCloudGateway: "SpringCloudGateway"
      }
    };
    baseOptions = {
      appsFolders: [],
      clusteredDbApps: [],
      directoryPath: "../",
      monitoring: {
        no: NO_MONITORING,
        prometheus: PROMETHEUS
      },
      serviceDiscoveryType: {
        eureka: EUREKA2,
        consul: CONSUL3,
        no: NO_SERVICE_DISCOVERY3
      }
    };
    Options2 = {
      ...baseOptions,
      deploymentType: {
        dockerCompose: DeploymentTypes.DOCKERCOMPOSE,
        kubernetes: DeploymentTypes.KUBERNETES,
        openshift: DeploymentTypes.OPENSHIFT
      },
      dockerPushCommand: "docker push",
      dockerRepositoryName: "",
      ...dockerComposeRelatedOptions,
      ...kubernetesRelatedOptions,
      ...openshiftRelatedOptions
    };
    Options2.defaults = (deploymentType = Options2.deploymentType.dockerCompose) => {
      if (deploymentType === Options2.deploymentType.kubernetes) {
        return {
          appsFolders: [],
          directoryPath: Options2.directoryPath,
          clusteredDbApps: [],
          serviceDiscoveryType: Options2.serviceDiscoveryType.consul,
          dockerRepositoryName: Options2.dockerRepositoryName,
          dockerPushCommand: Options2.dockerPushCommand,
          kubernetesNamespace: Options2.kubernetesNamespace,
          kubernetesServiceType: Options2.kubernetesServiceType.loadBalancer,
          kubernetesUseDynamicStorage: Options2.kubernetesUseDynamicStorage.false,
          kubernetesStorageClassName: Options2.kubernetesStorageClassName,
          ingressDomain: Options2.ingressDomain,
          monitoring: Options2.monitoring.no,
          istio: Options2.istio.false
        };
      }
      if (deploymentType === Options2.deploymentType.dockerCompose) {
        return {
          appsFolders: [],
          directoryPath: Options2.directoryPath,
          gatewayType: Options2.gatewayType.springCloudGateway,
          clusteredDbApps: [],
          monitoring: Options2.monitoring.no,
          serviceDiscoveryType: Options2.serviceDiscoveryType.consul
        };
      }
      return {
        appsFolders: [],
        directoryPath: Options2.directoryPath,
        clusteredDbApps: [],
        serviceDiscoveryType: Options2.serviceDiscoveryType.consul,
        monitoring: Options2.monitoring.no,
        dockerRepositoryName: Options2.dockerRepositoryName,
        dockerPushCommand: Options2.dockerPushCommand,
        openshiftNamespace: Options2.openshiftNamespace,
        storageType: Options2.storageType.ephemeral,
        registryReplicas: Options2.registryReplicas.two
      };
    };
    deployment_options_default = {
      Options: Options2,
      DeploymentTypes
    };
  }
});

// node_modules/generator-begcode/dist/generators/server/support/string.js
function hibernateSnakeCase(value) {
  let res = "";
  if (value) {
    if (value.length === 1) {
      return value.toLowerCase();
    }
    value = value.replace(".", "_");
    res = value[0];
    for (let i = 1, len = value.length - 1; i < len; i++) {
      if (value[i - 1] !== value[i - 1].toUpperCase() && value[i] !== value[i].toLowerCase() && value[i + 1] !== value[i + 1].toUpperCase()) {
        res += `_${value[i]}`;
      } else {
        res += value[i];
      }
    }
    res += value[value.length - 1];
    res = res.toLowerCase();
  }
  return res;
}
var init_string = __esm({
  "node_modules/generator-begcode/dist/generators/server/support/string.js"() {
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/entity-table-name-creator.js
function getTableNameFromEntityName(entityName) {
  if (!entityName) {
    throw new Error("An entity name must be passed to get a table name.");
  }
  return snakeCase_default(entityName);
}
var getTableNameFromEntityNameFallback, shouldWriteEntityTableName;
var init_entity_table_name_creator = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/entity-table-name-creator.js"() {
    init_lodash();
    init_string();
    getTableNameFromEntityNameFallback = (entityName) => {
      const snakeCasedEntityName = getTableNameFromEntityName(entityName);
      if (snakeCasedEntityName !== hibernateSnakeCase(entityName)) {
        return snakeCasedEntityName;
      }
      return void 0;
    };
    shouldWriteEntityTableName = (entityName, entityTableName) => {
      return entityTableName !== snakeCase_default(entityName) || entityTableName !== hibernateSnakeCase(entityName);
    };
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/validations.js
var ValidationTypes, exists2, needsValue, SUPPORTED_VALIDATION_RULES, Validations, validations_default;
var init_validations = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/validations.js"() {
    ValidationTypes = {
      REQUIRED: "required",
      UNIQUE: "unique",
      MIN: "min",
      MAX: "max",
      MINLENGTH: "minlength",
      MAXLENGTH: "maxlength",
      PATTERN: "pattern",
      MINBYTES: "minbytes",
      MAXBYTES: "maxbytes"
    };
    exists2 = (validation) => Object.keys(ValidationTypes).map((key) => ValidationTypes[key]).includes(validation);
    needsValue = (validation) => {
      const valuedMap = {
        required: false,
        unique: false,
        min: true,
        max: true,
        minlength: true,
        maxlength: true,
        pattern: true,
        minbytes: true,
        maxbytes: true
      };
      return valuedMap[validation];
    };
    SUPPORTED_VALIDATION_RULES = Object.keys(ValidationTypes).map((key) => ValidationTypes[key]).filter((e) => typeof e === "string");
    Validations = {
      ...ValidationTypes,
      exists: exists2,
      needsValue
    };
    validations_default = { Validations, SUPPORTED_VALIDATION_RULES };
  }
});

// node_modules/generator-begcode/dist/jdl/utils/object-utils.js
function merge(object1, object2) {
  if (!object1 || Object.keys(object1).length === 0) {
    return object2;
  }
  if (!object2 || Object.keys(object2).length === 0) {
    return object1;
  }
  return {
    ...object1,
    ...object2
  };
}
var init_object_utils = __esm({
  "node_modules/generator-begcode/dist/jdl/utils/object-utils.js"() {
  }
});

// node_modules/generator-begcode/dist/jdl/models/jdl-enum-value.js
var JDLEnumValue;
var init_jdl_enum_value = __esm({
  "node_modules/generator-begcode/dist/jdl/models/jdl-enum-value.js"() {
    JDLEnumValue = class {
      name;
      value;
      comment;
      constructor(name, value, comment) {
        if (!name) {
          throw new Error("The enum value name has to be passed to create an enum.");
        }
        this.name = name;
        this.value = value;
        this.comment = comment;
      }
      toString() {
        const value = this.value ? ` (${this.value})` : "";
        return `${this.name}${value}`;
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/models/jdl-enum.js
function defaults2() {
  return {
    values: []
  };
}
function stringifyValues(jdlEnumValues) {
  const values2 = [];
  jdlEnumValues.forEach((jdlEnumValue) => {
    values2.push(jdlEnumValue.toString());
  });
  return values2;
}
var JDLEnum;
var init_jdl_enum = __esm({
  "node_modules/generator-begcode/dist/jdl/models/jdl-enum.js"() {
    init_object_utils();
    init_jdl_enum_value();
    JDLEnum = class {
      comment;
      name;
      values;
      constructor(args) {
        const merged = merge(defaults2(), args);
        if (!merged.name) {
          throw new Error("The enum's name must be passed to create an enum.");
        }
        this.comment = merged.comment;
        this.name = merged.name;
        this.values = new Map(merged.values.map((entry) => {
          return [entry.key, new JDLEnumValue(entry.key, entry.value, entry.comment)];
        }));
      }
      getValuesAsString() {
        return stringifyValues(this.values).join(",");
      }
      getValueJavadocs() {
        const documentations = {};
        this.values.forEach((jdlEnumValue) => {
          if (jdlEnumValue.comment) {
            documentations[jdlEnumValue.name] = jdlEnumValue.comment;
          }
        });
        return documentations;
      }
      toString() {
        let comment = "";
        if (this.comment) {
          comment += `/**
 * ${this.comment}
 */
`;
        }
        const values2 = stringifyValues(this.values);
        return `${comment}enum ${this.name} {
  ${values2.join(",\n  ")}
}`;
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/field-types.js
function isCommonDBType(type) {
  if (!type) {
    throw new Error("The passed type must not be nil.");
  }
  return snakeCase_default(type).toUpperCase() in CommonDBTypes || type instanceof JDLEnum;
}
function isBlobType(type) {
  if (!type) {
    return false;
  }
  return CommonDBTypes.BLOB === type || CommonDBTypes.ANY_BLOB === type || CommonDBTypes.IMAGE_BLOB === type || CommonDBTypes.TEXT_BLOB === type;
}
function hasValidation(type, validation, isAnEnum) {
  if (!type || !validation) {
    throw new Error("The passed type and value must not be nil.");
  }
  if (isAnEnum) {
    type = "Enum";
  }
  return isCommonDBType(type) && CommonDBValidations[type].has(validation);
}
function getIsType(databaseType, callback) {
  if (!databaseType) {
    throw new Error("The passed type must not be nil.");
  }
  let isType;
  switch (databaseType) {
    case SQL4:
    case MYSQL3:
    case MARIADB3:
    case POSTGRESQL4:
    case ORACLE3:
    case MSSQL3:
    case MONGODB3:
    case COUCHBASE4:
    case CASSANDRA3:
    case NEO4J3:
      isType = isCommonDBType;
      break;
    case NO2:
      isType = () => true;
      break;
    default:
      callback && callback();
      throw new Error("The passed database type must either be 'sql', 'mysql', 'mariadb', 'postgresql', 'oracle', 'mssql', 'mongodb', 'couchbase', 'neo4j' or 'cassandra'");
  }
  return isType;
}
var REQUIRED, UNIQUE, MAX, MAXBYTES, MAXLENGTH, MIN, MINBYTES, MINLENGTH, PATTERN2, MONGODB3, MARIADB3, COUCHBASE4, NEO4J3, CASSANDRA3, MSSQL3, MYSQL3, NO2, ORACLE3, POSTGRESQL4, SQL4, CommonDBTypes, RelationalOnlyDBTypes, BlobTypes, CommonDBValidations, field_types_default;
var init_field_types = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/field-types.js"() {
    init_lodash();
    init_validations();
    init_jdl_enum();
    init_database_types();
    ({ Validations: { REQUIRED, UNIQUE, MAX, MAXBYTES, MAXLENGTH, MIN, MINBYTES, MINLENGTH, PATTERN: PATTERN2 } } = validations_default);
    ({ MONGODB: MONGODB3, MARIADB: MARIADB3, COUCHBASE: COUCHBASE4, NEO4J: NEO4J3, CASSANDRA: CASSANDRA3, MSSQL: MSSQL3, MYSQL: MYSQL3, NO: NO2, ORACLE: ORACLE3, POSTGRESQL: POSTGRESQL4, SQL: SQL4 } = database_types_default);
    CommonDBTypes = {
      STRING: "String",
      INTEGER: "Integer",
      LONG: "Long",
      BIG_DECIMAL: "BigDecimal",
      FLOAT: "Float",
      DOUBLE: "Double",
      UUID: "UUID",
      ENUM: "Enum",
      BOOLEAN: "Boolean",
      LOCAL_DATE: "LocalDate",
      ZONED_DATE_TIME: "ZonedDateTime",
      BLOB: "Blob",
      ANY_BLOB: "AnyBlob",
      IMAGE_BLOB: "ImageBlob",
      TEXT_BLOB: "TextBlob",
      INSTANT: "Instant",
      DURATION: "Duration",
      BYTES: "byte[]",
      BYTE_BUFFER: "ByteBuffer"
    };
    RelationalOnlyDBTypes = {
      BYTES: "byte[]",
      BYTE_BUFFER: "ByteBuffer"
    };
    BlobTypes = {
      IMAGE: "image",
      ANY: "any",
      TEXT: "text"
    };
    CommonDBValidations = {
      String: /* @__PURE__ */ new Set([REQUIRED, UNIQUE, MINLENGTH, MAXLENGTH, PATTERN2]),
      Integer: /* @__PURE__ */ new Set([REQUIRED, UNIQUE, MIN, MAX]),
      Long: /* @__PURE__ */ new Set([REQUIRED, UNIQUE, MIN, MAX]),
      BigDecimal: /* @__PURE__ */ new Set([REQUIRED, UNIQUE, MIN, MAX]),
      Float: /* @__PURE__ */ new Set([REQUIRED, UNIQUE, MIN, MAX]),
      Double: /* @__PURE__ */ new Set([REQUIRED, UNIQUE, MIN, MAX]),
      Enum: /* @__PURE__ */ new Set([REQUIRED, UNIQUE]),
      Boolean: /* @__PURE__ */ new Set([REQUIRED, UNIQUE]),
      LocalDate: /* @__PURE__ */ new Set([REQUIRED, UNIQUE]),
      ZonedDateTime: /* @__PURE__ */ new Set([REQUIRED, UNIQUE]),
      Blob: /* @__PURE__ */ new Set([REQUIRED, UNIQUE, MINBYTES, MAXBYTES]),
      AnyBlob: /* @__PURE__ */ new Set([REQUIRED, UNIQUE, MINBYTES, MAXBYTES]),
      ImageBlob: /* @__PURE__ */ new Set([REQUIRED, UNIQUE, MINBYTES, MAXBYTES]),
      TextBlob: /* @__PURE__ */ new Set([REQUIRED, UNIQUE]),
      UUID: /* @__PURE__ */ new Set([REQUIRED, UNIQUE]),
      Instant: /* @__PURE__ */ new Set([REQUIRED, UNIQUE]),
      Duration: /* @__PURE__ */ new Set([REQUIRED, UNIQUE])
    };
    field_types_default = {
      CommonDBTypes,
      RelationalOnlyDBTypes,
      isCommonDBType,
      hasValidation,
      getIsType,
      isBlobType,
      BlobTypes
    };
  }
});

// node_modules/generator-begcode/dist/jdl/utils/string-utils.js
function camelCase2(string) {
  checkStringIsValid(string);
  if (string === "") {
    return string;
  }
  const [firstLetter, ...rest] = string.replace(/[\W_]/g, "");
  return `${firstLetter.toLowerCase()}${rest.join("")}`;
}
function upperFirst2(string) {
  checkStringIsValid(string);
  if (string === "") {
    return string;
  }
  const [firstLetter, ...rest] = string;
  return `${firstLetter.toUpperCase()}${rest.join("")}`;
}
function lowerFirst2(string) {
  checkStringIsValid(string);
  if (string === "") {
    return string;
  }
  const [firstLetter, ...rest] = string;
  return `${firstLetter.toLowerCase()}${rest.join("")}`;
}
function checkStringIsValid(string) {
  if (string === void 0 || string === null) {
    throw new Error("The passed string cannot be nil.");
  }
}
var init_string_utils = __esm({
  "node_modules/generator-begcode/dist/jdl/utils/string-utils.js"() {
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/json-entity.js
function getDefaults(entityName) {
  return {
    name: upperFirst2(entityName),
    fields: [],
    relationships: [],
    applications: [],
    annotations: {},
    aigcs: []
  };
}
var JSONEntity, json_entity_default;
var init_json_entity = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/json-entity.js"() {
    init_object_utils();
    init_string_utils();
    JSONEntity = class {
      annotations;
      constructor(args) {
        if (!args || !args.entityName) {
          throw new Error("At least an entity name must be passed.");
        }
        const merged = merge(getDefaults(args.entityName), args);
        this.name = merged.name;
        this.fields = merged.fields;
        this.annotations = merged.annotations;
        this.relationships = merged.relationships;
        this.aigcs = merged.aigcs;
        this.documentation = merged.documentation;
        this.entityTableName = merged.entityTableName;
        this.dto = merged.dto;
        this.pagination = merged.pagination;
        this.service = merged.service;
        this.jpaMetamodelFiltering = merged.jpaMetamodelFiltering;
        this.fluentMethods = merged.fluentMethods;
        this.readOnly = merged.readOnly;
        this.embedded = merged.embedded;
        if (merged.clientRootFolder) {
          this.clientRootFolder = merged.clientRootFolder;
        }
        if (merged.microserviceName) {
          this.microserviceName = merged.microserviceName;
        }
        if (merged.angularJSSuffix) {
          this.angularJSSuffix = merged.angularJSSuffix;
        }
        if (merged.skipServer) {
          this.skipServer = merged.skipServer;
        }
        if (merged.skipClient) {
          this.skipClient = merged.skipClient;
        }
        this.applications = [];
      }
      addFields(fields) {
        if (!fields || fields.length === 0) {
          return;
        }
        this.fields = this.fields.concat(fields);
      }
      addField(field) {
        if (field) {
          this.fields.push(field);
        }
      }
      addRelationships(relationships) {
        if (!relationships || relationships.length === 0) {
          return;
        }
        this.relationships = this.relationships.concat(relationships);
      }
      addRelationship(relationship) {
        if (relationship) {
          this.relationships.push(relationship);
        }
      }
      addAigcs(aigcs) {
        if (!aigcs || aigcs.length === 0) {
          return;
        }
        this.aigcs = this.aigcs.concat(aigcs);
      }
      addAigc(aigc) {
        if (aigc) {
          this.aigcs.push(aigc);
        }
      }
      setOptions(options = {}) {
        Object.keys(options).forEach((optionName) => {
          this[optionName] = options[optionName];
        });
      }
      setAnnotations(annotations = {}) {
        Object.assign(this.annotations, annotations);
      }
    };
    json_entity_default = JSONEntity;
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/message-broker-types.js
var messageBrokerTypes, message_broker_types_default;
var init_message_broker_types = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/message-broker-types.js"() {
    messageBrokerTypes = {
      KAFKA: "kafka",
      PULSAR: "pulsar",
      NO: "no"
    };
    message_broker_types_default = messageBrokerTypes;
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/openapi-options.js
var OpenAPIOptionsNames, OpenAPIOptionsValues, OpenAPIDefaultValues, openapi_options_default;
var init_openapi_options = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/openapi-options.js"() {
    OpenAPIOptionsNames = {
      REGEN: "regen",
      API_CLIENTS: "new"
    };
    OpenAPIOptionsValues = {
      REGEN: {
        YES: true,
        NO: false
      }
    };
    OpenAPIDefaultValues = {
      REGEN: OpenAPIOptionsValues.REGEN.NO
    };
    openapi_options_default = {
      OpenAPIOptionsNames,
      OpenAPIOptionsValues,
      OpenAPIDefaultValues
    };
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/relationship-options.js
function exists3(option) {
  return Object.values(Options3).includes(option);
}
var Options3, relationship_options_default;
var init_relationship_options = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/relationship-options.js"() {
    Options3 = {
      BUILT_IN_ENTITY: "builtInEntity"
    };
    relationship_options_default = {
      ...Options3,
      exists: exists3,
      doesRelationshipOptionExist: exists3
    };
  }
});

// node_modules/generator-begcode/dist/jdl/basic-types/relationships.js
var JDL_RELATIONSHIP_ONE_TO_ONE, JDL_RELATIONSHIP_ONE_TO_MANY, JDL_RELATIONSHIP_MANY_TO_ONE, JDL_RELATIONSHIP_MANY_TO_MANY, relationshipTypes;
var init_relationships = __esm({
  "node_modules/generator-begcode/dist/jdl/basic-types/relationships.js"() {
    JDL_RELATIONSHIP_ONE_TO_ONE = "OneToOne";
    JDL_RELATIONSHIP_ONE_TO_MANY = "OneToMany";
    JDL_RELATIONSHIP_MANY_TO_ONE = "ManyToOne";
    JDL_RELATIONSHIP_MANY_TO_MANY = "ManyToMany";
    relationshipTypes = {
      ONE_TO_ONE: JDL_RELATIONSHIP_ONE_TO_ONE,
      ONE_TO_MANY: JDL_RELATIONSHIP_ONE_TO_MANY,
      MANY_TO_ONE: JDL_RELATIONSHIP_MANY_TO_ONE,
      MANY_TO_MANY: JDL_RELATIONSHIP_MANY_TO_MANY
    };
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/relationship-types.js
var asJdlRelationshipType, relationshipTypeExists, relationship_types_default;
var init_relationship_types = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/relationship-types.js"() {
    init_lodash();
    init_relationships();
    asJdlRelationshipType = (type) => upperFirst_default(camelCase_default(type));
    relationshipTypeExists = (relationship) => Object.values(relationshipTypes).includes(relationship);
    relationship_types_default = relationshipTypes;
  }
});

// node_modules/generator-begcode/dist/jdl/basic-types/aigc-type.js
var JDL_AIGC_TYPE_METHOD, JDL_AIGC_TYPE_API, JDL_AIGC_TYPE_FEATURE, aiTypes;
var init_aigc_type = __esm({
  "node_modules/generator-begcode/dist/jdl/basic-types/aigc-type.js"() {
    JDL_AIGC_TYPE_METHOD = "Method";
    JDL_AIGC_TYPE_API = "Api";
    JDL_AIGC_TYPE_FEATURE = "Feature";
    aiTypes = {
      METHOD: JDL_AIGC_TYPE_METHOD,
      API: JDL_AIGC_TYPE_API,
      FEATURE: JDL_AIGC_TYPE_FEATURE
    };
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/aigc-types.js
var asJdlAigcType, aigcTypeExists, aigc_types_default;
var init_aigc_types = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/aigc-types.js"() {
    init_lodash();
    init_aigc_type();
    asJdlAigcType = (type) => upperFirst_default(camelCase_default(type));
    aigcTypeExists = (aigc) => Object.values(aiTypes).includes(aigc);
    aigc_types_default = aiTypes;
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/reserved-keywords/jhipster.js
var jhipster_default;
var init_jhipster = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/reserved-keywords/jhipster.js"() {
    jhipster_default = [
      "ACCOUNT",
      "ACTIVATE",
      "AUDITS",
      "CONFIGURATION",
      "DOCS",
      "HEALTH",
      "LOGS",
      "METRICS",
      "PASSWORD",
      "REGISTER",
      "RESET",
      "SESSIONS",
      "SETTINGS",
      "TEST",
      "EVENTMANAGER",
      "PRINCIPAL",
      "ENTITY",
      "RESULT"
    ];
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/reserved-keywords/paging.js
var paging_default;
var init_paging = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/reserved-keywords/paging.js"() {
    paging_default = ["SIZE", "SORT", "PAGE"];
  }
});

// node_modules/generator-begcode/dist/generators/angular/support/reserved-keywords.js
var angularReservedKeywords;
var init_reserved_keywords = __esm({
  "node_modules/generator-begcode/dist/generators/angular/support/reserved-keywords.js"() {
    angularReservedKeywords = [
      "CLASS",
      "NODENAME",
      "NODETYPE",
      "COMPONENT",
      "SUBSCRIPTION",
      "RESPONSE",
      "OBSERVABLE",
      "INJECTABLE",
      "HTTP",
      "ROUTER"
    ];
  }
});

// node_modules/generator-begcode/dist/generators/spring-data-relational/support/mysql-reserved-keywords.js
var mysqlReservedKeywords;
var init_mysql_reserved_keywords = __esm({
  "node_modules/generator-begcode/dist/generators/spring-data-relational/support/mysql-reserved-keywords.js"() {
    mysqlReservedKeywords = [
      "ACCESSIBLE",
      "ADD",
      "ALL",
      "ALTER",
      "ANALYZE",
      "AND",
      "AS",
      "ASC",
      "ASENSITIVE",
      "BEFORE",
      "BETWEEN",
      "BIGINT",
      "BINARY",
      "BLOB",
      "BOTH",
      "BY",
      "CALL",
      "CASCADE",
      "CASE",
      "CHANGE",
      "CHAR",
      "CHARACTER",
      "CHECK",
      "COLLATE",
      "COLUMN",
      "CONDITION",
      "CONSTRAINT",
      "CONTINUE",
      "CONVERT",
      "CREATE",
      "CROSS",
      "CUME_DIST",
      "CURRENT_DATE",
      "CURRENT_TIME",
      "CURRENT_TIMESTAMP",
      "CURRENT_USER",
      "CURSOR",
      "DATABASE",
      "DATABASES",
      "DAY_HOUR",
      "DAY_MICROSECOND",
      "DAY_MINUTE",
      "DAY_SECOND",
      "DEC",
      "DECIMAL",
      "DECLARE",
      "DEFAULT",
      "DELAYED",
      "DELETE",
      "DENSE_RANK",
      "DESC",
      "DESCRIBE",
      "DETERMINISTIC",
      "DISTINCT",
      "DISTINCTROW",
      "DIV",
      "DOUBLE",
      "DROP",
      "DUAL",
      "EACH",
      "ELSE",
      "ELSEIF",
      "EMPTY",
      "ENCLOSED",
      "ESCAPED",
      "EXCEPT",
      "EXISTS",
      "EXIT",
      "EXPLAIN",
      "FALSE",
      "FETCH",
      "FIRST_VALUE",
      "FLOAT",
      "FLOAT4",
      "FLOAT8",
      "FOR",
      "FORCE",
      "FOREIGN",
      "FROM",
      "FULLTEXT",
      "GRANT",
      "GROUP",
      "GROUPING",
      "GROUPS",
      "HAVING",
      "HIGH_PRIORITY",
      "HOUR_MICROSECOND",
      "HOUR_MINUTE",
      "HOUR_SECOND",
      "IF",
      "IGNORE",
      "IN",
      "INDEX",
      "INFILE",
      "INNER",
      "INOUT",
      "INSENSITIVE",
      "INSERT",
      "INT",
      "INT1",
      "INT2",
      "INT3",
      "INT4",
      "INT8",
      "INTEGER",
      "INTERVAL",
      "INTO",
      "IS",
      "ITERATE",
      "JOIN",
      "JSON_TABLE",
      "KEY",
      "KEYS",
      "KILL",
      "LAG",
      "LAST_VALUE",
      "LEAD",
      "LEADING",
      "LEAVE",
      "LEFT",
      "LIKE",
      "LIMIT",
      "LINEAR",
      "LINES",
      "LOAD",
      "LOCALTIME",
      "LOCALTIMESTAMP",
      "LOCK",
      "LONG",
      "LONGBLOB",
      "LONGTEXT",
      "LOOP",
      "LOW_PRIORITY",
      "MASTER_SSL_VERIFY_SERVER_CERT",
      "MATCH",
      "MAXVALUE",
      "MEDIUMBLOB",
      "MEDIUMINT",
      "MEDIUMTEXT",
      "MIDDLEINT",
      "MINUTE_MICROSECOND",
      "MINUTE_SECOND",
      "MOD",
      "MODIFIES",
      "NATURAL",
      "NOT",
      "NO_WRITE_TO_BINLOG",
      "NTH_VALUE",
      "NTILE",
      "NULL",
      "NUMERIC",
      "OF",
      "ON",
      "OPTIMIZE",
      "OPTION",
      "OPTIONALLY",
      "OR",
      "ORDER",
      "OUT",
      "OUTER",
      "OUTFILE",
      "OVER",
      "PERCENT_RANK",
      "PERSIST",
      "PERSIST_ONLY",
      "PRECISION",
      "PRIMARY",
      "PROCEDURE",
      "PURGE",
      "RANGE",
      "RANK",
      "RECURSIVE",
      "READ",
      "READS",
      "READ_WRITE",
      "REAL",
      "REFERENCES",
      "REGEXP",
      "RELEASE",
      "RENAME",
      "REPEAT",
      "REPLACE",
      "REQUIRE",
      "RESIGNAL",
      "RESTRICT",
      "RETURN",
      "REVOKE",
      "RIGHT",
      "RLIKE",
      "ROW_NUMBER",
      "SCHEMA",
      "SCHEMAS",
      "SECOND_MICROSECOND",
      "SELECT",
      "SENSITIVE",
      "SEPARATOR",
      "SET",
      "SHOW",
      "SIGNAL",
      "SMALLINT",
      "SPATIAL",
      "SPECIFIC",
      "SQL",
      "SQLEXCEPTION",
      "SQLSTATE",
      "SQLWARNING",
      "SQL_BIG_RESULT",
      "SQL_CALC_FOUND_ROWS",
      "SQL_SMALL_RESULT",
      "SSL",
      "STARTING",
      "STRAIGHT_JOIN",
      "SYSTEM",
      "TABLE",
      "TERMINATED",
      "THEN",
      "TINYBLOB",
      "TINYINT",
      "TINYTEXT",
      "TO",
      "TRAILING",
      "TRIGGER",
      "TRUE",
      "UNDO",
      "UNION",
      "UNIQUE",
      "UNLOCK",
      "UNSIGNED",
      "UPDATE",
      "USAGE",
      "USE",
      "USING",
      "UTC_DATE",
      "UTC_TIME",
      "UTC_TIMESTAMP",
      "VALUES",
      "VARBINARY",
      "VARCHAR",
      "VARCHARACTER",
      "VARYING",
      "WHEN",
      "WHERE",
      "WHILE",
      "WITH",
      "WRITE",
      "XOR",
      "YEAR_MONTH",
      "ZEROFILL",
      "GENERAL",
      "IGNORE_SERVER_IDS",
      "MASTER_HEARTBEAT_PERIOD",
      "MAXVALUE",
      "RESIGNAL",
      "SIGNAL",
      "SLOW",
      "WINDOW",
      "GENERATED",
      "LINK"
    ];
  }
});

// node_modules/generator-begcode/dist/generators/java/support/reserved-keywords.js
var javaReservedKeywords;
var init_reserved_keywords2 = __esm({
  "node_modules/generator-begcode/dist/generators/java/support/reserved-keywords.js"() {
    javaReservedKeywords = [
      "ABSTRACT",
      "CONTINUE",
      "FOR",
      "NEW",
      "SWITCH",
      "ASSERT",
      "DEFAULT",
      "GOTO",
      "PACKAGE",
      "SYNCHRONIZED",
      "BOOLEAN",
      "DO",
      "IF",
      "PRIVATE",
      "THIS",
      "BREAK",
      "DOUBLE",
      "IMPLEMENTS",
      "PROTECTED",
      "THROW",
      "BYTE",
      "ELSE",
      "IMPORT",
      "PUBLIC",
      "THROWS",
      "CASE",
      "ENUM",
      "INSTANCEOF",
      "RETURN",
      "TRANSIENT",
      "CATCH",
      "EXTENDS",
      "INT",
      "SHORT",
      "TRY",
      "CHAR",
      "FINAL",
      "INTERFACE",
      "STATIC",
      "VOID",
      "CLASS",
      "FINALLY",
      "LONG",
      "STRICTFP",
      "VOLATILE",
      "CONST",
      "FLOAT",
      "NATIVE",
      "SUPER",
      "WHILE"
    ];
  }
});

// node_modules/generator-begcode/dist/generators/client/support/typescript.js
var typescriptReservedKeywords;
var init_typescript = __esm({
  "node_modules/generator-begcode/dist/generators/client/support/typescript.js"() {
    typescriptReservedKeywords = [
      "BREAK",
      "CASE",
      "CATCH",
      "CLASS",
      "CONST",
      "CONSTRUCTOR",
      "CONTINUE",
      "DEBUGGER",
      "DEFAULT",
      "DELETE",
      "DO",
      "ELSE",
      "ENUM",
      "EXPORT",
      "EXTENDS",
      "FALSE",
      "FINALLY",
      "FOR",
      "FUNCTION",
      "IF",
      "IMPORT",
      "IN",
      "INSTANCEOF",
      "NEW",
      "NULL",
      "RETURN",
      "SUPER",
      "SWITCH",
      "THIS",
      "THROW",
      "TRUE",
      "TRY",
      "TYPEOF",
      "VAR",
      "VOID",
      "WHILE",
      "WITH",
      "IMPLEMENTS",
      "INTERFACE",
      "LET",
      "PACKAGE",
      "PRIVATE",
      "PROTECTED",
      "PUBLIC",
      "STATIC",
      "YIELD"
    ];
  }
});

// node_modules/generator-begcode/dist/generators/spring-data-relational/support/postgresql-reserved-keywords.js
var postgresqlReservedKeywords;
var init_postgresql_reserved_keywords = __esm({
  "node_modules/generator-begcode/dist/generators/spring-data-relational/support/postgresql-reserved-keywords.js"() {
    postgresqlReservedKeywords = [
      "ALL",
      "ANALYSE",
      "ANALYZE",
      "AND",
      "ANY",
      "ARRAY",
      "AS",
      "ASC",
      "ASYMMETRIC",
      "AUTHORIZATION",
      "BINARY",
      "BOTH",
      "CASE",
      "CAST",
      "CHECK",
      "COLLATE",
      "COLLATION",
      "COLUMN",
      "CONCURRENTLY",
      "CONSTRAINT",
      "CREATE",
      "CROSS",
      "CURRENT_CATALOG",
      "CURRENT_DATE",
      "CURRENT_ROLE",
      "CURRENT_SCHEMA",
      "CURRENT_TIME",
      "CURRENT_TIMESTAMP",
      "CURRENT_USER",
      "DEFAULT",
      "DEFERRABLE",
      "DESC",
      "DISTINCT",
      "DO",
      "ELSE",
      "END",
      "EXCEPT",
      "FALSE",
      "FETCH",
      "FOR",
      "FOREIGN",
      "FROM",
      "FULL",
      "GRANT",
      "GROUP",
      "HAVING",
      "ILIKE",
      "IN",
      "INITIALLY",
      "INNER",
      "INTERSECT",
      "INTO",
      "IS",
      "ISNULL",
      "JOIN",
      "LATERAL",
      "LEADING",
      "LEFT",
      "LIKE",
      "LIMIT",
      "LOCALTIME",
      "LOCALTIMESTAMP",
      "NATURAL",
      "NOT",
      "NOTNULL",
      "NULL",
      "OFFSET",
      "ON",
      "ONLY",
      "OR",
      "ORDER",
      "OUTER",
      "OVERLAPS",
      "PLACING",
      "PRIMARY",
      "REFERENCES",
      "RETURNING",
      "RIGHT",
      "SELECT",
      "SESSION_USER",
      "SIMILAR",
      "SOME",
      "SYMMETRIC",
      "TABLE",
      "THEN",
      "TO",
      "TRAILING",
      "TRUE",
      "UNION",
      "UNIQUE",
      "USER",
      "USING",
      "VARIADIC",
      "VERBOSE",
      "WHEN",
      "WHERE",
      "WINDOW",
      "WITH"
    ];
  }
});

// node_modules/generator-begcode/dist/generators/spring-data-cassandra/support/reserved-keywords.js
var cassandraReservedKeywords;
var init_reserved_keywords3 = __esm({
  "node_modules/generator-begcode/dist/generators/spring-data-cassandra/support/reserved-keywords.js"() {
    cassandraReservedKeywords = [
      "ADD",
      "ALL",
      "ALTER",
      "AND",
      "ANY",
      "APPLY",
      "AS",
      "ASC",
      "ASCII",
      "AUTHORIZE",
      "BATCH",
      "BEGIN",
      "BIGINT",
      "BLOB",
      "BOOLEAN",
      "BY",
      "CLUSTERING",
      "COLUMNFAMILY",
      "COMPACT",
      "CONSISTENCY",
      "COUNT",
      "COUNTER",
      "CREATE",
      "DECIMAL",
      "DELETE",
      "DESC",
      "DOUBLE",
      "DROP",
      "EACH_QUORUM",
      "FLOAT",
      "FROM",
      "GRANT",
      "IN",
      "INDEX",
      "CUSTOM",
      "INSERT",
      "INT",
      "INTO",
      "KEY",
      "KEYSPACE",
      "LEVEL",
      "LIMIT",
      "LOCAL_ONE",
      "LOCAL_QUORUM",
      "MODIFY",
      "NORECURSIVE",
      "NOSUPERUSER",
      "OF",
      "ON",
      "ONE",
      "ORDER",
      "PASSWORD",
      "PERMISSION",
      "PERMISSIONS",
      "PRIMARY",
      "QUORUM",
      "REVOKE",
      "SCHEMA",
      "SELECT",
      "SET",
      "STORAGE",
      "SUPERUSER",
      "TABLE",
      "TEXT",
      "TIMESTAMP",
      "TIMEUUID",
      "THREE",
      "TOKEN",
      "TRUNCATE",
      "TTL",
      "TWO",
      "TYPE",
      "UPDATE",
      "USE",
      "USER",
      "USERS",
      "USING",
      "UUID",
      "VALUES",
      "VARCHAR",
      "VARINT",
      "WHERE",
      "WITH",
      "WRITETIME",
      "DISTINCT",
      "BYTE",
      "SMALLINT",
      "COMPLEX",
      "ENUM",
      "DATE",
      "INTERVAL",
      "MACADDR",
      "BITSTRING"
    ];
  }
});

// node_modules/generator-begcode/dist/generators/spring-data-couchbase/support/reserved-keywords.js
var couchbaseReservedKeywords;
var init_reserved_keywords4 = __esm({
  "node_modules/generator-begcode/dist/generators/spring-data-couchbase/support/reserved-keywords.js"() {
    couchbaseReservedKeywords = [
      "ALL",
      "AND",
      "ANY",
      "APPLY",
      "AS",
      "ASC",
      "AT",
      "AUTOGENERATED",
      "BETWEEN",
      "BTREE",
      "BUCKET",
      "BY",
      "CASE",
      "CLOSED",
      "CREATE",
      "COMPACTION",
      "COMPACT",
      "CONNECT",
      "CONNECTED",
      "CORRELATE",
      "COLLECTION",
      "DATASET",
      "DATAVERSE",
      "DECLARE",
      "DEFINITION",
      "DECLARE",
      "DEFINITION",
      "DELETE",
      "DESC",
      "DISCONNECT",
      "DISTINCT",
      "DROP",
      "ELEMENT",
      "EXPLAIN",
      "ELSE",
      "ENFORCED",
      "END",
      "EVERY",
      "EXCEPT",
      "EXISTS",
      "EXTERNAL",
      "FEED",
      "FILTER",
      "FLATTEN",
      "FOR",
      "FROM",
      "FULL",
      "FUNCTION",
      "GROUP",
      "HAVING",
      "HINTS",
      "IF",
      "INTO",
      "IN",
      "INDEX",
      "INGESTION",
      "INNER",
      "INSERT",
      "INTERNAL",
      "INTERSECT",
      "IS",
      "JOIN",
      "KEYWORD",
      "KEY",
      "LEFT",
      "LETTING",
      "LET",
      "LIKE",
      "LIMIT",
      "LOAD",
      "NODEGROUP",
      "NGRAM",
      "NOT",
      "OFFSET",
      "ON",
      "OPEN",
      "OR",
      "ORDER",
      "OUTER",
      "OUTPUT",
      "PATH",
      "POLICY",
      "PRE-SORTED",
      "PRIMARY",
      "RAW",
      "REFRESH",
      "RETURN",
      "RTREE",
      "RUN",
      "SATISFIES",
      "SECONDARY",
      "SELECT",
      "SET",
      "SHADOW",
      "SOME",
      "TEMPORARY",
      "THEN",
      "TYPE",
      "TO",
      "UNION",
      "UNKNOWN",
      "UNNEST",
      "UPDATE",
      "USE",
      "USING",
      "VALUE",
      "WHEN",
      "WHERE",
      "WITH",
      "WRITE"
    ];
  }
});

// node_modules/generator-begcode/dist/generators/spring-data-relational/support/oracle-reserved-keywords.js
var oracleReservedKeywords;
var init_oracle_reserved_keywords = __esm({
  "node_modules/generator-begcode/dist/generators/spring-data-relational/support/oracle-reserved-keywords.js"() {
    oracleReservedKeywords = [
      "ACCESS",
      "ACCOUNT",
      "ACTIVATE",
      "ADD",
      "ADMIN",
      "ADVISE",
      "AFTER",
      "ALL",
      "ALL_ROWS",
      "ALLOCATE",
      "ALTER",
      "ANALYZE",
      "AND",
      "ANY",
      "ARCHIVE",
      "ARCHIVELOG",
      "ARRAY",
      "AS",
      "ASC",
      "AT",
      "AUDIT",
      "AUTHENTICATED",
      "AUTHORIZATION",
      "AUTOEXTEND",
      "AUTOMATIC",
      "BACKUP",
      "BECOME",
      "BEFORE",
      "BEGIN",
      "BETWEEN",
      "BFILE",
      "BITMAP",
      "BLOB",
      "BLOCK",
      "BODY",
      "BY",
      "CACHE",
      "CACHE_INSTANCES",
      "CANCEL",
      "CASCADE",
      "CAST",
      "CFILE",
      "CHAINED",
      "CHANGE",
      "CHAR",
      "CHAR_CS",
      "CHARACTER",
      "CHECK",
      "CHECKPOINT",
      "CHOOSE",
      "CHUNK",
      "CLEAR",
      "CLOB",
      "CLONE",
      "CLOSE",
      "CLOSE_CACHED_OPEN_CURSORS",
      "CLUSTER",
      "COALESCE",
      "COLUMN",
      "COLUMNS",
      "COMMENT",
      "COMMIT",
      "COMMITTED",
      "COMPATIBILITY",
      "COMPILE",
      "COMPLETE",
      "COMPOSITE_LIMIT",
      "COMPRESS",
      "COMPUTE",
      "CONNECT",
      "CONNECT_TIME",
      "CONSTRAINT",
      "CONSTRAINTS",
      "CONTENTS",
      "CONTINUE",
      "CONTROLFILE",
      "CONVERT",
      "COST",
      "CPU_PER_CALL",
      "CPU_PER_SESSION",
      "CREATE",
      "CURRENT",
      "CURRENT_SCHEMA",
      "CURREN_USER",
      "CURSOR",
      "CYCLE",
      " ",
      "DANGLING",
      "DATABASE",
      "DATAFILE",
      "DATAFILES",
      "DATAOBJNO",
      "DATE",
      "DBA",
      "DBHIGH",
      "DBLOW",
      "DBMAC",
      "DEALLOCATE",
      "DEBUG",
      "DEC",
      "DECIMAL",
      "DECLARE",
      "DEFAULT",
      "DEFERRABLE",
      "DEFERRED",
      "DEGREE",
      "DELETE",
      "DEREF",
      "DESC",
      "DIRECTORY",
      "DISABLE",
      "DISCONNECT",
      "DISMOUNT",
      "DISTINCT",
      "DISTRIBUTED",
      "DML",
      "DOUBLE",
      "DROP",
      "DUMP",
      "EACH",
      "ELSE",
      "ENABLE",
      "END",
      "ENFORCE",
      "ENTRY",
      "ESCAPE",
      "EXCEPT",
      "EXCEPTIONS",
      "EXCHANGE",
      "EXCLUDING",
      "EXCLUSIVE",
      "EXECUTE",
      "EXISTS",
      "EXPIRE",
      "EXPLAIN",
      "EXTENT",
      "EXTENTS",
      "EXTERNALLY",
      "FAILED_LOGIN_ATTEMPTS",
      "FALSE",
      "FAST",
      "FILE",
      "FIRST_ROWS",
      "FLAGGER",
      "FLOAT",
      "FLOB",
      "FLUSH",
      "FOR",
      "FORCE",
      "FOREIGN",
      "FREELIST",
      "FREELISTS",
      "FROM",
      "FULL",
      "FUNCTION",
      "GLOBAL",
      "GLOBALLY",
      "GLOBAL_NAME",
      "GRANT",
      "GROUP",
      "GROUPS",
      "HASH",
      "HASHKEYS",
      "HAVING",
      "HEADER",
      "HEAP",
      "IDENTIFIED",
      "IDGENERATORS",
      "IDLE_TIME",
      "IF",
      "IMMEDIATE",
      "IN",
      "INCLUDING",
      "INCREMENT",
      "INDEX",
      "INDEXED",
      "INDEXES",
      "INDICATOR",
      "IND_PARTITION",
      "INITIAL",
      "INITIALLY",
      "INITRANS",
      "INSERT",
      "INSTANCE",
      "INSTANCES",
      "INSTEAD",
      "INT",
      "INTEGER",
      "INTERMEDIATE",
      "INTERSECT",
      "INTO",
      "IS",
      "ISOLATION",
      "ISOLATION_LEVEL",
      "KEEP",
      "KEY",
      "KILL",
      "LABEL",
      "LAYER",
      "LESS",
      "LEVEL",
      "LIBRARY",
      "LIKE",
      "LIMIT",
      "LINK",
      "LIST",
      "LOB",
      "LOCAL",
      "LOCK",
      "LOCKED",
      "LOG",
      "LOGFILE",
      "LOGGING",
      "LOGICAL_READS_PER_CALL",
      "LOGICAL_READS_PER_SESSION",
      "LONG",
      "MANAGE",
      "MASTER",
      "MAX",
      "MAXARCHLOGS",
      "MAXDATAFILES",
      "MAXEXTENTS",
      "MAXINSTANCES",
      "MAXLOGFILES",
      "MAXLOGHISTORY",
      "MAXLOGMEMBERS",
      "MAXSIZE",
      "MAXTRANS",
      "MAXVALUE",
      "MIN",
      "MEMBER",
      "MINIMUM",
      "MINEXTENTS",
      "MINUS",
      "MINVALUE",
      "MLSLABEL",
      "MLS_LABEL_FORMAT",
      "MODE",
      "MODIFY",
      "MOUNT",
      "MOVE",
      "MTS_DISPATCHERS",
      "MULTISET",
      "NATIONAL",
      "NCHAR",
      "NCHAR_CS",
      "NCLOB",
      "NEEDED",
      "NESTED",
      "NETWORK",
      "NEW",
      "NEXT",
      "NOARCHIVELOG",
      "NOAUDIT",
      "NOCACHE",
      "NOCOMPRESS",
      "NOCYCLE",
      "NOFORCE",
      "NOLOGGING",
      "NOMAXVALUE",
      "NOMINVALUE",
      "NONE",
      "NOORDER",
      "NOOVERRIDE",
      "NOPARALLEL",
      "NOPARALLEL",
      "NOREVERSE",
      "NORMAL",
      "NOSORT",
      "NOT",
      "NOTHING",
      "NOWAIT",
      "NULL",
      "NUMBER",
      "NUMERIC",
      "NVARCHAR2",
      "OBJECT",
      "OBJNO",
      "OBJNO_REUSE",
      "OF",
      "OFF",
      "OFFLINE",
      "OID",
      "OIDINDEX",
      "OLD",
      "ON",
      "ONLINE",
      "ONLY",
      "OPCODE",
      "OPEN",
      "OPTIMAL",
      "OPTIMIZER_GOAL",
      "OPTION",
      "OR",
      "ORDER",
      "ORGANIZATION",
      "OSLABEL",
      "OVERFLOW",
      "OWN",
      "PACKAGE",
      "PARALLEL",
      "PARTITION",
      "PASSWORD",
      "PASSWORD_GRACE_TIME",
      "PASSWORD_LIFE_TIME",
      "PASSWORD_LOCK_TIME",
      "PASSWORD_REUSE_MAX",
      "PASSWORD_REUSE_TIME",
      "PASSWORD_VERIFY_FUNCTION",
      "PCTFREE",
      "PCTINCREASE",
      "PCTTHRESHOLD",
      "PCTUSED",
      "PCTVERSION",
      "PERCENT",
      "PERMANENT",
      "PLAN",
      "PLSQL_DEBUG",
      "POST_TRANSACTION",
      "PRECISION",
      "PRESERVE",
      "PRIMARY",
      "PRIOR",
      "PRIVATE",
      "PRIVATE_SGA",
      "PRIVILEGE",
      "PRIVILEGES",
      "PROCEDURE",
      "PROFILE",
      "PUBLIC",
      "PURGE",
      "QUEUE",
      "QUOTA",
      "RANGE",
      "RAW",
      "RBA",
      "READ",
      "READUP",
      "REAL",
      "REBUILD",
      "RECOVER",
      "RECOVERABLE",
      "RECOVERY",
      "REF",
      "REFERENCES",
      "REFERENCING",
      "REFRESH",
      "RENAME",
      "REPLACE",
      "RESET",
      "RESETLOGS",
      "RESIZE",
      "RESOURCE",
      "RESTRICTED",
      "RETURN",
      "RETURNING",
      "REUSE",
      "REVERSE",
      "REVOKE",
      "ROLE",
      "ROLES",
      "ROLLBACK",
      "ROW",
      "ROWID",
      "ROWNUM",
      "ROWS",
      "RULE",
      "SAMPLE",
      "SAVEPOINT",
      "SB4",
      "SCAN_INSTANCES",
      "SCHEMA",
      "SCN",
      "SCOPE",
      "SD_ALL",
      "SD_INHIBIT",
      "SD_SHOW",
      "SEGMENT",
      "SEG_BLOCK",
      "SEG_FILE",
      "SELECT",
      "SEQUENCE",
      "SERIALIZABLE",
      "SESSION",
      "SESSION_CACHED_CURSORS",
      "SESSIONS_PER_USER",
      "SET",
      "SHARE",
      "SHARED",
      "SHARED_POOL",
      "SHRINK",
      "SIZE",
      "SKIP",
      "SKIP_UNUSABLE_INDEXES",
      "SMALLINT",
      "SNAPSHOT",
      "SOME",
      "SORT",
      "SPECIFICATION",
      "SPLIT",
      "SQL_TRACE",
      "STANDBY",
      "START",
      "STATEMENT_ID",
      "STATISTICS",
      "STOP",
      "STORAGE",
      "STORE",
      "STRUCTURE",
      "SUCCESSFUL",
      "SWITCH",
      "SYS_OP_ENFORCE_NOT_NULL$",
      "SYS_OP_NTCIMG$",
      "SYNONYM",
      "SYSDATE",
      "SYSDBA",
      "SYSOPER",
      "SYSTEM",
      "TABLE",
      "TABLES",
      "TABLESPACE",
      "TABLESPACE_NO",
      "TABNO",
      "TEMPORARY",
      "THAN",
      "THE",
      "THEN",
      "THREAD",
      "TIMESTAMP",
      "TIME",
      "TO",
      "TOPLEVEL",
      "TRACE",
      "TRACING",
      "TRANSACTION",
      "TRANSITIONAL",
      "TRIGGER",
      "TRIGGERS",
      "TRUE",
      "TRUNCATE",
      "TX",
      "TYPE",
      "UB2",
      "UBA",
      "UID",
      "UNARCHIVED",
      "UNDO",
      "UNION",
      "UNIQUE",
      "UNLIMITED",
      "UNLOCK",
      "UNRECOVERABLE",
      "UNTIL",
      "UNUSABLE",
      "UNUSED",
      "UPDATABLE",
      "UPDATE",
      "USAGE",
      "USE",
      "USER",
      "USING",
      "VALIDATE",
      "VALIDATION",
      "VALUE",
      "VALUES",
      "VARCHAR",
      "VARCHAR2",
      "VARYING",
      "VIEW",
      "WHEN",
      "WHENEVER",
      "WHERE",
      "WITH",
      "WITHOUT",
      "WORK",
      "WRITE",
      "WRITEDOWN",
      "WRITEUP",
      "XID",
      "YEAR",
      "ZONE"
    ];
  }
});

// node_modules/generator-begcode/dist/generators/spring-data-relational/support/mssql-reserved-keywords.js
var mssqlReservedKeywords;
var init_mssql_reserved_keywords = __esm({
  "node_modules/generator-begcode/dist/generators/spring-data-relational/support/mssql-reserved-keywords.js"() {
    mssqlReservedKeywords = [
      "ADD",
      "ALL",
      "ALTER",
      "AND",
      "ANY",
      "AS",
      "ASC",
      "AUTHORIZATION",
      "BACKUP",
      "BEGIN",
      "BETWEEN",
      "BREAK",
      "BROWSE",
      "BULK",
      "BY",
      "CASCADE",
      "CASE",
      "CHECK",
      "CHECKPOINT",
      "CLOSE",
      "CLUSTERED",
      "COALESCE",
      "COLLATE",
      "COLUMN",
      "COMMIT",
      "COMPUTE",
      "CONSTRAINT",
      "CONTAINS",
      "CONTAINSTABLE",
      "CONTINUE",
      "CONVERT",
      "CREATE",
      "CROSS",
      "CURRENT",
      "CURRENT_DATE",
      "CURRENT_TIME",
      "CURRENT_TIMESTAMP",
      "CURRENT_USER",
      "CURSOR",
      "DATABASE",
      "DBCC",
      "DEALLOCATE",
      "DECLARE",
      "DEFAULT",
      "DELETE",
      "DENY",
      "DESC",
      "DISK",
      "DISTINCT",
      "DISTRIBUTED",
      "DOUBLE",
      "DROP",
      "DUMP",
      "ELSE",
      "END",
      "ERRLVL",
      "ESCAPE",
      "EXCEPT",
      "EXEC",
      "EXECUTE",
      "EXISTS",
      "EXIT",
      "EXTERNAL",
      "FETCH",
      "FILE",
      "FILLFACTOR",
      "FOR",
      "FOREIGN",
      "FREETEXT",
      "FREETEXTTABLE",
      "FROM",
      "FULL",
      "FUNCTION",
      "GOTO",
      "GRANT",
      "GROUP",
      "HAVING",
      "HOLDLOCK",
      "IDENTITY",
      "IDENTITY_INSERT",
      "IDENTITYCOL",
      "IF",
      "IN",
      "INDEX",
      "INNER",
      "INSERT",
      "INTERSECT",
      "INTO",
      "IS",
      "JOIN",
      "KEY",
      "KILL",
      "LEFT",
      "LIKE",
      "LINENO",
      "LOAD",
      "MERGE",
      "NATIONAL",
      "NOCHECK",
      "NONCLUSTERED",
      "NOT",
      "NULL",
      "NULLIF",
      "OF",
      "OFF",
      "OFFSETS",
      "ON",
      "OPEN",
      "OPENDATASOURCE",
      "OPENQUERY",
      "OPENROWSET",
      "OPENXML",
      "OPTION",
      "OR",
      "ORDER",
      "OUTER",
      "OVER",
      "PERCENT",
      "PIVOT",
      "PLAN",
      "PRECISION",
      "PRIMARY",
      "PRINT",
      "PROC",
      "PROCEDURE",
      "PUBLIC",
      "RAISERROR",
      "READ",
      "READTEXT",
      "RECONFIGURE",
      "REFERENCES",
      "REPLICATION",
      "RESTORE",
      "RESTRICT",
      "RETURN",
      "REVERT",
      "REVOKE",
      "RIGHT",
      "ROLLBACK",
      "ROWCOUNT",
      "ROWGUIDCOL",
      "RULE",
      "SAVE",
      "SCHEMA",
      "SECURITYAUDIT",
      "SELECT",
      "SEMANTICKEYPHRASETABLE",
      "SEMANTICSIMILARITYDETAILSTABLE",
      "SEMANTICSIMILARITYTABLE",
      "SESSION_USER",
      "SET",
      "SETUSER",
      "SHUTDOWN",
      "SOME",
      "STATISTICS",
      "SYSTEM_USER",
      "TABLE",
      "TABLESAMPLE",
      "TEXTSIZE",
      "THEN",
      "TO",
      "TOP",
      "TRAN",
      "TRANSACTION",
      "TRIGGER",
      "TRUNCATE",
      "TRY_CONVERT",
      "TSEQUAL",
      "UNION",
      "UNIQUE",
      "UNPIVOT",
      "UPDATE",
      "UPDATETEXT",
      "USE",
      "USER",
      "VALUES",
      "VARYING",
      "VIEW",
      "WAITFOR",
      "WHEN",
      "WHERE",
      "WHILE",
      "WITH",
      "WITHIN GROUP",
      "WRITETEXT"
    ];
  }
});

// node_modules/generator-begcode/dist/generators/spring-data-neo4j/support/reserved-keywords.js
var neo4jReservedKeywords;
var init_reserved_keywords5 = __esm({
  "node_modules/generator-begcode/dist/generators/spring-data-neo4j/support/reserved-keywords.js"() {
    neo4jReservedKeywords = [
      "CALL",
      "CREATE",
      "DELETE",
      "DETACH",
      "EXISTS",
      "FOREACH",
      "LOAD",
      "MATCH",
      "MERGE",
      "OPTIONAL",
      "REMOVE",
      "RETURN",
      "SET",
      "START",
      "UNION",
      "UNWIND",
      "WITH",
      "LIMIT",
      "ORDER",
      "SKIP",
      "WHERE",
      "YIELD",
      "ASC",
      "ASCENDING",
      "ASSERT",
      "BY",
      "CSV",
      "DESC",
      "DESCENDING",
      "ON",
      "ALL",
      "CASE",
      "ELSE",
      "END",
      "THEN",
      "WHEN",
      "AND",
      "AS",
      "CONTAINS",
      "DISTINCT",
      "ENDS",
      "IN",
      "IS",
      "NOT",
      "OR",
      "STARTS",
      "XOR",
      "CONSTRAINT",
      "CREATE",
      "DROP",
      "EXISTS",
      "INDEX",
      "NODE",
      "KEY",
      "UNIQUE",
      "INDEX",
      "JOIN",
      "PERIODIC",
      "COMMIT",
      "SCAN",
      "USING",
      "false",
      "null",
      "true",
      "ADD",
      "DO",
      "FOR",
      "MANDATORY",
      "OF",
      "REQUIRE",
      "SCALAR"
    ];
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/reserved-keywords.js
function isReserved(keyword, type) {
  return !!keyword && !!type && !!keywordsForType(type)?.includes(keyword.toUpperCase());
}
function isReservedClassName(keyword) {
  return isReserved(keyword, "JHIPSTER") || isReserved(keyword, "ANGULAR") || isReserved(keyword, "TYPESCRIPT") || isReserved(keyword, "JAVA");
}
function isReservedTableName(keyword, databaseType) {
  return databaseType.toUpperCase() === "SQL" ? isReserved(keyword, "MYSQL") || isReserved(keyword, "POSTGRESQL") || isReserved(keyword, "ORACLE") || isReserved(keyword, "MSSQL") : isReserved(keyword, databaseType);
}
function isReservedPaginationWords(keyword) {
  return isReserved(keyword, "PAGING");
}
function isReservedFieldName(keyword, clientFramework) {
  if (clientFramework) {
    if (clientFramework === clientFrameworks.angular) {
      return isReserved(keyword, "ANGULAR") || isReserved(keyword, "TYPESCRIPT") || isReserved(keyword, "JAVA");
    }
    if (clientFramework === clientFrameworks.react) {
      return isReserved(keyword, "TYPESCRIPT") || isReserved(keyword, "JAVA");
    }
  }
  return isReserved(keyword, "ANGULAR") || isReserved(keyword, "TYPESCRIPT") || isReserved(keyword, "JAVA");
}
var clientFrameworks, ReservedWords, keywordsForType, reserved_keywords_default;
var init_reserved_keywords6 = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/reserved-keywords.js"() {
    init_jhipster();
    init_paging();
    init_reserved_keywords();
    init_mysql_reserved_keywords();
    init_reserved_keywords2();
    init_typescript();
    init_postgresql_reserved_keywords();
    init_reserved_keywords3();
    init_reserved_keywords4();
    init_oracle_reserved_keywords();
    init_mssql_reserved_keywords();
    init_reserved_keywords5();
    init_application_options2();
    clientFrameworks = application_options_default.OptionValues[application_options_default.OptionNames.CLIENT_FRAMEWORK];
    ReservedWords = {
      JHIPSTER: jhipster_default,
      ANGULAR: angularReservedKeywords,
      REACT: [],
      JAVA: javaReservedKeywords,
      TYPESCRIPT: typescriptReservedKeywords,
      MYSQL: mysqlReservedKeywords,
      MARIADB: mysqlReservedKeywords,
      POSTGRESQL: postgresqlReservedKeywords,
      PAGING: paging_default,
      CASSANDRA: cassandraReservedKeywords,
      COUCHBASE: couchbaseReservedKeywords,
      ORACLE: oracleReservedKeywords,
      MONGODB: ["DOCUMENT"],
      MSSQL: mssqlReservedKeywords,
      NEO4J: neo4jReservedKeywords
    };
    keywordsForType = (type) => ReservedWords[type.toUpperCase()];
    reserved_keywords_default = {
      isReserved,
      isReservedClassName,
      isReservedTableName,
      isReservedFieldName,
      isReservedPaginationWords,
      JHIPSTER: ReservedWords.JHIPSTER,
      ANGULAR: ReservedWords.ANGULAR,
      REACT: ReservedWords.REACT,
      JAVA: ReservedWords.JAVA,
      TYPESCRIPT: ReservedWords.TYPESCRIPT,
      MYSQL: ReservedWords.MYSQL,
      POSTGRESQL: ReservedWords.POSTGRESQL,
      CASSANDRA: ReservedWords.CASSANDRA,
      COUCHBASE: ReservedWords.COUCHBASE,
      ORACLE: ReservedWords.ORACLE,
      MONGODB: ReservedWords.MONGODB,
      MSSQL: ReservedWords.MSSQL,
      NEO4J: ReservedWords.NEO4J
    };
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/unary-options.js
var Options4, optionNames3, unary_options_default;
var init_unary_options = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/unary-options.js"() {
    init_application_options2();
    Options4 = {
      SKIP_CLIENT: application_options_default.OptionNames.SKIP_CLIENT,
      SKIP_SERVER: application_options_default.OptionNames.SKIP_SERVER,
      NO_FLUENT_METHOD: "noFluentMethod",
      READ_ONLY: "readOnly",
      FILTER: "filter",
      EMBEDDED: "embedded"
    };
    optionNames3 = Object.values(Options4);
    Options4.forEach = (passedFunction) => {
      if (!passedFunction) {
        throw new Error("A function has to be passed to loop over the unary options.");
      }
      optionNames3.forEach((optionName) => {
        passedFunction(optionName);
      });
    };
    Options4.exists = (option) => Object.values(Options4).includes(option);
    unary_options_default = Options4;
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/relationship-on-handler-options.js
function checkAndReturnRelationshipOnValue(onValue, generator) {
  let result = onValue;
  if (result) {
    if (!validOptions.includes(result)) {
      generator.log.warn(`Invalid value '${result}' for onDelete or onUpdate - resetting to undefined.`);
      result = void 0;
    }
  }
  return result;
}
var validOptions;
var init_relationship_on_handler_options = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/relationship-on-handler-options.js"() {
    validOptions = ["NO ACTION", "RESTRICT", "CASCADE", "SET NULL", "SET DEFAULT"];
  }
});

// node_modules/generator-begcode/dist/jdl/jhipster/index.js
var init_jhipster2 = __esm({
  "node_modules/generator-begcode/dist/jdl/jhipster/index.js"() {
    init_default_application_options();
    init_application_options2();
    init_application_types();
    init_authentication_types();
    init_binary_options();
    init_build_tool_types();
    init_cache_types();
    init_client_framework_types();
    init_database_types();
    init_deployment_options();
    init_entity_options();
    init_entity_table_name_creator();
    init_entity_table_name_creator();
    init_field_types();
    init_json_entity();
    init_kubernetes_platform_types();
    init_message_broker_types();
    init_monitoring_types();
    init_openapi_options();
    init_openshift_platform_types();
    init_relationship_options();
    init_relationship_types();
    init_aigc_types();
    init_reserved_keywords6();
    init_search_engine_types();
    init_service_discovery_types();
    init_test_framework_types();
    init_unary_options();
    init_validations();
    init_validations();
    init_websocket_types();
    init_relationship_on_handler_options();
    init_kubernetes_platform_types();
    init_default_application_options();
    init_application_types();
  }
});

// node_modules/generator-begcode/dist/jdl/parsing/lexer/token-creator.js
function createTokenFromConfig(config) {
  if (!config) {
    throw new Error("Can't create a token without the proper config.");
  }
  if (isString_default(config.pattern) && namePattern.test(config.pattern)) {
    config.longer_alt = nameToken;
    if (!config.categories) {
      config.categories = [];
    }
    if (!Array.isArray(config.categories)) {
      config.categories = [config.categories];
    }
    config.categories.push(keywordToken);
  }
  if (isString_default(config.pattern) && !config.label) {
    config.label = `'${config.pattern}'`;
  }
  return createToken(config);
}
var init_token_creator = __esm({
  "node_modules/generator-begcode/dist/jdl/parsing/lexer/token-creator.js"() {
    init_lodash();
    init_api5();
    init_shared_tokens();
  }
});

// node_modules/generator-begcode/dist/jdl/parsing/lexer/minmax-tokens.js
var mixMaxCategoryToken, minMaxTokens, minmax_tokens_default;
var init_minmax_tokens = __esm({
  "node_modules/generator-begcode/dist/jdl/parsing/lexer/minmax-tokens.js"() {
    init_api5();
    init_shared_tokens();
    init_token_creator();
    mixMaxCategoryToken = createTokenFromConfig({ name: "MIN_MAX_KEYWORD", pattern: Lexer.NA, categories: keywordToken });
    minMaxTokens = [
      { name: "MINLENGTH", pattern: "minlength" },
      { name: "MAXLENGTH", pattern: "maxlength" },
      { name: "MINBYTES", pattern: "minbytes" },
      { name: "MAXBYTES", pattern: "maxbytes" },
      { name: "MIN", pattern: "min" },
      { name: "MAX", pattern: "max" }
    ].map((tokenConfig) => {
      tokenConfig.categories = [mixMaxCategoryToken];
      return createTokenFromConfig(tokenConfig);
    });
    minmax_tokens_default = {
      categoryToken: mixMaxCategoryToken,
      tokens: [mixMaxCategoryToken, ...minMaxTokens]
    };
  }
});

// node_modules/generator-begcode/dist/jdl/parsing/lexer/validation-tokens.js
var validationTokens, validation_tokens_default;
var init_validation_tokens = __esm({
  "node_modules/generator-begcode/dist/jdl/parsing/lexer/validation-tokens.js"() {
    init_token_creator();
    init_minmax_tokens();
    validationTokens = [
      { name: "REQUIRED", pattern: "required" },
      { name: "UNIQUE", pattern: "unique" },
      { name: "PATTERN", pattern: "pattern" }
    ].map(createTokenFromConfig);
    validation_tokens_default = {
      tokens: [...validationTokens, ...minmax_tokens_default.tokens]
    };
  }
});

// node_modules/generator-begcode/dist/generators/app/jdl/index.js
var init_jdl2 = __esm({
  "node_modules/generator-begcode/dist/generators/app/jdl/index.js"() {
    init_application_options();
  }
});

// node_modules/generator-begcode/dist/jdl/parsing/lexer/application-tokens.js
var OptionNames3, APPLICATION_TYPE2, AUTHENTICATION_TYPE2, BASE_NAME2, BLUEPRINT, BLUEPRINTS, BUILD_TOOL2, CACHE_PROVIDER2, CLIENT_FRAMEWORK2, CLIENT_PACKAGE_MANAGER2, CLIENT_THEME2, CLIENT_THEME_VARIANT2, CREATION_TIMESTAMP, DATABASE_TYPE2, DEV_DATABASE_TYPE2, DTO_SUFFIX2, EMBEDDABLE_LAUNCH_SCRIPT, ENABLE_HIBERNATE_CACHE2, ENABLE_SWAGGER_CODEGEN2, ENABLE_TRANSLATION2, ENTITY_SUFFIX2, GATEWAY_SERVER_PORT, JHIPSTER_VERSION, JHI_PREFIX2, JWT_SECRET_KEY, LANGUAGES2, MICROFRONTEND, MICROFRONTENDS, NATIVE_LANGUAGE2, PACKAGE_NAME2, PROD_DATABASE_TYPE2, REACTIVE2, REMEMBER_ME_KEY, SEARCH_ENGINE2, SERVER_PORT2, SKIP_CLIENT2, SKIP_SERVER, SKIP_USER_MANAGEMENT2, TEST_FRAMEWORKS2, WEBSOCKET2, WITH_ADMIN_UI2, ENABLE_GRADLE_ENTERPRISE2, GRADLE_ENTERPRISE_HOST2, BUILT_IN_SERVICES2, MOBILE_FRAMEWORK2, MOBILE_THEME2, WITH_WEBSITE2, ORM_TOOL2, FRONT_OR_BACK, JOB_SCHEDULER, JAVA_VERSION2, USE_LOMBOK2, MULTI_MODULE2, USE_COMMON_TABLE2, USE_MULTI_TENANT2, SOFT_DELETE2, applicationConfigCategoryToken, applicationConfigTokens, application_tokens_default;
var init_application_tokens = __esm({
  "node_modules/generator-begcode/dist/jdl/parsing/lexer/application-tokens.js"() {
    init_api5();
    init_token_creator();
    init_shared_tokens();
    init_jhipster2();
    init_jdl2();
    ({ OptionNames: OptionNames3 } = application_options_default);
    ({ APPLICATION_TYPE: APPLICATION_TYPE2, AUTHENTICATION_TYPE: AUTHENTICATION_TYPE2, BASE_NAME: BASE_NAME2, BLUEPRINT, BLUEPRINTS, BUILD_TOOL: BUILD_TOOL2, CACHE_PROVIDER: CACHE_PROVIDER2, CLIENT_FRAMEWORK: CLIENT_FRAMEWORK2, CLIENT_PACKAGE_MANAGER: CLIENT_PACKAGE_MANAGER2, CLIENT_THEME: CLIENT_THEME2, CLIENT_THEME_VARIANT: CLIENT_THEME_VARIANT2, CREATION_TIMESTAMP, DATABASE_TYPE: DATABASE_TYPE2, DEV_DATABASE_TYPE: DEV_DATABASE_TYPE2, DTO_SUFFIX: DTO_SUFFIX2, EMBEDDABLE_LAUNCH_SCRIPT, ENABLE_HIBERNATE_CACHE: ENABLE_HIBERNATE_CACHE2, ENABLE_SWAGGER_CODEGEN: ENABLE_SWAGGER_CODEGEN2, ENABLE_TRANSLATION: ENABLE_TRANSLATION2, ENTITY_SUFFIX: ENTITY_SUFFIX2, GATEWAY_SERVER_PORT, JHIPSTER_VERSION, JHI_PREFIX: JHI_PREFIX2, JWT_SECRET_KEY, LANGUAGES: LANGUAGES2, MICROFRONTEND, MICROFRONTENDS, NATIVE_LANGUAGE: NATIVE_LANGUAGE2, PACKAGE_NAME: PACKAGE_NAME2, PROD_DATABASE_TYPE: PROD_DATABASE_TYPE2, REACTIVE: REACTIVE2, REMEMBER_ME_KEY, SEARCH_ENGINE: SEARCH_ENGINE2, SERVER_PORT: SERVER_PORT2, SKIP_CLIENT: SKIP_CLIENT2, SKIP_SERVER, SKIP_USER_MANAGEMENT: SKIP_USER_MANAGEMENT2, TEST_FRAMEWORKS: TEST_FRAMEWORKS2, WEBSOCKET: WEBSOCKET2, WITH_ADMIN_UI: WITH_ADMIN_UI2, ENABLE_GRADLE_ENTERPRISE: ENABLE_GRADLE_ENTERPRISE2, GRADLE_ENTERPRISE_HOST: GRADLE_ENTERPRISE_HOST2, BUILT_IN_SERVICES: BUILT_IN_SERVICES2, MOBILE_FRAMEWORK: MOBILE_FRAMEWORK2, MOBILE_THEME: MOBILE_THEME2, WITH_WEBSITE: WITH_WEBSITE2, ORM_TOOL: ORM_TOOL2, FRONT_OR_BACK, JOB_SCHEDULER, JAVA_VERSION: JAVA_VERSION2, USE_LOMBOK: USE_LOMBOK2, MULTI_MODULE: MULTI_MODULE2, USE_COMMON_TABLE: USE_COMMON_TABLE2, USE_MULTI_TENANT: USE_MULTI_TENANT2, SOFT_DELETE: SOFT_DELETE2 } = OptionNames3);
    applicationConfigCategoryToken = createTokenFromConfig({ name: "CONFIG_KEY", pattern: Lexer.NA });
    applicationConfigTokens = [
      { name: "BASE_NAME", pattern: BASE_NAME2 },
      { name: "BLUEPRINTS", pattern: BLUEPRINTS },
      { name: "BLUEPRINT", pattern: BLUEPRINT },
      { name: "EMBEDDABLE_LAUNCH_SCRIPT", pattern: EMBEDDABLE_LAUNCH_SCRIPT },
      { name: "CREATION_TIMESTAMP", pattern: CREATION_TIMESTAMP },
      { name: "GATEWAY_SERVER_PORT", pattern: GATEWAY_SERVER_PORT },
      { name: "PACKAGE_NAME", pattern: PACKAGE_NAME2 },
      { name: "AUTHENTICATION_TYPE", pattern: AUTHENTICATION_TYPE2 },
      { name: "CACHE_PROVIDER", pattern: CACHE_PROVIDER2 },
      { name: "ENABLE_HIBERNATE_CACHE", pattern: ENABLE_HIBERNATE_CACHE2 },
      { name: "WEBSOCKET", pattern: WEBSOCKET2 },
      { name: "DATABASE_TYPE", pattern: DATABASE_TYPE2 },
      { name: "DEV_DATABASE_TYPE", pattern: DEV_DATABASE_TYPE2 },
      { name: "PROD_DATABASE_TYPE", pattern: PROD_DATABASE_TYPE2 },
      { name: "BUILD_TOOL", pattern: BUILD_TOOL2 },
      { name: "SEARCH_ENGINE", pattern: SEARCH_ENGINE2 },
      { name: "ENABLE_TRANSLATION", pattern: ENABLE_TRANSLATION2 },
      { name: "APPLICATION_TYPE", pattern: APPLICATION_TYPE2 },
      { name: "TEST_FRAMEWORKS", pattern: TEST_FRAMEWORKS2 },
      { name: "LANGUAGES", pattern: LANGUAGES2 },
      { name: "SERVER_PORT", pattern: SERVER_PORT2 },
      { name: "JHI_PREFIX", pattern: JHI_PREFIX2 },
      { name: "JWT_SECRET_KEY", pattern: JWT_SECRET_KEY },
      { name: "JHIPSTER_VERSION", pattern: JHIPSTER_VERSION },
      { name: "CLIENT_PACKAGE_MANAGER", pattern: CLIENT_PACKAGE_MANAGER2 },
      { name: "CLIENT_FRAMEWORK", pattern: CLIENT_FRAMEWORK2 },
      { name: "CLIENT_THEME_VARIANT", pattern: CLIENT_THEME_VARIANT2 },
      { name: "CLIENT_THEME", pattern: CLIENT_THEME2 },
      { name: "WITH_ADMIN_UI", pattern: WITH_ADMIN_UI2 },
      { name: "NATIVE_LANGUAGE", pattern: NATIVE_LANGUAGE2 },
      { name: "FRONT_END_BUILDER", pattern: "frontendBuilder" },
      { name: "SKIP_USER_MANAGEMENT", pattern: SKIP_USER_MANAGEMENT2 },
      { name: "ENABLE_SWAGGER_CODEGEN", pattern: ENABLE_SWAGGER_CODEGEN2 },
      { name: "REACTIVE", pattern: REACTIVE2 },
      { name: "ENTITY_SUFFIX", pattern: ENTITY_SUFFIX2 },
      { name: "DTO_SUFFIX", pattern: DTO_SUFFIX2 },
      { name: "SKIP_CLIENT", pattern: SKIP_CLIENT2 },
      { name: "SKIP_SERVER", pattern: SKIP_SERVER },
      { name: "REMEMBER_ME_KEY", pattern: REMEMBER_ME_KEY },
      { name: "ENABLE_GRADLE_ENTERPRISE", pattern: ENABLE_GRADLE_ENTERPRISE2 },
      { name: "GRADLE_ENTERPRISE_HOST", pattern: GRADLE_ENTERPRISE_HOST2 },
      { name: "MICROFRONTENDS", pattern: MICROFRONTENDS },
      { name: "MICROFRONTEND", pattern: MICROFRONTEND },
      { name: "BUILT_IN_SERVICES", pattern: BUILT_IN_SERVICES2 },
      { name: "MOBILE_FRAMEWORK", pattern: MOBILE_FRAMEWORK2 },
      { name: "MOBILE_THEME", pattern: MOBILE_THEME2 },
      { name: "WITH_WEBSITE", pattern: WITH_WEBSITE2 },
      { name: "ORM_TOOL", pattern: ORM_TOOL2 },
      { name: "FRONT_OR_BACK", pattern: FRONT_OR_BACK },
      { name: "JOB_SCHEDULER", pattern: JOB_SCHEDULER },
      { name: "JAVA_VERSION", pattern: JAVA_VERSION2 },
      { name: "USE_LOMBOK", pattern: USE_LOMBOK2 },
      { name: "MULTI_MODULE", pattern: MULTI_MODULE2 },
      { name: "USE_COMMON_TABLE", pattern: USE_COMMON_TABLE2 },
      { name: "USE_MULTI_TENANT", pattern: USE_MULTI_TENANT2 },
      { name: "SOFT_DELETE", pattern: SOFT_DELETE2 },
      ...application_definition_default.tokenConfigs
    ];
    application_tokens_default = {
      categoryToken: applicationConfigCategoryToken,
      tokens: [
        applicationConfigCategoryToken,
        ...applicationConfigTokens.map((tokenConfig) => {
          tokenConfig.categories = [applicationConfigCategoryToken];
          if (["SKIP_CLIENT", "SKIP_SERVER"].includes(tokenConfig.name)) {
            tokenConfig.categories.push(keywordToken);
            tokenConfig.categories.push(unaryOptionCategoryToken);
          }
          return createTokenFromConfig(tokenConfig);
        })
      ]
    };
  }
});

// node_modules/generator-begcode/dist/jdl/parsing/lexer/deployment-tokens.js
var deploymentCategoryToken, deploymentTokens, deployment_tokens_default;
var init_deployment_tokens = __esm({
  "node_modules/generator-begcode/dist/jdl/parsing/lexer/deployment-tokens.js"() {
    init_api5();
    init_token_creator();
    deploymentCategoryToken = createTokenFromConfig({
      name: "DEPLOYMENT_KEY",
      pattern: Lexer.NA
    });
    deploymentTokens = [
      { name: "APPS_FOLDERS", pattern: "appsFolders" },
      { name: "CLUSTERED_DB_APPS", pattern: "clusteredDbApps" },
      { name: "DEPLOYMENT_TYPE", pattern: "deploymentType" },
      { name: "DIRECTORY_PATH", pattern: "directoryPath" },
      { name: "DOCKER_PUSH_COMMAND", pattern: "dockerPushCommand" },
      { name: "DOCKER_REPOSITORY_NAME", pattern: "dockerRepositoryName" },
      { name: "GATEWAY_TYPE", pattern: "gatewayType" },
      { name: "INGRESS_DOMAIN", pattern: "ingressDomain" },
      { name: "INGRESS_TYPE", pattern: "ingressType" },
      { name: "ISTIO", pattern: "istio" },
      { name: "KUBERNETES_NAMESPACE", pattern: "kubernetesNamespace" },
      { name: "KUBERNETES_SERVICE_TYPE", pattern: "kubernetesServiceType" },
      { name: "KUBERNETES_STORAGE_CLASS_NAME", pattern: "kubernetesStorageClassName" },
      { name: "KUBERNETES_USE_DYNAMIC_STORAGE", pattern: "kubernetesUseDynamicStorage" },
      { name: "MONITORING", pattern: "monitoring" },
      { name: "OPENSHIFT_NAMESPACE", pattern: "openshiftNamespace" },
      { name: "REGISTRY_REPLICAS", pattern: "registryReplicas" },
      { name: "STORAGE_TYPE", pattern: "storageType" }
    ].map((tokenConfig) => {
      tokenConfig.categories = [deploymentCategoryToken];
      return createTokenFromConfig(tokenConfig);
    });
    deployment_tokens_default = {
      categoryToken: deploymentCategoryToken,
      tokens: [deploymentCategoryToken, ...deploymentTokens]
    };
  }
});

// node_modules/generator-begcode/dist/jdl/parsing/lexer/relationship-type-tokens.js
var relationshipTypeCategoryToken, relationshipTypeTokens, relationship_type_tokens_default;
var init_relationship_type_tokens = __esm({
  "node_modules/generator-begcode/dist/jdl/parsing/lexer/relationship-type-tokens.js"() {
    init_api5();
    init_relationships();
    init_token_creator();
    relationshipTypeCategoryToken = createTokenFromConfig({ name: "RELATIONSHIP_TYPE", pattern: Lexer.NA });
    relationshipTypeTokens = [
      { name: "ONE_TO_ONE", pattern: JDL_RELATIONSHIP_ONE_TO_ONE },
      { name: "ONE_TO_MANY", pattern: JDL_RELATIONSHIP_ONE_TO_MANY },
      { name: "MANY_TO_ONE", pattern: JDL_RELATIONSHIP_MANY_TO_ONE },
      { name: "MANY_TO_MANY", pattern: JDL_RELATIONSHIP_MANY_TO_MANY }
    ].map((tokenConfig) => {
      tokenConfig.categories = [relationshipTypeCategoryToken];
      return createTokenFromConfig(tokenConfig);
    });
    relationship_type_tokens_default = {
      categoryToken: relationshipTypeCategoryToken,
      tokens: [relationshipTypeCategoryToken, ...relationshipTypeTokens]
    };
  }
});

// node_modules/generator-begcode/dist/jdl/parsing/lexer/aigc-type-tokens.js
var aigcTypeCategoryToken, aigcTypeTokens, aigc_type_tokens_default;
var init_aigc_type_tokens = __esm({
  "node_modules/generator-begcode/dist/jdl/parsing/lexer/aigc-type-tokens.js"() {
    init_api5();
    init_aigc_type();
    init_token_creator();
    aigcTypeCategoryToken = createTokenFromConfig({ name: "AIGC_TYPE", pattern: Lexer.NA });
    aigcTypeTokens = [
      { name: "METHOD", pattern: JDL_AIGC_TYPE_METHOD },
      { name: "API", pattern: JDL_AIGC_TYPE_API },
      { name: "FEATURE", pattern: JDL_AIGC_TYPE_FEATURE }
    ].map((tokenConfig) => {
      tokenConfig.categories = [aigcTypeCategoryToken];
      return createTokenFromConfig(tokenConfig);
    });
    aigc_type_tokens_default = {
      categoryToken: aigcTypeCategoryToken,
      tokens: [aigcTypeCategoryToken, ...aigcTypeTokens]
    };
  }
});

// node_modules/generator-begcode/dist/jdl/parsing/lexer/option-tokens.js
var tokens, option_tokens_default;
var init_option_tokens = __esm({
  "node_modules/generator-begcode/dist/jdl/parsing/lexer/option-tokens.js"() {
    init_token_creator();
    init_shared_tokens();
    tokens = [
      { name: "WITH", pattern: "with" },
      { name: "EXCEPT", pattern: "except" },
      { name: "USE", pattern: "use" },
      { name: "FOR", pattern: "for" },
      { name: "CLIENT_ROOT_FOLDER", pattern: "clientRootFolder", type: "binary" },
      { name: "NO_FLUENT_METHOD", pattern: "noFluentMethod", type: "unary" },
      { name: "READ_ONLY", pattern: "readOnly", type: "unary" },
      { name: "EMBEDDED", pattern: "embedded", type: "unary" },
      { name: "DTO", pattern: "dto", type: "binary" },
      { name: "PAGINATE", pattern: "paginate", type: "binary" },
      { name: "SERVICE", pattern: "service", type: "binary" },
      { name: "MICROSERVICE", pattern: "microservice", type: "binary" },
      { name: "SEARCH", pattern: "search", type: "binary" },
      { name: "ANGULAR_SUFFIX", pattern: "angularSuffix", type: "binary" },
      { name: "FILTER", pattern: "filter", type: "unary" }
    ].map((tokenConfig) => {
      if (tokenConfig.type === "unary") {
        tokenConfig.categories = [unaryOptionCategoryToken, keywordToken];
      } else if (tokenConfig.type === "binary") {
        tokenConfig.categories = [binaryOptionCategoryToken, keywordToken];
      }
      delete tokenConfig.type;
      return createTokenFromConfig(tokenConfig);
    });
    option_tokens_default = {
      tokens
    };
  }
});

// node_modules/generator-begcode/dist/jdl/parsing/lexer/lexer.js
function createTokenFromConfig2(config) {
  const newToken = createTokenFromConfig(config);
  tokens2[config.name] = newToken;
  return newToken;
}
var tokens2, BUILT_IN_ENTITY, BOOLEAN, CONFIG_KEY, DEPLOYMENT_KEY, JDLLexer;
var init_lexer2 = __esm({
  "node_modules/generator-begcode/dist/jdl/parsing/lexer/lexer.js"() {
    init_api5();
    init_shared_tokens();
    init_jhipster2();
    init_validation_tokens();
    init_application_tokens();
    init_deployment_tokens();
    init_relationship_type_tokens();
    init_aigc_type_tokens();
    init_option_tokens();
    init_token_creator();
    tokens2 = {};
    ({ BUILT_IN_ENTITY } = relationship_options_default);
    BOOLEAN = createTokenFromConfig2({
      name: "BOOLEAN",
      pattern: Lexer.NA
    });
    CONFIG_KEY = application_tokens_default.categoryToken;
    DEPLOYMENT_KEY = deployment_tokens_default.categoryToken;
    createTokenFromConfig2({
      name: "WHITESPACE",
      pattern: /[\n\t\r \u2028\u2029]+/,
      group: Lexer.SKIPPED
    });
    createTokenFromConfig2({
      name: "JAVADOC",
      pattern: /\/\*\*([\s\S]*?)\*\//
    });
    createTokenFromConfig2({
      name: "BLOCK_COMMENT",
      pattern: /\/\*([\s\S]*?)\*\//,
      group: Lexer.SKIPPED
    });
    createTokenFromConfig2({ name: "CONFIG", pattern: "config" });
    createTokenFromConfig2({ name: "ENTITIES", pattern: "entities" });
    application_tokens_default.tokens.forEach((token) => {
      tokens2[token.name] = token;
    });
    createTokenFromConfig2({ name: "APPLICATION", pattern: "application" });
    createTokenFromConfig2({
      name: "SERVICE_DISCOVERY_TYPE",
      pattern: "serviceDiscoveryType",
      categories: [CONFIG_KEY, DEPLOYMENT_KEY]
    });
    deployment_tokens_default.tokens.forEach((token) => {
      tokens2[token.name] = token;
    });
    createTokenFromConfig2({ name: "DEPLOYMENT", pattern: "deployment" });
    createTokenFromConfig2({ name: "TRUE", pattern: "true", categories: [BOOLEAN] });
    createTokenFromConfig2({ name: "FALSE", pattern: "false", categories: [BOOLEAN] });
    createTokenFromConfig2({ name: "ENTITY", pattern: "entity" });
    createTokenFromConfig2({ name: "ENUM", pattern: "enum" });
    createTokenFromConfig2({ name: "RELATIONSHIP", pattern: "relationship" });
    createTokenFromConfig2({ name: "BUILT_IN_ENTITY", pattern: BUILT_IN_ENTITY });
    relationship_type_tokens_default.tokens.forEach((token) => {
      tokens2[token.name] = token;
    });
    createTokenFromConfig2({ name: "AIGC", pattern: "aigc" });
    aigc_type_tokens_default.tokens.forEach((token) => {
      tokens2[token.name] = token;
    });
    createTokenFromConfig2({ name: "STAR", pattern: "*" });
    option_tokens_default.tokens.forEach((token) => {
      tokens2[token.name] = token;
    });
    validation_tokens_default.tokens.forEach((token) => {
      tokens2[token.name] = token;
    });
    createTokenFromConfig2({ name: "REGEX", pattern: /\/[^\n\r]*\// });
    createTokenFromConfig2({ name: "DECIMAL", pattern: /-?\d+\.\d+/ });
    createTokenFromConfig2({ name: "INTEGER", pattern: /-?\d+/ });
    createTokenFromConfig2({ name: "STRING", pattern: /"(?:[^"])*"/ });
    createTokenFromConfig2({ name: "LPAREN", pattern: "(" });
    createTokenFromConfig2({ name: "RPAREN", pattern: ")" });
    createTokenFromConfig2({ name: "LCURLY", pattern: "{" });
    createTokenFromConfig2({ name: "RCURLY", pattern: "}" });
    createTokenFromConfig2({ name: "LSQUARE", pattern: "[" });
    createTokenFromConfig2({ name: "RSQUARE", pattern: "]" });
    createTokenFromConfig2({ name: "COMMA", pattern: "," });
    createTokenFromConfig2({ name: "COMMA_WITHOUT_NEWLINE", pattern: /,[^\n\r]/ });
    createTokenFromConfig2({ name: "EQUALS", pattern: "=" });
    createTokenFromConfig2({ name: "DOT", pattern: "." });
    createTokenFromConfig2({ name: "TO", pattern: "to" });
    createTokenFromConfig2({ name: "AT", pattern: "@" });
    tokens2.UNARY_OPTION = unaryOptionCategoryToken;
    tokens2.BINARY_OPTION = binaryOptionCategoryToken;
    tokens2.NAME = nameToken;
    JDLLexer = new Lexer(Object.values(tokens2), { ensureOptimizations: true });
  }
});

// node_modules/generator-begcode/dist/jdl/parsing/jdl-parser.js
function _0x2310(_0x206aa1, _0x59a0ba) {
  const _0x231006 = _0x59a0();
  _0x2310 = function(_0x25f39a, _0x3dc77e) {
    _0x25f39a = _0x25f39a - 0;
    let _0x33a06d = _0x231006[_0x25f39a];
    return _0x33a06d;
  };
  return _0x2310(_0x206aa1, _0x59a0ba);
}
function _0x59a0() {
  const _0x4e01d8 = ["validation", "entityList", "mXzAgJ334987".split("").reverse().join(""), "ENO_TSAEL_TA".split("").reverse().join(""), "ydoBcgia".split("").reverse().join(""), "wieAgc8348394".split("").reverse().join(""), "ylkXk".split("").reverse().join(""), "KkncMv77499".split("").reverse().join(""), "unlhkt78".split("").reverse().join(""), "vXSQP", "sepyTnekoTyrevoceRnIdeteleDeBnac".split("").reverse().join(""), "eiPDW".split("").reverse().join(""), "HnZISb82087".split("").reverse().join(""), "YTITNE_NI_TLIUB".split("").reverse().join(""), "tokenType", "zLHXa", "RCURLY", "getParser", "CONSUME2", "NOITACILPPA".split("").reverse().join(""), "1RO".split("").reverse().join(""), "ORzYn", "noitaralceDnoitaler".split("").reverse().join(""), "relationshipType", "UBFWA", "injectedField", "dYlai", "methodPath", "STAR", "804078dVTYrJ", "FALSE", "ROF".split("").reverse().join(""), "1YNAM".split("").reverse().join(""), "qMTPb", "canTokenTypeBeDeletedInRecovery", "xgbXu", "MANY_SEP", "zNNhY", "annotationOnSourceSide", "fQxGt", "option", "cIKBB".split("").reverse().join(""), "REGETNI".split("").reverse().join(""), "VOVOV".split("").reverse().join(""), "annotationDeclaration", "ZkzLW", "applicationNamespaceConfigDeclaration", "aigcType", "noitaralceDnoitpOesu".split("").reverse().join(""), "configValue", "AIGC", "WITH", "noitaralceDnoitpOyranib".split("").reverse().join(""), "MANY3", "CONFIG_KEY", "qWFCk", "0|10|3|26|42|15|12|23|24|34|5|16|2|31|17|38|9|13|30|44|29|8|1|18|33|6|40|22|21|45|11|7|14|25|32|35|28|39|27|19|43|36|20|41|4|37", "Mpean".split("").reverse().join(""), "EPYT_PIHSNOITALER".split("").reverse().join(""), "UNIQUE", "3|4|2|0|1", "DECIMAL", "DERIUQER".split("").reverse().join(""), "drvyA", "ydoBytitne".split("").reverse().join(""), "QHeUy", "constantDeclaration", "noitaralceDtnemyolped".split("").reverse().join(""), "qualifiedName", "PgRYk", "eulaVgifnoCtnemyolped".split("").reverse().join(""), "0|4|1|3|2", "TOD".split("").reverse().join(""), "sZwmd", "SUBRULE1", "DbkKj", "noitaralceDcgia".split("").reverse().join(""), "namespaceConfigValue", "ERAUQSR".split("").reverse().join(""), "EfBsR", "wJdwd".split("").reverse().join(""), "ENUM", "noitaralceDbuSnoitacilppa".split("").reverse().join(""), "zyLCM", "ENTITY", "enumProp", "from", "ALuyG".split("").reverse().join(""), "214520CCGhed", "exclusion", "UNARY_OPTION", "wobsY", "applicationSubConfig", "PATTERN", "commonEntityList", "QOigZ", "relationshipOptions", "filterFieldsOnSourceSide", "COMMA_WITHOUT_NEWLINE", "LSQUARE", "RXHFQ", "QpYJm", "EPYT_CGIA".split("").reverse().join(""), "ypvpd".split("").reverse().join(""), "2272172rHKyfs", "epyt".split("").reverse().join(""), "seititnEbuSnoitacilppa".split("").reverse().join(""), "FbvNr", "sUeoi", "LPAREN", "startLine", "jrKUk".split("").reverse().join(""), "enumPropKey", "enumPropList", "COMMA", "TPECXE".split("").reverse().join(""), "SUBRULE3", "YKGYF", "noitaralceDgifnoCtnemyolped".split("").reverse().join(""), "NERAPR".split("").reverse().join(""), "ediSpihsnoitaler".split("").reverse().join(""), "emTKG".split("").reverse().join(""), "annotationOnDestinationSide", "CONFIG", "EQUALS", "NOITPO_YRANIB".split("").reverse().join(""), "aAZMj".split("").reverse().join(""), "dzVTV".split("").reverse().join(""), "injectedFieldParam", "AT_LEAST_ONE_SEP", "noitadilaVxaMnim".split("").reverse().join(""), "ydoBpihsnoitaler".split("").reverse().join(""), "NAELOOB".split("").reverse().join(""), "SNkmK", "method", "pattern", "MANY", "TNEMYOLPED".split("").reverse().join(""), "applicationDeclaration", "enumDeclaration", "noitaralceDdleif".split("").reverse().join(""), "comment", "1270ujMmTS", "PIHSNOITALER".split("").reverse().join(""), "morFediScgia".split("").reverse().join(""), "MIN_MAX_KEYWORD", "HcFnr", "thsMo", "CONSUME1", "includes", "applicationConfigDeclaration", "split", "feDretlif".split("").reverse().join(""), "rRknJ", "GNIRTS".split("").reverse().join(""), "noitaralceDnoitpOyranu".split("").reverse().join(""), "OPTION", "entityTableNameDeclaration", "3|2|0|4|6|1|5", "2NOITPO".split("").reverse().join(""), "noitpOpihsnoitaler".split("").reverse().join(""), "SUBRULE2", "namespace", "applicationSubNamespaceConfig", "DEPLOYMENT_KEY", "eEblu", "2YNAM".split("").reverse().join(""), "SUBRULE4", "enumPropValueWithQuotes", "EMUSNOC".split("").reverse().join(""), "EURT".split("").reverse().join(""), "parse", "entityDeclaration", "ENTITIES", "fmsBV".split("").reverse().join(""), "4|3|2|0|1|5", "ELUR".split("").reverse().join(""), "16zwwZQT", "ncgCp".split("").reverse().join(""), "JAVADOC", "xODxF".split("").reverse().join(""), "CiwOd", "rUYmW".split("").reverse().join(""), "ncHsT".split("").reverse().join(""), "2|4|0|1|3", "eGmDJ", "tsil".split("").reverse().join(""), "ESU".split("").reverse().join(""), "qAyva".split("").reverse().join(""), "SUBRULE", "value", "performSelfAnalysis", "pPKhw", "NAME", "fMrwA", "iFXqW", "REGEX", "xhYAZ", "jpDDW", "WAcWS", "OPTION1", "gorp".split("").reverse().join(""), "BSdiZ", "enumPropValue", "CONSUME3", "LCURLY", "oXkzc", "zwslv".split("").reverse().join("")];
  _0x59a0 = function() {
    return _0x4e01d8;
  };
  return _0x59a0();
}
var instance, JDLParser;
var init_jdl_parser = __esm({
  "node_modules/generator-begcode/dist/jdl/parsing/jdl-parser.js"() {
    init_api5();
    init_lexer2();
    init_shared_tokens();
    (function(_0x2afab1, _0x54bb5f) {
      const _0x1b0ce8 = _0x2310;
      const _0x1abcba = _0x2afab1();
      while (!![]) {
        try {
          const _0x109f5b = parseInt(_0x1b0ce8(150)) / 1 + parseInt(_0x1b0ce8(177)) / 2 + -parseInt(_0x1b0ce8(156)) / 3 * (-parseInt(_0x1b0ce8(160)) / 4) + -parseInt(_0x1b0ce8(28)) / 5 + parseInt(_0x1b0ce8(153)) / 6 + parseInt(_0x1b0ce8(44)) / 7 * (-parseInt(_0x1b0ce8(117)) / 8) + parseInt(_0x1b0ce8(155)) / 9 * (-parseInt(_0x1b0ce8(82)) / 10);
          if (_0x109f5b === _0x54bb5f) {
            break;
          } else {
            _0x1abcba["push"](_0x1abcba["shift"]());
          }
        } catch (_0xe7fc4) {
          _0x1abcba["push"](_0x1abcba["shift"]());
        }
      }
    })(_0x59a0, 484421);
    JDLParser = class _JDLParser extends CstParser {
      constructor(_0x449e2f) {
        super(tokens2, _0x449e2f);
      }
      static ["getParser"](_0x2db962) {
        if (instance) {
          return instance;
        }
        instance = new _JDLParser(_0x2db962);
        return instance;
      }
      ["canBeDeletedInRecoveryTokenTypes"] = [tokens2["AT"]];
      ["canTokenTypeBeDeletedInRecovery"](_0x5ee743) {
        return this["canBeDeletedInRecoveryTokenTypes"]["includes"](_0x5ee743);
      }
      ["esrap".split("").reverse().join("")]() {
        const _0x4b1155 = _0x2310;
        const _0x254acc = { "fMrwA": _0x4b1155(204) };
        const _0x4f7084 = _0x254acc["fMrwA"]["split"]("|");
        let _0x35f825 = 0;
        while (!![]) {
          switch (_0x4f7084[_0x35f825++]) {
            case "0":
              this["prog"]();
              continue;
            case "1":
              this["enumPropList"]();
              continue;
            case "2":
              this["relationshipType"]();
              continue;
            case "3":
              this["entityDeclaration"]();
              continue;
            case "4":
              this["list"]();
              continue;
            case "5":
              this["pattern"]();
              continue;
            case "6":
              this["exclusion"]();
              continue;
            case "7":
              this["deploymentDeclaration"]();
              continue;
            case "8":
              this["enumDeclaration"]();
              continue;
            case "9":
              this["relationshipOption"]();
              continue;
            case "10":
              this["constantDeclaration"]();
              continue;
            case "11":
              this["comment"]();
              continue;
            case "12":
              this["fieldDeclaration"]();
              continue;
            case "13":
              this["aigcDeclaration"]();
              continue;
            case "14":
              this["deploymentConfigDeclaration"]();
              continue;
            case "15":
              this["entityBody"]();
              continue;
            case "16":
              this["relationDeclaration"]();
              continue;
            case "17":
              this["relationshipSide"]();
              continue;
            case "18":
              this["enumProp"]();
              continue;
            case "19":
              this["applicationConfigDeclaration"]();
              continue;
            case "20":
              this["namespaceConfigValue"]();
              continue;
            case "21":
              this["binaryOptionDeclaration"]();
              continue;
            case "22".split("").reverse().join(""):
              this["unaryOptionDeclaration"]();
              continue;
            case "32".split("").reverse().join(""):
              this["type"]();
              continue;
            case "24":
              this["validation"]();
              continue;
            case "25":
              this["deploymentConfigValue"]();
              continue;
            case "26":
              this["annotationDeclaration"]();
              continue;
            case "27":
              this["applicationSubEntities"]();
              continue;
            case "28":
              this["applicationSubConfig"]();
              continue;
            case "92".split("").reverse().join(""):
              this["aigcSideFrom"]();
              continue;
            case "30":
              this["aigcType"]();
              continue;
            case "31":
              this["relationshipBody"]();
              continue;
            case "23".split("").reverse().join(""):
              this["applicationDeclaration"]();
              continue;
            case "33".split("").reverse().join(""):
              this["entityList"]();
              continue;
            case "34":
              this["minMaxValidation"]();
              continue;
            case "35":
              this["applicationSubDeclaration"]();
              continue;
            case "36":
              this["applicationNamespaceConfigDeclaration"]();
              continue;
            case "37":
              this["performSelfAnalysis"]();
              continue;
            case "38":
              this["relationshipOptions"]();
              continue;
            case "39":
              this["applicationSubNamespaceConfig"]();
              continue;
            case "04".split("").reverse().join(""):
              this["useOptionDeclaration"]();
              continue;
            case "41":
              this["qualifiedName"]();
              continue;
            case "24".split("").reverse().join(""):
              this["entityTableNameDeclaration"]();
              continue;
            case "43":
              this["configValue"]();
              continue;
            case "44":
              this["aigcBody"]();
              continue;
            case "45":
              this["filterDef"]();
              continue;
          }
          break;
        }
      }
      ["prog"]() {
        const _0x1182d1 = _0x2310;
        const _0x3fc9af = { "fQxGt": _0x1182d1(141) };
        this["RULE"](_0x3fc9af["fQxGt"], () => {
          this["MANY"](() => {
            this["OR"]([{ "ALT": () => this["SUBRULE"](this["entityDeclaration"]) }, { "ALT": () => this["SUBRULE"](this["relationDeclaration"]) }, { "ALT": () => this["SUBRULE"](this["aigcDeclaration"]) }, { "ALT": () => this["SUBRULE"](this["enumDeclaration"]) }, { "ALT": () => this["CONSUME"](tokens2["JAVADOC"]) }, { "ALT": () => this["SUBRULE"](this["useOptionDeclaration"]) }, { "ALT": () => this["SUBRULE"](this["unaryOptionDeclaration"]) }, { "ALT": () => this["SUBRULE"](this["binaryOptionDeclaration"]) }, { "ALT": () => this["SUBRULE"](this["applicationDeclaration"]) }, { "ALT": () => this["SUBRULE"](this["deploymentDeclaration"]) }, { "GATE": () => this["LA"](814191 ^ 814189)["tokenType"] === tokens2["EQUALS"], "ALT": () => this["SUBRULE"](this["constantDeclaration"]) }]);
          });
        });
      }
      ["constantDeclaration"]() {
        const _0x5bc2c0 = _0x2310;
        const _0x43cd10 = { "RXHFQ": _0x5bc2c0(6) };
        this["RULE"](_0x43cd10["RXHFQ"], () => {
          this["CONSUME"](tokens2["NAME"]);
          this["CONSUME"](tokens2["EQUALS"]);
          this["OR"]([{ "ALT": () => this["CONSUME"](tokens2["DECIMAL"]) }, { "ALT": () => this["CONSUME"](tokens2["INTEGER"]) }, { "ALT": () => this["CONSUME"](tokens2["STRING"]) }]);
        });
      }
      ["entityDeclaration"]() {
        const _0x1aeb59 = _0x2310;
        const _0x46e906 = { "PgRYk": _0x1aeb59(112) };
        this["RULE"](_0x46e906["PgRYk"], () => {
          this["OPTION"](() => {
            this["CONSUME"](tokens2["JAVADOC"]);
          });
          this["MANY"](() => {
            this["SUBRULE"](this["annotationDeclaration"]);
          });
          this["CONSUME"](tokens2["ENTITY"]);
          this["CONSUME"](tokens2["NAME"]);
          this["OPTION1"](() => {
            this["SUBRULE"](this["entityTableNameDeclaration"]);
          });
          this["OPTION2"](() => {
            this["SUBRULE"](this["entityBody"]);
          });
        });
      }
      ["annotationDeclaration"]() {
        const _0x4a16a7 = _0x2310;
        const _0x813b71 = { "iFXqW": _0x4a16a7(188), "zLHXa": _0x4a16a7(192) };
        this["RULE"](_0x813b71["zLHXa"], () => {
          this["CONSUME"](tokens2["AT"]);
          this["CONSUME"](tokens2["NAME"], { "LABEL": _0x813b71["iFXqW"] });
          this["OPTION"](() => {
            const _0x3b7a12 = _0x2310;
            this["CONSUME"](tokens2["LPAREN"]);
            this["OR"]({ "IGNORE_AMBIGUITIES": !![], "DEF": [{ "ALT": () => this["CONSUME"](tokens2["STRING"], { "LABEL": _0x3b7a12(130) }) }, { "ALT": () => this["CONSUME"](tokens2["INTEGER"], { "LABEL": _0x3b7a12(130) }) }, { "ALT": () => this["CONSUME"](tokens2["DECIMAL"], { "LABEL": _0x3b7a12(130) }) }, { "ALT": () => this["CONSUME"](tokens2["TRUE"], { "LABEL": _0x3b7a12(130) }) }, { "ALT": () => this["CONSUME"](tokens2["FALSE"], { "LABEL": _0x3b7a12(130) }) }, { "ALT": () => this["CONSUME2"](tokens2["NAME"], { "LABEL": _0x3b7a12(130) }) }] });
            this["CONSUME"](tokens2["RPAREN"]);
          });
        });
      }
      ["entityTableNameDeclaration"]() {
        const _0x9e1e8 = _0x2310;
        this["RULE"](_0x9e1e8(97), () => {
          this["CONSUME"](tokens2["LPAREN"]);
          this["CONSUME"](tokens2["NAME"]);
          this["CONSUME"](tokens2["RPAREN"]);
        });
      }
      ["entityBody"]() {
        const _0x158d9d = _0x2310;
        this["RULE"](_0x158d9d(4), () => {
          this["CONSUME"](tokens2["LCURLY"]);
          this["MANY"](() => {
            this["SUBRULE"](this["fieldDeclaration"]);
            this["OPTION"](() => {
              this["CONSUME"](tokens2["COMMA"]);
            });
          });
          this["CONSUME"](tokens2["RCURLY"]);
        });
      }
      ["fieldDeclaration"]() {
        const _0x2ebcb0 = _0x2310;
        const _0x128759 = { "jMZAa": function(_0x42d4f6, _0x396841) {
          return _0x42d4f6 ^ _0x396841;
        }, "FbvNr": function(_0x383a5, _0xfbee3b) {
          return _0x383a5 === _0xfbee3b;
        }, "QHeUy": _0x2ebcb0(80) };
        this["RULE"](_0x128759["QHeUy"], () => {
          const _0x2ff7f7 = { "QpYJm": function(_0x599a92, _0x35b7cc) {
            return _0x128759["jMZAa"](_0x599a92, _0x35b7cc);
          }, "HcFnr": function(_0x4e36d8, _0x726a18) {
            return _0x128759["FbvNr"](_0x4e36d8, _0x726a18);
          } };
          this["OPTION"](() => {
            this["CONSUME"](tokens2["JAVADOC"]);
          });
          this["MANY"](() => {
            this["SUBRULE"](this["annotationDeclaration"]);
          });
          this["CONSUME"](tokens2["NAME"]);
          this["SUBRULE"](this["type"]);
          this["MANY1"](() => {
            this["SUBRULE"](this["validation"]);
          });
          this["OPTION2"]({ "GATE": () => {
            const _0x126c31 = this["LA"](_0x2ff7f7["QpYJm"](892338, 892338));
            const _0x49cfcd = this["LA"](_0x2ff7f7["QpYJm"](357351, 357350));
            return _0x2ff7f7["HcFnr"](_0x126c31["startLine"], _0x49cfcd["startLine"]);
          }, "DEF": () => {
            this["CONSUME2"](tokens2["JAVADOC"]);
          } });
        });
      }
      ["type"]() {
        const _0x396818 = _0x2310;
        const _0x4a7836 = { "WDPie": _0x396818(45) };
        this["RULE"](_0x4a7836["WDPie"], () => {
          this["CONSUME"](tokens2["NAME"]);
        });
      }
      ["validation"]() {
        const _0x3389ea = _0x2310;
        const _0x512b0a = { "VOVOV": _0x3389ea(148) };
        this["RULE"](_0x512b0a["VOVOV"], () => {
          this["OR"]([{ "ALT": () => this["CONSUME"](tokens2["REQUIRED"]) }, { "ALT": () => this["CONSUME"](tokens2["UNIQUE"]) }, { "ALT": () => this["SUBRULE"](this["minMaxValidation"]) }, { "ALT": () => this["SUBRULE"](this["pattern"]) }]);
        });
      }
      ["minMaxValidation"]() {
        const _0x5e3c08 = _0x2310;
        this["RULE"](_0x5e3c08(70), () => {
          this["CONSUME"](tokens2["MIN_MAX_KEYWORD"]);
          this["CONSUME"](tokens2["LPAREN"]);
          this["OR"]([{ "ALT": () => this["CONSUME"](tokens2["DECIMAL"]) }, { "ALT": () => this["CONSUME"](tokens2["INTEGER"]) }, { "ALT": () => this["CONSUME"](tokens2["NAME"]) }]);
          this["CONSUME"](tokens2["RPAREN"]);
        });
      }
      ["pattern"]() {
        const _0xe60a20 = _0x2310;
        const _0xa69be0 = { "sZwmd": _0xe60a20(75) };
        this["RULE"](_0xa69be0["sZwmd"], () => {
          this["CONSUME"](tokens2["PATTERN"]);
          this["CONSUME"](tokens2["LPAREN"]);
          this["CONSUME"](tokens2["REGEX"]);
          this["CONSUME"](tokens2["RPAREN"]);
        });
      }
      ["relationDeclaration"]() {
        const _0x3b1982 = _0x2310;
        const _0x179ece = { "vlswz": _0x3b1982(170) };
        this["RULE"](_0x179ece["vlswz"], () => {
          this["CONSUME"](tokens2["RELATIONSHIP"]);
          this["SUBRULE"](this["relationshipType"]);
          this["CONSUME"](tokens2["LCURLY"]);
          this["AT_LEAST_ONE"](() => {
            this["SUBRULE"](this["relationshipBody"]);
            this["OPTION"](() => {
              this["CONSUME"](tokens2["COMMA"]);
            });
          });
          this["CONSUME"](tokens2["RCURLY"]);
        });
      }
      ["relationshipType"]() {
        const _0x2ad77d = _0x2310;
        const _0x2bc279 = { "sUeoi": _0x2ad77d(171) };
        this["RULE"](_0x2bc279["sUeoi"], () => {
          this["CONSUME"](tokens2["RELATIONSHIP_TYPE"]);
        });
      }
      ["relationshipBody"]() {
        const _0x170338 = _0x2310;
        const _0x364936 = { "FxDOx": _0x170338(186), "VTVzd": _0x170338(62), "dpvpy": _0x170338(37), "dwdJw": _0x170338(36), "ORzYn": _0x170338(26), "kXkly": _0x170338(71) };
        this["RULE"](_0x364936["kXkly"], () => {
          const _0x53c4ca = { "pPKhw": _0x364936["dpvpy"], "VBsmf": _0x364936["dwdJw"] };
          this["MANY1"](() => {
            this["SUBRULE1"](this["annotationDeclaration"], { "LABEL": _0x364936["FxDOx"] });
          });
          this["MANY3"](() => {
            this["SUBRULE4"](this["annotationDeclaration"], { "LABEL": _0x53c4ca["pPKhw"] });
          });
          this["SUBRULE1"](this["relationshipSide"], { "LABEL": _0x364936["ORzYn"] });
          this["CONSUME"](tokens2["TO"]);
          this["MANY2"](() => {
            this["SUBRULE2"](this["annotationDeclaration"], { "LABEL": _0x364936["VTVzd"] });
          });
          this["SUBRULE2"](this["relationshipSide"], { "LABEL": "to" });
          this["OPTION"](() => {
            this["CONSUME"](tokens2["WITH"]);
            this["SUBRULE3"](this["relationshipOptions"], { "LABEL": _0x53c4ca["VBsmf"] });
          });
        });
      }
      ["relationshipSide"]() {
        const _0x58b020 = _0x2310;
        const _0x2956a0 = { "dYlai": _0x58b020(11), "wobsY": _0x58b020(173), "xgbXu": _0x58b020(60) };
        this["RULE"](_0x2956a0["xgbXu"], () => {
          const _0x47b006 = { "UBFWA": _0x2956a0["dYlai"], "BSdiZ": _0x2956a0["wobsY"] };
          this["SUBRULE"](this["comment"]);
          this["CONSUME"](tokens2["NAME"]);
          this["OPTION"](() => {
            const _0x38c86f = _0x47b006["UBFWA"]["split"]("|");
            let _0x5e5da0 = 0;
            while (!![]) {
              switch (_0x38c86f[_0x5e5da0++]) {
                case "0":
                  this["CONSUME"](tokens2["LCURLY"]);
                  continue;
                case "1":
                  this["OPTION1"](() => {
                    const _0x431097 = _0x2310;
                    this["CONSUME"](tokens2["LPAREN"]);
                    this["CONSUME3"](tokens2["NAME"], { "LABEL": _0x431097(68) });
                    this["CONSUME"](tokens2["RPAREN"]);
                  });
                  continue;
                case "2":
                  this["CONSUME"](tokens2["RCURLY"]);
                  continue;
                case "3":
                  this["OPTION2"](() => {
                    this["CONSUME"](tokens2["REQUIRED"]);
                  });
                  continue;
                case "4":
                  this["CONSUME2"](tokens2["NAME"], { "LABEL": _0x47b006["BSdiZ"] });
                  continue;
              }
              break;
            }
          });
        });
      }
      ["relationshipOptions"]() {
        const _0x3eef9c = _0x2310;
        const _0x5032ba = { "ZkzLW": _0x3eef9c(100), "GyuLA": _0x3eef9c(36) };
        this["RULE"](_0x5032ba["GyuLA"], () => {
          this["AT_LEAST_ONE_SEP"]({ "SEP": tokens2["COMMA_WITHOUT_NEWLINE"], "DEF": () => {
            this["SUBRULE"](this["relationshipOption"], { "LABEL": _0x5032ba["ZkzLW"] });
          } });
        });
      }
      ["relationshipOption"]() {
        const _0x10ee3b = _0x2310;
        const _0x53a2df = { "EfBsR": _0x10ee3b(100) };
        this["RULE"](_0x53a2df["EfBsR"], () => {
          this["OR"]([{ "ALT": () => this["CONSUME"](tokens2["BUILT_IN_ENTITY"]) }]);
        });
      }
      ["aigcDeclaration"]() {
        const _0x186dd2 = _0x2310;
        const _0x4dfdb1 = { "GKTme": _0x186dd2(124), "DbkKj": _0x186dd2(16) };
        this["RULE"](_0x4dfdb1["DbkKj"], () => {
          const _0x27b83a = _0x4dfdb1["GKTme"]["split"]("|");
          let _0x435f22 = 0;
          while (!![]) {
            switch (_0x27b83a[_0x435f22++]) {
              case "0":
                this["CONSUME"](tokens2["LCURLY"]);
                continue;
              case "1":
                this["AT_LEAST_ONE"](() => {
                  this["SUBRULE"](this["aigcBody"]);
                  this["OPTION"](() => {
                    this["CONSUME"](tokens2["COMMA"]);
                  });
                });
                continue;
              case "2":
                this["CONSUME"](tokens2["AIGC"]);
                continue;
              case "3":
                this["CONSUME"](tokens2["RCURLY"]);
                continue;
              case "4":
                this["SUBRULE"](this["aigcType"]);
                continue;
            }
            break;
          }
        });
      }
      ["aigcType"]() {
        const _0x8c2055 = _0x2310;
        const _0x3cf500 = { "eEblu": _0x8c2055(195) };
        this["RULE"](_0x3cf500["eEblu"], () => {
          this["CONSUME"](tokens2["AIGC_TYPE"]);
        });
      }
      ["aigcBody"]() {
        const _0x169508 = _0x2310;
        const _0x150b4e = { "oXkzc": _0x169508(26), "zyLCM": _0x169508(152) };
        this["RULE"](_0x150b4e["zyLCM"], () => {
          this["SUBRULE1"](this["aigcSideFrom"], { "LABEL": _0x150b4e["oXkzc"] });
          this["OPTION"](() => {
            this["CONSUME"](tokens2["TO"]);
            this["CONSUME"](tokens2["NAME"], { "LABEL": "to" });
          });
        });
      }
      ["aigcSideFrom"]() {
        const _0x3abc15 = _0x2310;
        const _0x3347e8 = { "SNkmK": _0x3abc15(0), "QOigZ": _0x3abc15(173), "zNNhY": _0x3abc15(84) };
        this["RULE"](_0x3347e8["zNNhY"], () => {
          const _0x43d7fd = _0x3347e8["SNkmK"]["split"]("|");
          let _0x4162dc = 0;
          while (!![]) {
            switch (_0x43d7fd[_0x4162dc++]) {
              case "0":
                this["CONSUME2"](tokens2["NAME"], { "LABEL": _0x3347e8["QOigZ"] });
                continue;
              case "1":
                this["CONSUME"](tokens2["RCURLY"]);
                continue;
              case "2":
                this["CONSUME"](tokens2["LCURLY"]);
                continue;
              case "3":
                this["SUBRULE"](this["comment"]);
                continue;
              case "4":
                this["CONSUME"](tokens2["NAME"]);
                continue;
            }
            break;
          }
        });
      }
      ["noitaralceDmune".split("").reverse().join("")]() {
        const _0xea77f8 = _0x2310;
        const _0x58b558 = { "YKGYF": _0xea77f8(79) };
        this["RULE"](_0x58b558["YKGYF"], () => {
          this["OPTION"](() => {
            this["CONSUME"](tokens2["JAVADOC"]);
          });
          this["CONSUME"](tokens2["ENUM"]);
          this["CONSUME"](tokens2["NAME"]);
          this["CONSUME"](tokens2["LCURLY"]);
          this["SUBRULE"](this["enumPropList"]);
          this["CONSUME"](tokens2["RCURLY"]);
        });
      }
      ["enumPropList"]() {
        const _0x138c81 = _0x2310;
        const _0x138f8c = { "BBKIc": _0x138c81(53) };
        this["RULE"](_0x138f8c["BBKIc"], () => {
          this["SUBRULE"](this["enumProp"]);
          this["MANY"](() => {
            this["OPTION"](() => {
              this["CONSUME"](tokens2["COMMA"]);
            });
            this["SUBRULE1"](this["enumProp"]);
          });
        });
      }
      ["enumProp"]() {
        const _0x1f343a = _0x2310;
        const _0x146717 = { "kUKrj": _0x1f343a(52), "thsMo": _0x1f343a(25) };
        this["RULE"](_0x146717["thsMo"], () => {
          this["OPTION"](() => {
            this["CONSUME"](tokens2["JAVADOC"]);
          });
          this["CONSUME"](tokens2["NAME"], { "LABEL": _0x146717["kUKrj"] });
          this["OPTION1"](() => {
            const _0x244caf = _0x2310;
            this["CONSUME"](tokens2["LPAREN"]);
            this["OR"]([{ "ALT": () => this["CONSUME2"](tokens2["STRING"], { "LABEL": _0x244caf(108) }) }, { "ALT": () => this["CONSUME3"](tokens2["NAME"], { "LABEL": _0x244caf(143) }) }]);
            this["CONSUME"](tokens2["RPAREN"]);
          });
          this["OPTION2"](() => {
            this["CONSUME1"](tokens2["JAVADOC"]);
          });
        });
      }
      ["tsiLytitne".split("").reverse().join("")]() {
        const _0x18ab7b = _0x2310;
        this["RULE"](_0x18ab7b(149), () => {
          const _0x41f7dc = _0x2310;
          this["commonEntityList"]();
          this["CONSUME"](tokens2["WITH"]);
          this["OR1"]([{ "ALT": () => this["CONSUME2"](tokens2["NAME"], { "LABEL": _0x41f7dc(74) }) }, { "ALT": () => this["CONSUME3"](tokens2["STRING"], { "LABEL": _0x41f7dc(175) }) }]);
        });
      }
      ["commonEntityList"]() {
        this["MANY"]({ "GATE": () => this["LA"](591321 ^ 591323)["tokenType"] === tokens2["COMMA"], "DEF": () => {
          this["CONSUME"](tokens2["NAME"]);
          this["CONSUME"](tokens2["COMMA"]);
        } });
        this["OR"]([{ "ALT": () => this["CONSUME"](tokens2["STAR"]) }, { "ALT": () => this["CONSUME1"](tokens2["NAME"]) }]);
      }
      ["exclusion"]() {
        const _0x4e779e = _0x2310;
        this["RULE"](_0x4e779e(29), () => {
          this["CONSUME"](tokens2["EXCEPT"]);
          this["CONSUME"](tokens2["NAME"]);
          this["MANY"](() => {
            this["CONSUME"](tokens2["COMMA"]);
            this["CONSUME2"](tokens2["NAME"]);
          });
        });
      }
      ["useOptionDeclaration"]() {
        const _0x3c451e = _0x2310;
        const _0x114824 = { "CiwOd": _0x3c451e(115), "naepM": _0x3c451e(196) };
        this["RULE"](_0x114824["naepM"], () => {
          const _0xe6f04c = _0x114824["CiwOd"]["split"]("|");
          let _0x553e80 = 0;
          while (!![]) {
            switch (_0xe6f04c[_0x553e80++]) {
              case "0":
                this["CONSUME"](tokens2["FOR"]);
                continue;
              case "1":
                this["SUBRULE"](this["filterDef"]);
                continue;
              case "2":
                this["CONSUME1"](tokens2["NAME"]);
                continue;
              case "3":
                this["MANY"]({ "GATE": () => this["LA"](191569 ^ 191571)["tokenType"] === tokens2["COMMA"], "DEF": () => {
                  this["CONSUME"](tokens2["NAME"]);
                  this["CONSUME"](tokens2["COMMA"]);
                } });
                continue;
              case "4":
                this["CONSUME"](tokens2["USE"]);
                continue;
              case "5":
                this["OPTION"](() => {
                  this["SUBRULE"](this["exclusion"]);
                });
                continue;
            }
            break;
          }
        });
      }
      ["unaryOptionDeclaration"]() {
        const _0x58bd8e = _0x2310;
        this["RULE"](_0x58bd8e(95), () => {
          this["CONSUME"](tokens2["UNARY_OPTION"]);
          this["SUBRULE"](this["filterDef"]);
          this["OPTION"](() => {
            this["SUBRULE"](this["exclusion"]);
          });
        });
      }
      ["binaryOptionDeclaration"]() {
        const _0x26ca5f = _0x2310;
        const _0xf4a2fa = { "eGmDJ": _0x26ca5f(200) };
        this["RULE"](_0xf4a2fa["eGmDJ"], () => {
          this["CONSUME"](tokens2["BINARY_OPTION"]);
          this["SUBRULE"](this["entityList"]);
          this["OPTION"](() => {
            this["SUBRULE"](this["exclusion"]);
          });
        });
      }
      ["filterDef"]() {
        const _0x22b984 = _0x2310;
        this["RULE"](_0x22b984(92), this["commonEntityList"]);
      }
      ["comment"]() {
        const _0x5956a7 = _0x2310;
        this["RULE"](_0x5956a7(81), () => {
          this["OPTION"](() => {
            this["CONSUME"](tokens2["JAVADOC"]);
          });
        });
      }
      ["deploymentDeclaration"]() {
        const _0x1be4dc = _0x2310;
        const _0x2c3e31 = { "WmYUr": _0x1be4dc(7) };
        this["RULE"](_0x2c3e31["WmYUr"], () => {
          this["CONSUME"](tokens2["DEPLOYMENT"]);
          this["CONSUME"](tokens2["LCURLY"]);
          this["MANY"](() => {
            this["OR"]([{ "ALT": () => this["CONSUME"](tokens2["JAVADOC"]) }, { "ALT": () => this["SUBRULE"](this["deploymentConfigDeclaration"]) }]);
          });
          this["CONSUME"](tokens2["RCURLY"]);
        });
      }
      ["deploymentConfigDeclaration"]() {
        const _0x21a72a = _0x2310;
        const _0xf53e7a = { "qMTPb": _0x21a72a(58) };
        this["RULE"](_0xf53e7a["qMTPb"], () => {
          this["CONSUME"](tokens2["DEPLOYMENT_KEY"]);
          this["SUBRULE"](this["deploymentConfigValue"]);
          this["OPTION"](() => {
            this["CONSUME"](tokens2["COMMA"]);
          });
        });
      }
      ["deploymentConfigValue"]() {
        const _0x28390d = _0x2310;
        this["RULE"](_0x28390d(10), () => {
          this["OR"]([{ "ALT": () => this["CONSUME"](tokens2["BOOLEAN"]) }, { "ALT": () => this["SUBRULE"](this["qualifiedName"]) }, { "ALT": () => this["SUBRULE"](this["list"]) }, { "ALT": () => this["CONSUME"](tokens2["INTEGER"]) }, { "ALT": () => this["CONSUME"](tokens2["STRING"]) }]);
        });
      }
      ["applicationDeclaration"]() {
        const _0x318b5a = _0x2310;
        const _0x40bc3d = { "pCgcn": _0x318b5a(78) };
        this["RULE"](_0x40bc3d["pCgcn"], () => {
          this["CONSUME"](tokens2["APPLICATION"]);
          this["CONSUME"](tokens2["LCURLY"]);
          this["SUBRULE"](this["applicationSubDeclaration"]);
          this["CONSUME"](tokens2["RCURLY"]);
        });
      }
      ["applicationSubDeclaration"]() {
        const _0x43e715 = _0x2310;
        const _0x24dc69 = { "WAcWS": _0x43e715(22) };
        this["RULE"](_0x24dc69["WAcWS"], () => {
          this["MANY"](() => {
            this["OR"]([{ "ALT": () => this["SUBRULE"](this["applicationSubNamespaceConfig"]) }, { "ALT": () => this["SUBRULE"](this["applicationSubConfig"]) }, { "ALT": () => this["SUBRULE"](this["applicationSubEntities"]) }, { "ALT": () => this["SUBRULE"](this["unaryOptionDeclaration"]) }, { "ALT": () => this["SUBRULE"](this["binaryOptionDeclaration"]) }, { "ALT": () => this["SUBRULE"](this["useOptionDeclaration"]) }]);
          });
        });
      }
      ["applicationSubNamespaceConfig"]() {
        const _0x1f7305 = _0x2310;
        const _0x2fd385 = { "jpDDW": _0x1f7305(98), "avyAq": _0x1f7305(102), "rRknJ": _0x1f7305(103) };
        this["RULE"](_0x2fd385["rRknJ"], () => {
          const _0x1ef963 = _0x2fd385["jpDDW"]["split"]("|");
          let _0x4097d1 = 0;
          while (!![]) {
            switch (_0x1ef963[_0x4097d1++]) {
              case "0":
                this["CONSUME"](tokens2["NAME"], { "LABEL": _0x2fd385["avyAq"] });
                continue;
              case "1":
                this["MANY"](() => {
                  this["OR"]([{ "ALT": () => this["CONSUME"](tokens2["JAVADOC"]) }, { "ALT": () => this["SUBRULE"](this["applicationNamespaceConfigDeclaration"]) }]);
                });
                continue;
              case "2":
                this["CONSUME"](tokens2["LPAREN"]);
                continue;
              case "3":
                this["CONSUME"](tokens2["CONFIG"]);
                continue;
              case "4":
                this["CONSUME"](tokens2["RPAREN"]);
                continue;
              case "5":
                this["CONSUME"](tokens2["RCURLY"]);
                continue;
              case "6":
                this["CONSUME"](tokens2["LCURLY"]);
                continue;
            }
            break;
          }
        });
      }
      ["applicationNamespaceConfigDeclaration"]() {
        const _0xb42cb3 = _0x2310;
        const _0x58f7e2 = { "xhYAZ": _0xb42cb3(194) };
        this["RULE"](_0x58f7e2["xhYAZ"], () => {
          this["CONSUME"](nameToken);
          this["SUBRULE"](this["namespaceConfigValue"]);
          this["OPTION"](() => {
            this["CONSUME"](tokens2["COMMA"]);
          });
        });
      }
      ["namespaceConfigValue"]() {
        const _0x506fa0 = _0x2310;
        this["RULE"](_0x506fa0(17), () => {
          this["OR"]([{ "ALT": () => this["CONSUME"](tokens2["BOOLEAN"]) }, { "ALT": () => this["SUBRULE"](this["qualifiedName"]) }, { "ALT": () => this["SUBRULE"](this["list"]) }, { "ALT": () => this["CONSUME"](tokens2["INTEGER"]) }, { "ALT": () => this["CONSUME"](tokens2["STRING"]) }]);
        });
      }
      ["applicationSubConfig"]() {
        const _0x5458ac = _0x2310;
        const _0x46dffc = { "qWFCk": _0x5458ac(32) };
        this["RULE"](_0x46dffc["qWFCk"], () => {
          this["CONSUME"](tokens2["CONFIG"]);
          this["CONSUME"](tokens2["LCURLY"]);
          this["MANY"](() => {
            this["OR"]([{ "ALT": () => this["CONSUME"](tokens2["JAVADOC"]) }, { "ALT": () => this["SUBRULE"](this["applicationConfigDeclaration"]) }]);
          });
          this["CONSUME"](tokens2["RCURLY"]);
        });
      }
      ["applicationConfigDeclaration"]() {
        const _0x5e2f5c = _0x2310;
        const _0x284dd1 = { "vXSQP": _0x5e2f5c(90) };
        this["RULE"](_0x284dd1["vXSQP"], () => {
          this["CONSUME"](tokens2["CONFIG_KEY"]);
          this["SUBRULE"](this["configValue"]);
          this["OPTION"](() => {
            this["CONSUME"](tokens2["COMMA"]);
          });
        });
      }
      ["configValue"]() {
        const _0x26b1b6 = _0x2310;
        this["RULE"](_0x26b1b6(197), () => {
          this["OR"]([{ "ALT": () => this["CONSUME"](tokens2["BOOLEAN"]) }, { "ALT": () => this["SUBRULE"](this["qualifiedName"]) }, { "ALT": () => this["SUBRULE"](this["list"]) }, { "ALT": () => this["CONSUME"](tokens2["INTEGER"]) }, { "ALT": () => this["CONSUME"](tokens2["STRING"]) }]);
        });
      }
      ["qualifiedName"]() {
        const _0x2b444f = _0x2310;
        const _0x4dee0a = { "drvyA": _0x2b444f(8) };
        this["RULE"](_0x4dee0a["drvyA"], () => {
          this["AT_LEAST_ONE_SEP"]({ "SEP": tokens2["DOT"], "DEF": () => {
            this["CONSUME"](tokens2["NAME"]);
          } });
        });
      }
      ["tsil".split("").reverse().join("")]() {
        const _0x435578 = _0x2310;
        const _0x1ef0fd = { "TsHcn": _0x435578(126) };
        this["RULE"](_0x1ef0fd["TsHcn"], () => {
          this["CONSUME"](tokens2["LSQUARE"]);
          this["MANY_SEP"]({ "SEP": tokens2["COMMA"], "DEF": () => {
            this["CONSUME"](tokens2["NAME"]);
          } });
          this["CONSUME"](tokens2["RSQUARE"]);
        });
      }
      ["applicationSubEntities"]() {
        const _0x32185a = _0x2310;
        this["RULE"](_0x32185a(46), () => {
          this["CONSUME"](tokens2["ENTITIES"]);
          this["SUBRULE"](this["filterDef"]);
          this["OPTION"](() => {
            this["SUBRULE"](this["exclusion"]);
          });
        });
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/utils/array-utils.js
function deduplicate(array) {
  return Array.from(new Set(array));
}
var init_array_utils = __esm({
  "node_modules/generator-begcode/dist/jdl/utils/array-utils.js"() {
  }
});

// node_modules/generator-begcode/dist/jdl/parsing/jdl-ast-builder-visitor.js
function _0x54f5() {
  const _0x169125 = ["aigcType", "DERIUQER".split("").reverse().join(""), "stnatsnoc".split("").reverse().join(""), "morFediScgia".split("").reverse().join(""), "maraPdleiFdetcejni".split("").reverse().join(""), "63306IvfGUL", "eulaVgifnoCecapseman".split("").reverse().join(""), "YRANIB".split("").reverse().join(""), "pHUfB".split("").reverse().join(""), "emaNdeifilauq".split("").reverse().join(""), "ediSpihsnoitaler".split("").reverse().join(""), "JAVADOC", "AoYYZ".split("").reverse().join(""), "prog", "eighm".split("").reverse().join(""), "REGETNI".split("").reverse().join(""), "rIjJj".split("").reverse().join(""), "tsiLporPmune".split("").reverse().join(""), "eulav".split("").reverse().join(""), "relationships", "XBgub", "binaryOptionDeclaration", "join", "noitaralceDtnatsnoc".split("").reverse().join(""), "ydoBpihsnoitaler".split("").reverse().join(""), "RELATIONSHIP_TYPE", "noitadilav".split("").reverse().join(""), "ntltb", "annotationOnDestinationSide", "qGVFQ", "bHrRj", "namespace", "ITvDv".split("").reverse().join(""), "kcOFs", "poPHM".split("").reverse().join(""), "lla".split("").reverse().join(""), "entities", "fieldDeclaration", "UNIQUE", "useOptionDeclaration", "getBaseCstVisitorConstructor", "noitaralceDgifnoCtnemyolped".split("").reverse().join(""), "LAMICED".split("").reverse().join(""), "VBAHB", "BOOLEAN", "epyTpihsnoitaler".split("").reverse().join(""), "1YUmRcK", "tZNwv".split("").reverse().join(""), "filterFieldsOnSourceSide", "getParser", "LrlaB", "from", "mGLXB", "13536UqdQkk", "flatMap", "tsiLytitne".split("").reverse().join(""), "eulaVgifnoc".split("").reverse().join(""), "iiKHM".split("").reverse().join(""), "NOITPO_YRANU".split("").reverse().join(""), "GloJs", "validateVisitor", "CcaMz", "push", "4174296lqcyJE", "unaryOptionDeclaration", "JTNXb", "aigcDeclaration", "NAME", "noitaralceDnoitatonna".split("").reverse().join(""), "nhZVY", "forEach", "STAR", "PHuSw", "comment", "FALSE", "wpOUhr79005".split("").reverse().join(""), "tsil".split("").reverse().join(""), "1881cwrgWJ", "method", "porPmune".split("").reverse().join(""), "REGEX", "XKBga".split("").reverse().join(""), "filterDef", "GNIRTS".split("").reverse().join(""), "applications", "snoitpOpihsnoitaler".split("").reverse().join(""), "enumDeclaration", "required", "FHUIw".split("").reverse().join(""), "PxqVt", "' detcepxe ,dnuof noitpo pihsnoitaler dilav oN".split("").reverse().join(""), "PZOrS", "gifnoCecapsemaNbuSnoitacilppa".split("").reverse().join(""), "BUILT_IN_ENTITY", "entityDeclaration", "injectedField", "yeBLL", "slice", "ytilanidrac".split("").reverse().join(""), "excluded", "annotationOnSourceSide", "CONFIG_KEY", "noitaralceDgifnoCecapsemaNnoitacilppa".split("").reverse().join(""), "minMaxValidation", "deploymentDeclaration", "TRUE", "gifnoc".split("").reverse().join(""), "ydoBcgia".split("").reverse().join(""), "UNARY", "LiiiZ", "yqYMu".split("").reverse().join(""), "RResI".split("").reverse().join(""), "mNPDZ", "yAIsy", "noitpOpihsnoitaler".split("").reverse().join(""), "SHsmt", "applicationSubEntities", "DEPLOYMENT_KEY", "4820520dQhsIg", "whgFA".split("").reverse().join(""), "MOAJn", "options", "snoitpOesu".split("").reverse().join(""), "UhbDL".split("").reverse().join(""), "replace", "WifrA".split("").reverse().join(""), "redloFegakcap".split("").reverse().join(""), "exclusion", "iVGVP", "nIqLD", "optionValue", "cYGWcM211".split("").reverse().join(""), "namespaceConfigs", "JEcsf", "yek".split("").reverse().join(""), "applicationConfigDeclaration", "option", "enumPropValueWithQuotes", "MYudl", "zjKvl", "ufAHD".split("").reverse().join(""), "noitaralceDnoitacilppa".split("").reverse().join(""), "EPYT_CGIA".split("").reverse().join(""), "fTXQy", "NFBLQ".split("").reverse().join(""), "visit", "yeKporPmune".split("").reverse().join(""), "2686060whvHNY", "No valid config value was found, expected a qualified name, a list, an integer, a string or a boolean.", "noitaralceDemaNelbaTytitne".split("").reverse().join(""), "eVoom", "76NAXKEu", "NOITPO_YRANIB".split("").reverse().join(""), "DROWYEK_XAM_NIM".split("").reverse().join(""), "pam".split("").reverse().join(""), "6ktdxRR", "type", "deployments", "qEmFm", "reduce", "gMLrp", "name", "KEkAP", "xPxpL", "eulaVgifnoCtnemyolped".split("").reverse().join(""), "applicationSubDeclaration", "htaPdohtem".split("").reverse().join(""), "danIIi408421".split("").reverse().join(""), "enumPropValue", "length", "pattern", "hmngz", "applicationSubConfig", "paginate", "parse", "zTfNm", "djrdR".split("").reverse().join(""), "SyxdG", "entityBody", "enums", "egami".split("").reverse().join(""), "tacnoc".split("").reverse().join(""), "emaNnoitpo".split("").reverse().join(""), "YIAzw", "relationDeclaration", "pGfzR".split("").reverse().join(""), "eurt".split("").reverse().join(""), "aigcs", "substring"];
  _0x54f5 = function() {
    return _0x169125;
  };
  return _0x54f5();
}
function _0x44fb(_0x4d6592, _0x54f5ad) {
  const _0x44fb0b = _0x54f5();
  _0x44fb = function(_0x243ad0, _0x16cd36) {
    _0x243ad0 = _0x243ad0 - 0;
    let _0x346ae1 = _0x44fb0b[_0x243ad0];
    return _0x346ae1;
  };
  return _0x44fb(_0x4d6592, _0x54f5ad);
}
function getOptionEntityAndExcludedEntityLists(_0x4a8142, _0x11275a) {
  const _0x1252f8 = { "mNPDZ": function(_0x541b08, _0x1bae5b) {
    return _0x541b08(_0x1bae5b);
  }, "IseRR": function(_0x2f8501, _0x176c2c) {
    return _0x2f8501(_0x176c2c);
  } };
  let _0x49fa5b = _0x4a8142["list"] || [];
  _0x49fa5b = _0x1252f8["mNPDZ"](deduplicate, _0x49fa5b["concat"](_0x11275a["list"]));
  let _0x52ad92 = _0x4a8142["excluded"] || [];
  if (_0x11275a["excluded"]) {
    _0x52ad92 = _0x1252f8["IseRR"](deduplicate, _0x52ad92["concat"](_0x11275a["excluded"]));
  }
  return { "entityList": _0x49fa5b, "excludedEntityList": _0x52ad92 };
}
function getEntityListFromContext(_0x2b90a2, _0x402be3) {
  const _0x4f96d0 = _0x402be3["visit"](_0x2b90a2["filterDef"]);
  let _0x51c10c = [];
  if (_0x2b90a2["exclusion"]) {
    _0x51c10c = _0x402be3["visit"](_0x2b90a2["exclusion"]);
  }
  const _0x1894f0 = { "entityList": _0x4f96d0, "excluded": _0x51c10c };
  if (_0x2b90a2["UNARY_OPTION"]) {
    _0x1894f0["optionName"] = _0x2b90a2["UNARY_OPTION"][752010 ^ 752010]["image"];
  }
  return _0x1894f0;
}
function getUnaryOptionFromContext(_0x3a2e70, _0x1183f7) {
  const _0x43e0f6 = { "ntltb": function(_0x979ade, _0x55eb46) {
    return _0x979ade ^ _0x55eb46;
  } };
  const _0x3a793e = _0x1183f7["visit"](_0x3a2e70["filterDef"]);
  let _0x2bb485 = [];
  if (_0x3a2e70["exclusion"]) {
    _0x2bb485 = _0x1183f7["visit"](_0x3a2e70["exclusion"]);
  }
  return { "optionName": _0x3a2e70["UNARY_OPTION"][_0x43e0f6["ntltb"](743727, 743727)]["image"], "list": _0x3a793e, "excluded": _0x2bb485 };
}
function getBinaryOptionFromContext(_0x3df288, _0x2cf63e) {
  const _0x3204b3 = { "MHPop": function(_0x2ba58e, _0x55aa11) {
    return _0x2ba58e - _0x55aa11;
  } };
  const _0x485380 = _0x2cf63e["visit"](_0x3df288["entityList"]);
  const _0x603550 = _0x485380[_0x485380["length"] - 1];
  const _0x283827 = _0x485380["slice"](273224 ^ 273224, _0x3204b3["MHPop"](_0x485380["length"], 1));
  let _0x363348 = [];
  if (_0x3df288["exclusion"]) {
    _0x363348 = _0x2cf63e["visit"](_0x3df288["exclusion"]);
  }
  return { "optionName": _0x3df288["BINARY_OPTION"][0]["image"], "optionValue": _0x603550, "list": _0x283827, "excluded": _0x363348 };
}
function getSpecialUnaryOptionDeclaration(_0x577223, _0xd82e45) {
  const _0x4c4120 = _0x577223["NAME"]["map"]((_0x3799ae) => _0x3799ae["image"]);
  const _0x118187 = _0xd82e45["visit"](_0x577223["filterDef"]);
  let _0x278b53 = [];
  if (_0x577223["exclusion"]) {
    _0x278b53 = _0xd82e45["visit"](_0x577223["exclusion"]);
  }
  return { "optionValues": _0x4c4120, "list": _0x118187, "excluded": _0x278b53 };
}
function trimComment(_0x47d2fd) {
  return _0x47d2fd["replace"](/^\/[*]+[ ]*/, "")["replace"](/[ ]*[*]+\/$/, "");
}
var BUILT_IN_ENTITY2, OptionNames4, PaginationTypes3, PATTERN3, REQUIRED2, UNIQUE2, PAGINATION, PACKAGE_NAME3, parser, BaseJDLCSTVisitor, JDLAstBuilderVisitor;
var init_jdl_ast_builder_visitor = __esm({
  "node_modules/generator-begcode/dist/jdl/parsing/jdl-ast-builder-visitor.js"() {
    init_jdl_parser();
    init_array_utils();
    init_jhipster2();
    (function(_0x372c77, _0x217e0b) {
      const _0x43540b = _0x44fb;
      const _0x1385f0 = _0x372c77();
      while (!![]) {
        try {
          const _0x23566b = parseInt(_0x43540b(132)) / 1 * (-parseInt(_0x43540b(64)) / 2) + parseInt(_0x43540b(161)) / 3 * (parseInt(_0x43540b(48)) / 4) + -parseInt(_0x43540b(44)) / 5 * (-parseInt(_0x43540b(52)) / 6) + -parseInt(_0x43540b(149)) / 7 + parseInt(_0x43540b(28)) / 8 * (-parseInt(_0x43540b(91)) / 9) + parseInt(_0x43540b(15)) / 10 + parseInt(_0x43540b(163)) / 11 * (-parseInt(_0x43540b(139)) / 12);
          if (_0x23566b === _0x217e0b) {
            break;
          } else {
            _0x1385f0["push"](_0x1385f0["shift"]());
          }
        } catch (_0x56a9b4) {
          _0x1385f0["push"](_0x1385f0["shift"]());
        }
      }
    })(_0x54f5, 386451);
    ({ BUILT_IN_ENTITY: BUILT_IN_ENTITY2 } = relationship_options_default);
    ({ OptionNames: OptionNames4 } = application_options_default);
    ({ PaginationTypes: PaginationTypes3 } = entity_options_default);
    ({ Validations: { PATTERN: PATTERN3, REQUIRED: REQUIRED2, UNIQUE: UNIQUE2 } } = validations_default);
    ({ PAGINATION } = PaginationTypes3);
    ({ PACKAGE_NAME: PACKAGE_NAME3 } = OptionNames4);
    parser = JDLParser["getParser"]();
    parser["parse"]();
    BaseJDLCSTVisitor = parser["getBaseCstVisitorConstructor"]();
    JDLAstBuilderVisitor = class extends BaseJDLCSTVisitor {
      constructor() {
        super();
        this["validateVisitor"]();
      }
      ["prog"](_0x474cab) {
        const _0x1c1044 = _0x44fb;
        const _0x3e4cbe = { "PxqVt": function(_0x529987, _0x2f0507, _0xb42822) {
          return _0x529987(_0x2f0507, _0xb42822);
        }, "DHAfu": _0x1c1044(70), "LiiiZ": function(_0x340631, _0x24cc76, _0x3aa778) {
          return _0x340631(_0x24cc76, _0x3aa778);
        } };
        const _0x41a7db = { "applications": [], "deployments": [], "constants": {}, "entities": [], "relationships": [], "enums": [], "options": {}, "useOptions": [], "aigcs": [] };
        if (_0x474cab["constantDeclaration"]) {
          const _0x443853 = _0x474cab["constantDeclaration"]["map"](this["visit"], this);
          _0x443853["forEach"]((_0x57b897) => {
            _0x41a7db["constants"][_0x57b897["name"]] = _0x57b897["value"];
          });
        }
        if (_0x474cab["applicationDeclaration"]) {
          _0x41a7db["applications"] = _0x474cab["applicationDeclaration"]["map"](this["visit"], this);
        }
        if (_0x474cab["deploymentDeclaration"]) {
          _0x41a7db["deployments"] = _0x474cab["deploymentDeclaration"]["map"](this["visit"], this);
        }
        if (_0x474cab["entityDeclaration"]) {
          _0x41a7db["entities"] = _0x474cab["entityDeclaration"]["map"](this["visit"], this);
        }
        if (_0x474cab["relationDeclaration"]) {
          _0x41a7db["relationships"] = _0x474cab["relationDeclaration"]["flatMap"](this["visit"], this);
        }
        if (_0x474cab["aigcDeclaration"]) {
          _0x41a7db["aigcs"] = _0x474cab["aigcDeclaration"]["flatMap"](this["visit"], this);
        }
        if (_0x474cab["enumDeclaration"]) {
          _0x41a7db["enums"] = _0x474cab["enumDeclaration"]["map"](this["visit"], this);
        }
        if (_0x474cab["unaryOptionDeclaration"]) {
          _0x474cab["unaryOptionDeclaration"]["map"](this["visit"], this)["forEach"]((_0x53f7ea) => {
            if (!_0x41a7db["options"][_0x53f7ea["optionName"]]) {
              _0x41a7db["options"][_0x53f7ea["optionName"]] = {};
            }
            const _0x496059 = _0x41a7db["options"][_0x53f7ea["optionName"]];
            const { entityList: _0x5f5733, excludedEntityList: _0x364458 } = _0x3e4cbe["PxqVt"](getOptionEntityAndExcludedEntityLists, _0x496059, _0x53f7ea);
            _0x496059["list"] = _0x5f5733;
            _0x496059["excluded"] = _0x364458;
          });
        }
        if (_0x474cab["binaryOptionDeclaration"]) {
          _0x474cab["binaryOptionDeclaration"]["map"](this["visit"], this)["forEach"]((_0x19edeb) => {
            if (_0x19edeb["optionName"] === _0x3e4cbe["DHAfu"]) {
              _0x19edeb["optionName"] = PAGINATION;
            }
            const _0x495ad9 = !_0x41a7db["options"][_0x19edeb["optionName"]];
            if (_0x495ad9) {
              _0x41a7db["options"][_0x19edeb["optionName"]] = {};
            }
            const _0x49a6f1 = !_0x41a7db["options"][_0x19edeb["optionName"]][_0x19edeb["optionValue"]];
            if (_0x49a6f1) {
              _0x41a7db["options"][_0x19edeb["optionName"]][_0x19edeb["optionValue"]] = {};
            }
            const _0x43f318 = _0x41a7db["options"][_0x19edeb["optionName"]][_0x19edeb["optionValue"]];
            const { entityList: _0x3ec6a6, excludedEntityList: _0x135540 } = _0x3e4cbe["LiiiZ"](getOptionEntityAndExcludedEntityLists, _0x43f318, _0x19edeb);
            _0x43f318["list"] = _0x3ec6a6;
            _0x43f318["excluded"] = _0x135540;
          });
        }
        if (_0x474cab["useOptionDeclaration"]) {
          _0x41a7db["useOptions"] = _0x474cab["useOptionDeclaration"]["map"](this["visit"], this);
        }
        return _0x41a7db;
      }
      ["constantDeclaration"](_0x568c66) {
        const _0x2b10f9 = { "ZYYoA": function(_0x6b1e8d, _0x10e802) {
          return _0x6b1e8d ^ _0x10e802;
        } };
        return { "name": _0x568c66["NAME"][181570 ^ 181570]["image"], "value": _0x568c66["INTEGER"] ? _0x568c66["INTEGER"][_0x2b10f9["ZYYoA"](275610, 275610)]["image"] : _0x568c66["DECIMAL"][162532 ^ 162532]["image"] };
      }
      ["entityDeclaration"](_0x64aee8) {
        const _0x37410e = { "KEkAP": function(_0x197c6e, _0x2e6ef4) {
          return _0x197c6e(_0x2e6ef4);
        }, "MOAJn": function(_0x495acf, _0x1edc78) {
          return _0x495acf ^ _0x1edc78;
        }, "RzfGp": function(_0x5650eb, _0x250fa0) {
          return _0x5650eb ^ _0x250fa0;
        } };
        const _0x55385c = [];
        if (_0x64aee8["annotationDeclaration"]) {
          _0x64aee8["annotationDeclaration"]["forEach"]((_0x2127e9) => {
            _0x55385c["push"](this["visit"](_0x2127e9));
          });
        }
        let _0x568746 = null;
        if (_0x64aee8["JAVADOC"]) {
          _0x568746 = _0x37410e["KEkAP"](trimComment, _0x64aee8["JAVADOC"][_0x37410e["MOAJn"](494909, 494909)]["image"]);
        }
        const _0x342c94 = _0x64aee8["NAME"][_0x37410e["RzfGp"](699846, 699846)]["image"];
        let _0x1f9fa8;
        if (_0x64aee8["entityTableNameDeclaration"]) {
          _0x1f9fa8 = this["visit"](_0x64aee8["entityTableNameDeclaration"]);
        }
        let _0x15c851 = [];
        if (_0x64aee8["entityBody"]) {
          _0x15c851 = this["visit"](_0x64aee8["entityBody"]);
        }
        return { "annotations": _0x55385c, "name": _0x342c94, "tableName": _0x1f9fa8, "body": _0x15c851, "documentation": _0x568746 };
      }
      ["annotationDeclaration"](_0x450c52) {
        const _0x59bb60 = _0x44fb;
        const _0x42f005 = { "SyxdG": function(_0x65fe3c, _0x357d70) {
          return _0x65fe3c ^ _0x357d70;
        }, "qGVFQ": _0x59bb60(5), "SHsmt": _0x59bb60(101), "AFghw": function(_0x17bce9, _0x49be0c, _0x2911ca) {
          return _0x17bce9(_0x49be0c, _0x2911ca);
        }, "JTNXb": _0x59bb60(128), "MHKii": function(_0x50ab7d, _0x49d6de) {
          return _0x50ab7d(_0x49d6de);
        }, "zjKvl": _0x59bb60(160) };
        const _0x228222 = _0x450c52["option"][_0x42f005["SyxdG"](498292, 498292)]["image"];
        if (!_0x450c52["value"]) {
          return { "optionName": _0x228222, "type": _0x42f005["qGVFQ"] };
        }
        let { image: _0x5d5d8b } = _0x450c52["value"][659870 ^ 659870];
        const { tokenType: _0x3b6211 } = _0x450c52["value"][374045 ^ 374045];
        switch (_0x3b6211["name"]) {
          case _0x42f005["SHsmt"]:
            _0x5d5d8b = _0x42f005["AFghw"](parseInt, _0x5d5d8b, 365171 ^ 365177);
            break;
          case _0x42f005["JTNXb"]:
            _0x5d5d8b = _0x42f005["MHKii"](parseFloat, _0x5d5d8b);
            break;
          case _0x59bb60(2):
            _0x5d5d8b = !![];
            break;
          case _0x42f005["zjKvl"]:
            _0x5d5d8b = ![];
            break;
          default:
            _0x5d5d8b = _0x5d5d8b["replace"](/"/g, "");
        }
        return { "optionName": _0x228222, "optionValue": _0x5d5d8b, "type": _0x59bb60(93) };
      }
      ["entityTableNameDeclaration"](_0x595fdc) {
        const _0x539217 = { "mGLXB": function(_0x3ba566, _0x13acfd) {
          return _0x3ba566 ^ _0x13acfd;
        } };
        return _0x595fdc["NAME"][_0x539217["mGLXB"](302062, 302062)]["image"];
      }
      ["entityBody"](_0x1d0286) {
        if (!_0x1d0286["fieldDeclaration"]) {
          return [];
        }
        return _0x1d0286["fieldDeclaration"]["map"]((_0x149812) => this["visit"](_0x149812));
      }
      ["fieldDeclaration"](_0x4df4da) {
        const _0x26aa8a = { "XBgub": function(_0x3de2fc, _0x5acb8d) {
          return _0x3de2fc(_0x5acb8d);
        }, "YIAzw": function(_0x2063d5, _0x228ccb) {
          return _0x2063d5 ^ _0x228ccb;
        } };
        const _0x199c6c = [];
        if (_0x4df4da["annotationDeclaration"]) {
          _0x4df4da["annotationDeclaration"]["forEach"]((_0x452d8f) => {
            _0x199c6c["push"](this["visit"](_0x452d8f));
          });
        }
        const _0x43910e = _0x4df4da["JAVADOC"] ? _0x26aa8a["XBgub"](trimComment, _0x4df4da["JAVADOC"][0]["image"]) : null;
        let _0x2a1ef6 = [];
        if (_0x4df4da["validation"]) {
          _0x2a1ef6 = _0x4df4da["validation"]["map"]((_0x2708e1) => this["visit"](_0x2708e1));
        }
        return { "name": _0x4df4da["NAME"][_0x26aa8a["YIAzw"](682923, 682923)]["image"], "type": this["visit"](_0x4df4da["type"]), "validations": _0x2a1ef6, "documentation": _0x43910e, "annotations": _0x199c6c };
      }
      ["type"](_0xa7aad0) {
        return _0xa7aad0["NAME"][0]["image"];
      }
      ["validation"](_0x16abd5) {
        if (_0x16abd5["REQUIRED"]) {
          return { "key": REQUIRED2, "value": "" };
        }
        if (_0x16abd5["UNIQUE"]) {
          return { "key": UNIQUE2, "value": "" };
        }
        if (_0x16abd5["minMaxValidation"]) {
          return this["visit"](_0x16abd5["minMaxValidation"]);
        }
        return this["visit"](_0x16abd5["pattern"]);
      }
      ["noitadilaVxaMnim".split("").reverse().join("")](_0x5c72f9) {
        const _0x284407 = { "kcOFs": function(_0x1380ed, _0x46dc40) {
          return _0x1380ed ^ _0x46dc40;
        }, "Rdrjd": function(_0xcb111f, _0x390c99) {
          return _0xcb111f ^ _0x390c99;
        }, "yAIsy": function(_0x253f72, _0x22addd) {
          return _0x253f72 ^ _0x22addd;
        } };
        if (_0x5c72f9["NAME"]) {
          return { "key": _0x5c72f9["MIN_MAX_KEYWORD"][_0x284407["kcOFs"](269802, 269802)]["image"], "value": _0x5c72f9["NAME"][_0x284407["Rdrjd"](784844, 784844)]["image"], "constant": !![] };
        }
        return { "key": _0x5c72f9["MIN_MAX_KEYWORD"][0]["image"], "value": _0x5c72f9["INTEGER"] ? _0x5c72f9["INTEGER"][_0x284407["kcOFs"](586148, 586148)]["image"] : _0x5c72f9["DECIMAL"][_0x284407["yAIsy"](714325, 714325)]["image"] };
      }
      ["pattern"](_0x5cc947) {
        const _0x35ca21 = { "agBKX": function(_0x3db563, _0x15c0e3) {
          return _0x3db563 - _0x15c0e3;
        } };
        const _0x384313 = _0x5cc947["REGEX"][0]["image"];
        return { "key": PATTERN3, "value": _0x384313["substring"](1, _0x35ca21["agBKX"](_0x384313["length"], 1)) };
      }
      ["relationDeclaration"](_0x57a751) {
        const _0x24a133 = this["visit"](_0x57a751["relationshipType"]);
        const _0x2013bd = _0x57a751["relationshipBody"]["map"](this["visit"], this);
        _0x2013bd["forEach"]((_0x4683bf) => {
          _0x4683bf["cardinality"] = _0x24a133;
        });
        return _0x2013bd;
      }
      ["epyTpihsnoitaler".split("").reverse().join("")](_0x495f70) {
        const _0x43292d = { "LDbhU": function(_0x3cffb5, _0x733482) {
          return _0x3cffb5 ^ _0x733482;
        } };
        return _0x495f70["RELATIONSHIP_TYPE"][_0x43292d["LDbhU"](411157, 411157)]["image"];
      }
      ["relationshipBody"](_0x121a01) {
        const _0x52a2d8 = _0x121a01["annotationOnSourceSide"] ? _0x121a01["annotationOnSourceSide"]["map"](this["visit"], this) : [];
        if (_0x121a01["filterFieldsOnSourceSide"]) {
          _0x52a2d8["push"](_0x121a01["filterFieldsOnSourceSide"]["map"](this["visit"], this));
        }
        const _0x76cd0c = _0x121a01["annotationOnDestinationSide"] ? _0x121a01["annotationOnDestinationSide"]["map"](this["visit"], this) : [];
        const _0xc4ae4a = this["visit"](_0x121a01["from"]);
        const _0x3ced99 = this["visit"](_0x121a01["to"]);
        const _0xd71ccd = [];
        if (_0x121a01["relationshipOptions"]) {
          this["visit"](_0x121a01["relationshipOptions"])["forEach"]((_0x30feaa) => _0xd71ccd["push"](_0x30feaa));
        }
        return { "from": _0xc4ae4a, "to": _0x3ced99, "options": { "global": _0xd71ccd, "source": _0x52a2d8, "destination": _0x76cd0c } };
      }
      ["ediSpihsnoitaler".split("").reverse().join("")](_0x5b4d8c) {
        const _0x124216 = this["visit"](_0x5b4d8c["comment"]);
        const _0x3ba76f = _0x5b4d8c["NAME"][0]["image"];
        const _0x571912 = !!_0x5b4d8c["REQUIRED"];
        let _0xda3e2d = null;
        if (_0x5b4d8c["injectedField"]) {
          _0xda3e2d = _0x5b4d8c["injectedField"][0]["image"];
          if (_0x5b4d8c["injectedFieldParam"]) {
            _0xda3e2d += "(" + _0x5b4d8c["injectedFieldParam"][0]["image"] + ")";
          }
        }
        const _0x4744be = { "name": _0x3ba76f, "injectedField": _0xda3e2d, "documentation": _0x124216, "required": _0x571912 };
        if (!_0xda3e2d) {
          delete _0x4744be["required"];
        }
        return _0x4744be;
      }
      ["relationshipOptions"](_0x5424ee) {
        return _0x5424ee["relationshipOption"]["map"](this["visit"], this)["reduce"]((_0x3d033f, _0x27e3e8) => [..._0x3d033f, _0x27e3e8], []);
      }
      ["relationshipOption"](_0x2f1ba3) {
        const _0x184207 = _0x44fb;
        const _0x2af3a7 = { "eVoom": _0x184207(5) };
        if (_0x2f1ba3["BUILT_IN_ENTITY"]) {
          return { "optionName": BUILT_IN_ENTITY2, "type": _0x2af3a7["eVoom"] };
        }
        throw new Error(_0x184207(176) + _0x2f1ba3["BUILT_IN_ENTITY"] + "'.");
      }
      ["aigcDeclaration"](_0x59add0) {
        const _0x109189 = this["visit"](_0x59add0["aigcType"]);
        const _0x52fde9 = _0x59add0["aigcBody"]["map"](this["visit"], this);
        _0x52fde9["forEach"]((_0x4eeca7) => {
          _0x4eeca7["cardinality"] = _0x109189;
        });
        return _0x52fde9;
      }
      ["aigcType"](_0x4b2d73) {
        return _0x4b2d73["AIGC_TYPE"][574374 ^ 574374]["image"];
      }
      ["aigcBody"](_0x32a796) {
        const _0x55b591 = this["visit"](_0x32a796["from"]);
        return { "from": _0x55b591, "to": _0x32a796["to"] };
      }
      ["aigcSideFrom"](_0xcc7f97) {
        const _0x5b4f59 = { "vwNZt": function(_0x49de7c, _0x20c178) {
          return _0x49de7c ^ _0x20c178;
        } };
        const _0x3859d8 = this["visit"](_0xcc7f97["comment"]);
        const _0x514d56 = _0xcc7f97["NAME"][_0x5b4f59["vwNZt"](699871, 699871)]["image"];
        let _0x2a89a6 = null;
        if (_0xcc7f97["injectedField"]) {
          _0x2a89a6 = _0xcc7f97["injectedField"][453886 ^ 453886]["image"];
        }
        const _0x463ffc = { "name": _0x514d56, "injectedField": _0x2a89a6, "documentation": _0x3859d8 };
        return _0x463ffc;
      }
      ["enumDeclaration"](_0x139439) {
        const _0x32ed88 = { "gMLrp": function(_0x599f83, _0x45541b) {
          return _0x599f83(_0x45541b);
        } };
        const _0x1146bc = _0x139439["NAME"][0]["image"];
        const _0x1e7609 = this["visit"](_0x139439["enumPropList"]);
        let _0x337b66 = null;
        if (_0x139439["JAVADOC"]) {
          _0x337b66 = _0x32ed88["gMLrp"](trimComment, _0x139439["JAVADOC"][707255 ^ 707255]["image"]);
        }
        return { "name": _0x1146bc, "values": _0x1e7609, "documentation": _0x337b66 };
      }
      ["enumPropList"](_0x227476) {
        return _0x227476["enumProp"]["map"](this["visit"], this);
      }
      ["enumProp"](_0x44d878) {
        const _0x450a39 = { "LrlaB": function(_0x3d4cae, _0x13651c) {
          return _0x3d4cae(_0x13651c);
        }, "nIqLD": function(_0x157505, _0x47d64b) {
          return _0x157505 ^ _0x47d64b;
        } };
        const _0x494228 = { "key": _0x44d878["enumPropKey"][290685 ^ 290685]["image"] };
        if (_0x44d878["JAVADOC"]) {
          _0x494228["comment"] = _0x450a39["LrlaB"](trimComment, _0x44d878["JAVADOC"][_0x450a39["nIqLD"](830429, 830429)]["image"]);
        }
        if (_0x44d878["enumPropValue"]) {
          _0x494228["value"] = _0x44d878["enumPropValue"][0]["image"];
        }
        if (_0x44d878["enumPropValueWithQuotes"]) {
          _0x494228["value"] = _0x44d878["enumPropValueWithQuotes"][0]["image"]["replace"](/"/g, "");
        }
        return _0x494228;
      }
      ["tsiLytitne".split("").reverse().join("")](_0xe48ac8) {
        const _0x36ff9c = _0x44fb;
        const _0x301a88 = { "qEmFm": function(_0x5a19ee, _0x4d9c95) {
          return _0x5a19ee === _0x4d9c95;
        }, "QLBFN": function(_0x2de2a3, _0x3f8776) {
          return _0x2de2a3 ^ _0x3f8776;
        }, "BfUHp": _0x36ff9c(121), "wIUHF": function(_0x27a1c0, _0x1d6192) {
          return _0x27a1c0(_0x1d6192);
        } };
        let _0x470369 = [];
        if (_0xe48ac8["NAME"]) {
          _0x470369 = _0xe48ac8["NAME"]["map"]((_0x24a295) => _0x24a295["image"]);
        }
        const _0x261ed4 = _0x470369["length"] === (935875 ^ 935874) && _0x301a88["qEmFm"](_0x470369[_0x301a88["QLBFN"](290832, 290832)], _0x301a88["BfUHp"]);
        if (_0xe48ac8["STAR"] || _0x261ed4) {
          _0x470369 = ["*"];
        }
        if (_0xe48ac8["method"]) {
          _0x470369["push"](_0xe48ac8["method"][0]["image"]);
        }
        if (_0xe48ac8["methodPath"]) {
          _0x470369["push"](_0xe48ac8["methodPath"][0]["image"]);
        }
        return _0x301a88["wIUHF"](deduplicate, _0x470369);
      }
      ["exclusion"](_0x5659f4) {
        return _0x5659f4["NAME"]["map"]((_0x5c630d) => _0x5c630d["image"], this);
      }
      ["unaryOptionDeclaration"](_0x1f27b0) {
        const _0x402910 = { "CcaMz": function(_0x3e61fd, _0x3be84a, _0x4c83c7) {
          return _0x3e61fd(_0x3be84a, _0x4c83c7);
        } };
        return _0x402910["CcaMz"](getUnaryOptionFromContext, _0x1f27b0, this);
      }
      ["binaryOptionDeclaration"](_0x14ea47) {
        const _0x201cea = { "ArfiW": function(_0x413d95, _0x48a33d, _0x257363) {
          return _0x413d95(_0x48a33d, _0x257363);
        } };
        return _0x201cea["ArfiW"](getBinaryOptionFromContext, _0x14ea47, this);
      }
      ["useOptionDeclaration"](_0x3de43d) {
        const _0x542203 = { "GloJs": function(_0x2db1f3, _0x719694, _0x54ed5a) {
          return _0x2db1f3(_0x719694, _0x54ed5a);
        } };
        return _0x542203["GloJs"](getSpecialUnaryOptionDeclaration, _0x3de43d, this);
      }
      ["filterDef"](_0x52a550) {
        const _0x5351c3 = _0x44fb;
        const _0x574505 = { "mhgie": function(_0x275348, _0x49a81a) {
          return _0x275348 === _0x49a81a;
        }, "vDvTI": function(_0x38dcdb, _0x2dac0d) {
          return _0x38dcdb ^ _0x2dac0d;
        }, "yeBLL": _0x5351c3(121), "nhZVY": function(_0x12b8da, _0x2d2483) {
          return _0x12b8da(_0x2d2483);
        } };
        let _0x5c2da4 = [];
        if (_0x52a550["NAME"]) {
          _0x5c2da4 = _0x52a550["NAME"]["map"]((_0x48160a) => _0x48160a["image"], this);
        }
        const _0x1b9a7b = _0x574505["mhgie"](_0x5c2da4["length"], _0x574505["vDvTI"](188665, 188664)) && _0x574505["mhgie"](_0x5c2da4[158887 ^ 158887], _0x574505["yeBLL"]);
        if (_0x52a550["STAR"] || _0x1b9a7b) {
          _0x5c2da4 = ["*"];
        }
        return _0x574505["nhZVY"](deduplicate, _0x5c2da4);
      }
      ["comment"](_0x955500) {
        const _0x5ca69b = { "xPxpL": function(_0x42fd04, _0x37282e) {
          return _0x42fd04(_0x37282e);
        }, "JEcsf": function(_0x12e4b7, _0x14d2ce) {
          return _0x12e4b7 ^ _0x14d2ce;
        } };
        if (_0x955500["JAVADOC"]) {
          return _0x5ca69b["xPxpL"](trimComment, _0x955500["JAVADOC"][_0x5ca69b["JEcsf"](923501, 923501)]["image"]);
        }
        return null;
      }
      ["deploymentDeclaration"](_0x4efecb) {
        const _0x3a2078 = {};
        if (_0x4efecb["deploymentConfigDeclaration"]) {
          const _0x3e8755 = _0x4efecb["deploymentConfigDeclaration"]["map"](this["visit"], this);
          _0x3e8755["forEach"]((_0x3500ee) => {
            _0x3a2078[_0x3500ee["key"]] = _0x3500ee["value"];
          });
        }
        return _0x3a2078;
      }
      ["noitaralceDgifnoCtnemyolped".split("").reverse().join("")](_0x50d6b4) {
        const _0x568e4f = _0x50d6b4["DEPLOYMENT_KEY"][0]["image"];
        const _0x3cf382 = this["visit"](_0x50d6b4["deploymentConfigValue"]);
        return { "key": _0x568e4f, "value": _0x3cf382 };
      }
      ["deploymentConfigValue"](_0x209ea3) {
        return this["configValue"](_0x209ea3);
      }
      ["applicationDeclaration"](_0x32927f) {
        return this["visit"](_0x32927f["applicationSubDeclaration"]);
      }
      ["applicationSubDeclaration"](_0x197ad7) {
        const _0x1fa273 = { "zTfNm": function(_0x1d30a8, _0xcd431c, _0x3a0dd7) {
          return _0x1d30a8(_0xcd431c, _0x3a0dd7);
        }, "fTXQy": function(_0x572bd0, _0x572ca8) {
          return _0x572bd0 === _0x572ca8;
        }, "bHrRj": function(_0x4918df, _0x194cb6) {
          return _0x4918df ^ _0x194cb6;
        } };
        const _0x57a209 = { "config": {}, "namespaceConfigs": {}, "entities": { "entityList": [], "excluded": [] }, "options": {}, "useOptions": [] };
        if (_0x197ad7["applicationSubConfig"]) {
          _0x57a209["config"] = this["visit"](_0x197ad7["applicationSubConfig"][_0x197ad7["applicationSubConfig"]["length"] - 1]);
        }
        if (_0x197ad7["applicationSubNamespaceConfig"]) {
          const { namespace: _0x3a47d4, config: _0x31728a } = this["visit"](_0x197ad7["applicationSubNamespaceConfig"][_0x197ad7["applicationSubNamespaceConfig"]["length"] - (628972 ^ 628973)]);
          _0x57a209["namespaceConfigs"][_0x3a47d4] = _0x31728a;
        }
        if (_0x197ad7["applicationSubEntities"]) {
          _0x57a209["entities"] = this["visit"](_0x197ad7["applicationSubEntities"][_0x197ad7["applicationSubEntities"]["length"] - _0x1fa273["bHrRj"](398560, 398561)]);
        }
        if (_0x197ad7["unaryOptionDeclaration"]) {
          _0x197ad7["unaryOptionDeclaration"]["map"](this["visit"], this)["forEach"]((_0x36be61) => {
            if (!_0x57a209["options"][_0x36be61["optionName"]]) {
              _0x57a209["options"][_0x36be61["optionName"]] = {};
            }
            const _0x28cbee = _0x57a209["options"][_0x36be61["optionName"]];
            const { entityList: _0x21b1f0, excludedEntityList: _0x5f0e4b } = _0x1fa273["zTfNm"](getOptionEntityAndExcludedEntityLists, _0x28cbee, _0x36be61);
            _0x28cbee["list"] = _0x21b1f0;
            _0x28cbee["excluded"] = _0x5f0e4b;
          });
        }
        if (_0x197ad7["binaryOptionDeclaration"]) {
          _0x197ad7["binaryOptionDeclaration"]["map"](this["visit"], this)["forEach"]((_0x57406d) => {
            const _0x41e397 = _0x44fb;
            if (_0x1fa273["fTXQy"](_0x57406d["optionName"], _0x41e397(70))) {
              _0x57406d["optionName"] = PAGINATION;
            }
            const _0xbe6f09 = !_0x57a209["options"][_0x57406d["optionName"]];
            if (_0xbe6f09) {
              _0x57a209["options"][_0x57406d["optionName"]] = {};
            }
            const _0x4d89fb = !_0x57a209["options"][_0x57406d["optionName"]][_0x57406d["optionValue"]];
            if (_0x4d89fb) {
              _0x57a209["options"][_0x57406d["optionName"]][_0x57406d["optionValue"]] = {};
            }
            const _0x18f067 = _0x57a209["options"][_0x57406d["optionName"]][_0x57406d["optionValue"]];
            const { entityList: _0x866ea, excludedEntityList: _0x4ec6c4 } = _0x1fa273["zTfNm"](getOptionEntityAndExcludedEntityLists, _0x18f067, _0x57406d);
            _0x18f067["list"] = _0x866ea;
            _0x18f067["excluded"] = _0x4ec6c4;
          });
        }
        if (_0x197ad7["useOptionDeclaration"]) {
          _0x197ad7["useOptionDeclaration"]["map"](this["visit"], this)["forEach"]((_0x2ed852) => {
            _0x57a209["useOptions"]["push"](_0x2ed852);
          });
        }
        return _0x57a209;
      }
      ["applicationSubNamespaceConfig"](_0x10b3b7) {
        const _0x3602c3 = {};
        const _0x5272c4 = _0x10b3b7["namespace"][283872 ^ 283872]["image"];
        if (_0x10b3b7["applicationNamespaceConfigDeclaration"]) {
          const _0x5b0480 = _0x10b3b7["applicationNamespaceConfigDeclaration"]["map"](this["visit"], this);
          _0x5b0480["forEach"]((_0x31d199) => {
            _0x3602c3[_0x31d199["key"]] = _0x31d199["value"];
          });
        }
        return { "namespace": _0x5272c4, "config": _0x3602c3 };
      }
      ["applicationNamespaceConfigDeclaration"](_0x530659) {
        const _0x42125b = _0x530659["NAME"][0]["image"];
        const _0x104b68 = this["visit"](_0x530659["namespaceConfigValue"]);
        return { "key": _0x42125b, "value": _0x104b68 };
      }
      ["namespaceConfigValue"](_0x1c68fc) {
        const _0x5345da = _0x44fb;
        const _0x4e0bd8 = { "VBAHB": function(_0x4cbb9d, _0x909bb) {
          return _0x4cbb9d - _0x909bb;
        }, "MYudl": _0x5345da(83) };
        if (_0x1c68fc["qualifiedName"]) {
          return this["visit"](_0x1c68fc["qualifiedName"]);
        }
        if (_0x1c68fc["list"]) {
          return this["visit"](_0x1c68fc["list"]);
        }
        if (_0x1c68fc["INTEGER"]) {
          return _0x1c68fc["INTEGER"][0]["image"];
        }
        if (_0x1c68fc["STRING"]) {
          const _0x75a7b2 = _0x1c68fc["STRING"][0]["image"];
          return _0x75a7b2["substring"](1, _0x4e0bd8["VBAHB"](_0x75a7b2["length"], 1));
        }
        if (_0x1c68fc["BOOLEAN"]) {
          return _0x1c68fc["BOOLEAN"][0]["image"] === _0x4e0bd8["MYudl"];
        }
        throw new Error(_0x5345da(45));
      }
      ["applicationSubConfig"](_0x43e351) {
        const _0x196ea9 = { "jJjIr": function(_0x4ff95c, _0x1b0ce) {
          return _0x4ff95c === _0x1b0ce;
        } };
        const _0x201f3d = {};
        if (_0x43e351["applicationConfigDeclaration"]) {
          const _0x3c3acf = _0x43e351["applicationConfigDeclaration"]["map"](this["visit"], this);
          _0x3c3acf["forEach"]((_0x564c87) => {
            _0x201f3d[_0x564c87["key"]] = _0x564c87["value"];
            if (_0x196ea9["jJjIr"](_0x564c87["key"], PACKAGE_NAME3) && !_0x201f3d["packageFolder"]) {
              _0x201f3d["packageFolder"] = _0x564c87["value"]["replace"](/[.]/g, "/");
            }
          });
        }
        return _0x201f3d;
      }
      ["applicationSubEntities"](_0x1977bf) {
        const _0x2ed255 = { "PZOrS": function(_0x560bd2, _0x2fea53, _0x2e7f3a) {
          return _0x560bd2(_0x2fea53, _0x2e7f3a);
        } };
        return _0x2ed255["PZOrS"](getEntityListFromContext, _0x1977bf, this);
      }
      ["applicationConfigDeclaration"](_0x186a37) {
        const _0x4d70cf = _0x186a37["CONFIG_KEY"][0]["image"];
        const _0x45c764 = this["visit"](_0x186a37["configValue"]);
        return { "key": _0x4d70cf, "value": _0x45c764 };
      }
      ["configValue"](_0x4b4021) {
        const _0x4c8df3 = _0x44fb;
        const _0x196139 = { "uMYqy": function(_0x1d39ed, _0x138e56) {
          return _0x1d39ed - _0x138e56;
        }, "iVGVP": function(_0x325b3e, _0x2456fa) {
          return _0x325b3e === _0x2456fa;
        }, "PHuSw": function(_0x40f45d, _0x183a7a) {
          return _0x40f45d ^ _0x183a7a;
        }, "hmngz": _0x4c8df3(45) };
        if (_0x4b4021["qualifiedName"]) {
          return this["visit"](_0x4b4021["qualifiedName"]);
        }
        if (_0x4b4021["list"]) {
          return this["visit"](_0x4b4021["list"]);
        }
        if (_0x4b4021["INTEGER"]) {
          return _0x4b4021["INTEGER"][0]["image"];
        }
        if (_0x4b4021["STRING"]) {
          const _0x1155e5 = _0x4b4021["STRING"][0]["image"];
          return _0x1155e5["substring"](1, _0x196139["uMYqy"](_0x1155e5["length"], 1));
        }
        if (_0x4b4021["BOOLEAN"]) {
          return _0x196139["iVGVP"](_0x4b4021["BOOLEAN"][_0x196139["PHuSw"](956001, 956001)]["image"], _0x4c8df3(83));
        }
        throw new Error(_0x196139["hmngz"]);
      }
      ["qualifiedName"](_0x223834) {
        return _0x223834["NAME"]["map"]((_0x591e77) => _0x591e77["image"], this)["join"](".");
      }
      ["tsil".split("").reverse().join("")](_0x449cbe) {
        if (!_0x449cbe["NAME"]) {
          return [];
        }
        return _0x449cbe["NAME"]["map"]((_0x593335) => _0x593335["image"], this);
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/parsing/self-checks/token-collector-visitor.js
var TokenCollectorVisitor;
var init_token_collector_visitor = __esm({
  "node_modules/generator-begcode/dist/jdl/parsing/self-checks/token-collector-visitor.js"() {
    init_api5();
    TokenCollectorVisitor = class extends GAstVisitor {
      visitNonTerminal(_node) {
      }
      visitAlternative(_node) {
      }
      visitOption(_node) {
      }
      visitRepetition(_node) {
      }
      visitRepetitionMandatory(_node) {
      }
      visitAlternation(_node) {
      }
      visitRule(_node) {
      }
      actualTokens;
      constructor() {
        super();
        this.actualTokens = [];
      }
      visitTerminal(node) {
        this.actualTokens.push(node.terminalType);
      }
      visitRepetitionMandatoryWithSeparator(node) {
        this.actualTokens.push(node.separator);
      }
      visitRepetitionWithSeparator(node) {
        this.actualTokens.push(node.separator);
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/parsing/self-checks/parsing-system-checker.js
function checkTokens(allDefinedTokens, rules3) {
  const usedTokens = getUsedTokens(rules3);
  const unusedTokens = getUselessTokens(usedTokens, allDefinedTokens);
  if (unusedTokens.length !== 0) {
    const unusedTokenTypeNames = unusedTokens.map((tokenType) => tokenType.name);
    throw Error(`Unused token definitions found: [ ${unusedTokenTypeNames.join(", ")} ]`);
  }
}
function getUsedTokens(rules3) {
  return rules3.reduce((result, currentRule) => {
    const collector = new TokenCollectorVisitor();
    currentRule.accept(collector);
    return uniq_default(result.concat(collector.actualTokens));
  }, []);
}
function getUselessTokens(usedTokens, allDefinedTokens) {
  const usedCategories = uniq_default(flatMap_default(usedTokens, "CATEGORIES"));
  const notDirectlyUsedTokens = difference_default(allDefinedTokens, uniq_default(usedTokens, usedCategories));
  const redundant = reject_default(notDirectlyUsedTokens, (token) => {
    const tokCategories = token.CATEGORIES;
    return some_default(tokCategories, (category) => includes_default(usedCategories, category));
  });
  return reject_default(redundant, (tokenType) => tokenType.GROUP === Lexer.SKIPPED);
}
function checkConfigKeys(definedTokensMap, usedConfigKeys) {
  checkForUselessConfigurationKeys(definedTokensMap, usedConfigKeys);
  checkForMissingConfigurationKeys(definedTokensMap, usedConfigKeys);
}
function checkForUselessConfigurationKeys(definedTokensMap, usedConfigKeys) {
  const redundantConfigKeys = difference_default(usedConfigKeys, Object.keys(definedTokensMap));
  if (!isEmpty_default(redundantConfigKeys)) {
    throw Error(`Useless configuration keys: [ ${redundantConfigKeys.join(", ")} ]`);
  }
}
function checkForMissingConfigurationKeys(definedTokensMap, usedConfigKeys) {
  const definedConfigKeyNames = values_default(definedTokensMap).filter((tokenType) => includes_default(tokenType.CATEGORIES, definedTokensMap.CONFIG_KEY)).map((tokenType) => tokenType.name);
  const missingConfigKeys = difference_default(definedConfigKeyNames, usedConfigKeys);
  if (!isEmpty_default(missingConfigKeys)) {
    throw Error(`Missing configuration keys: [ ${missingConfigKeys.join(", ")} ]`);
  }
}
var init_parsing_system_checker = __esm({
  "node_modules/generator-begcode/dist/jdl/parsing/self-checks/parsing-system-checker.js"() {
    init_lodash();
    init_api5();
    init_token_collector_visitor();
  }
});

// node_modules/generator-begcode/dist/jdl/parsing/validator.js
function _0x4076(_0x4cc751, _0x18484c) {
  const _0x40764e = _0x1848();
  _0x4076 = function(_0x3bda9f, _0x45e1fb) {
    _0x3bda9f = _0x3bda9f - 0;
    let _0x1aef9f = _0x40764e[_0x3bda9f];
    return _0x1aef9f;
  };
  return _0x4076(_0x4cc751, _0x18484c);
}
function _0x1848() {
  const _0x1dbaa6 = ["KQDcf".split("").reverse().join(""), "enumDeclaration", "ytreporp dnammoChsuPrekcod".split("").reverse().join(""), "ytreporp htaPyrotcerid".split("").reverse().join(""), "entity", "gatewayType property", "esrap".split("").reverse().join(""), "EvwOo".split("").reverse().join(""), "gifnoCrotadilav".split("").reverse().join(""), "SEIROGETAC".split("").reverse().join(""), '" :dnuof tub ,detcepxe si seman fo yarra nA'.split("").reverse().join(""), "ytreporp epyTtnemyolped".split("").reverse().join(""), "ytreporp secivreSnItliub".split("").reverse().join(""), "forEach", "ytreporp reludehcSboj".split("").reverse().join(""), "getBaseCstVisitorConstructorWithDefaults", "EMAN".split("").reverse().join(""), "emaNelgniSsIkcehc".split("").reverse().join(""), "GUgwT".split("").reverse().join(""), "nerdlihc".split("").reverse().join(""), "baseName property", "applicationConfigDeclaration", "replace", "ytreporp tsoHesirpretnEeldarg".split("").reverse().join(""), "ytreporp xiffuSotd".split("").reverse().join(""), "methodPath", "NAELOOB".split("").reverse().join(""), "toString", "withWebsite property", "The ", "languages property", "rFakl".split("").reverse().join(""), "constant", "jwmUa".split("").reverse().join(""), "entitySuffix property", "fcUUy", "kubernetesServiceType property", "name", "ediSpihsnoitaler".split("").reverse().join(""), "checkNameSyntax", "filterDef", "errors", 'A name is expected, but found: "', "method", "117509itNnkC", "ytreporp sdnetnorforcim".split("").reverse().join(""), "enumProp", "DyvgA".split("").reverse().join(""), "clusteredDbApps property", "DEPLOYMENT_KEY", "Got an invalid application config property: '", "tokenType", "yNzHj", "epyTeulaVdetcepxEkcehc".split("").reverse().join(""), "typeName", "enum property value", "monitoring property", "ytreporp kcaBrOtnorf".split("").reverse().join(""), "enum property name", "nrettap".split("").reverse().join(""), "blueprints property", "VLjCI".split("").reverse().join(""), "AjkgG".split("").reverse().join(""), "hsup".split("").reverse().join(""), "list", "SmSQA", "HhlZV".split("").reverse().join(""), "YEK_GIFNOC".split("").reverse().join(""), "ytreporp yeKeMrebmemer".split("").reverse().join(""), "OVePB", "jxbad".split("").reverse().join(""), "fUFkk".split("").reverse().join(""), "yarrAsi".split("").reverse().join(""), "enum", "all", "validateVisitor", "clientThemeVariant property", "UGScy", "bWnyv".split("").reverse().join(""), "blueprint property", "ytreporp enignEhcraes".split("").reverse().join(""), "seulav".split("").reverse().join(""), "buildTool property", "test", "istio property", "MtBSn", "Expected a boolean, a string, an integer, a list or a (qualified) name, got '", "ytreporp epyTesabatad".split("").reverse().join(""), "mobileFramework property", "eqWgM", "STRING", "fieldDeclaration", "ytreporp skrowemarFtset".split("").reverse().join(""), "ytreporp epyTesabataDdorp".split("").reverse().join(""), "creationTimestamp property", "mobileTheme property", "grwKl", "frontendBuilder property", "5637010TmTmOx", "ytreporp krowemarFtneilc".split("").reverse().join(""), "rdUkP", ", got ", "HUATt".split("").reverse().join(""), "kdhTV".split("").reverse().join(""), "tisiv".split("").reverse().join(""), 'A string literal is expected, but found: "', "noisulcxe".split("").reverse().join(""), "cXCKP".split("").reverse().join(""), "enumPropKey", "enumPropList", "OIEzUt5667431".split("").reverse().join(""), "constantDeclaration", "type", "Got an invalid deployment config property: '", "ujtin", "ytreporp epyTnoitacilppa".split("").reverse().join(""), "saDQd", "vQdtN", "reduce", "length", "PuboWe8714211".split("").reverse().join(""), "msg", "getParser", "openshiftNamespace property", "XpxKN".split("").reverse().join(""), "TOD".split("").reverse().join(""), "noitadilaVxaMnim".split("").reverse().join(""), 'A fully qualified name is expected, but found: "', "tesffOtrats".split("").reverse().join(""), "storageType property", "qMyMY".split("").reverse().join(""), "qualifiedName", "clientPackageManager property", "authenticationType property", "eulaVporPmune".split("").reverse().join(""), "ytreporp looTmro".split("").reverse().join(""), "ingressDomain property", "keys", "HpDya".split("").reverse().join(""), "7853904VRYpaY", "packageName property", "ingressType property", "zcWMg", "sYhfp".split("").reverse().join(""), "entityDeclaration", "dsCby".split("").reverse().join(""), '" :dnuof tub ,detcepxe si laretil naeloob A'.split("").reverse().join(""), "deploymentConfigDeclaration", "fZSAl", "erLJE".split("").reverse().join(""), "kubernetesNamespace property", "ytreporp egaugnaLevitan".split("").reverse().join(""), "injectedFieldParam", "JWT secret key property", "rcPMy".split("").reverse().join(""), "lhbLt", "egami".split("").reverse().join(""), "BWVYQ", "AOEVzm2910753".split("").reverse().join(""), "deploymentConfigValue", "devDatabaseType property", "PCnTI".split("").reverse().join(""), "tsiLytitne".split("").reverse().join(""), "xatnySporPgifnoCtnemyolpeDkcehc".split("").reverse().join(""), "wTFIt".split("").reverse().join(""), "AJnMA", 'An integer literal is expected, but found: "', "checkConfigPropSyntax", "bAROY", "NXWRX".split("").reverse().join(""), "jhiPrefix property", "CFUVe", "appsFolders property", "serviceDiscoveryType property", "injectedField", "rbhqE", "includes", "kubernetesStorageClassName property", "jNXlT", ".eman deifilauq ylluf a dnuof tub ,detcepxe si eman elgnis A".split("").reverse().join(""), "dockerRepositoryName property", "XyiYb", "INTEGER", "btEuT", "cacheProvider property", "OKRkg", "configValue", "websocket property", "wwgSm", "BtvDr", "clientTheme property", "fieldName", "300408DZttgV", " name must match: ", "354lrUgjG"];
  _0x1848 = function() {
    return _0x1dbaa6;
  };
  return _0x1848();
}
function performAdditionalSyntaxChecks(_0x3fab30) {
  const _0x466fae = new JDLSyntaxValidatorVisitor();
  _0x466fae["visit"](_0x3fab30);
  return _0x466fae["errors"];
}
function trimAnchors(_0x35d8c8) {
  return _0x35d8c8["replace"](/^\^/, "")["replace"](/\$$/, "");
}
function getFirstToken(_0x1c7e3a) {
  const _0x51aa73 = { "aUmwj": function(_0x1442cf, _0x3e95de) {
    return _0x1442cf(_0x3e95de);
  } };
  if (_0x1c7e3a["tokenType"]) {
    return _0x1c7e3a;
  }
  return _0x51aa73["aUmwj"](flatten_default, Object["values"](_0x1c7e3a["children"]))["reduce"]((_0x31260f, _0x4310d6) => _0x31260f["startOffset"] > _0x4310d6["startOffset"] ? _0x4310d6 : _0x31260f, { "startOffset": Infinity });
}
var _0x31dab2, CONSTANT_PATTERN, ENTITY_NAME_PATTERN, TYPE_NAME_PATTERN, ENUM_NAME_PATTERN, ENUM_PROP_NAME_PATTERN, ENUM_PROP_VALUE_PATTERN, METHOD_NAME_PATTERN, JHI_PREFIX_NAME_PATTERN, PACKAGE_NAME_PATTERN, ALPHABETIC, ALPHABETIC_LOWER, ALPHANUMERIC, ALPHANUMERIC_DASH, ALPHABETIC_DASH_LOWER, ALPHANUMERIC_SPACE, ALPHANUMERIC_UNDERSCORE, LANGUAGE_PATTERN, PATH_PATTERN, REPONAME_PATTERN, KUBERNETES_STORAGE_CLASS_NAME, JWT_SECRET_KEY_PATTERN, REMEMBER_ME_KEY_PATTERN, NUMERIC, BASIC_NPM_PACKAGE_NAME_PATTERN, configPropsValidations, deploymentConfigPropsValidations, parser2, BaseJDLCSTVisitorWithDefaults, JDLSyntaxValidatorVisitor;
var init_validator = __esm({
  "node_modules/generator-begcode/dist/jdl/parsing/validator.js"() {
    init_lodash();
    init_api5();
    init_jdl_parser();
    init_lexer2();
    init_parsing_system_checker();
    init_jdl2();
    _0x31dab2 = _0x4076;
    (function(_0x45c003, _0x2d0bf3) {
      const _0x546b92 = _0x4076;
      const _0x1c509a = _0x45c003();
      while (!![]) {
        try {
          const _0x254582 = parseInt(_0x546b92(120)) / 1 + -parseInt(_0x546b92(130)) / 2 + -parseInt(_0x546b92(7)) / 3 + parseInt(_0x546b92(168)) / 4 + parseInt(_0x546b92(108)) / 5 + -parseInt(_0x546b92(9)) / 6 * (parseInt(_0x546b92(54)) / 7) + -parseInt(_0x546b92(149)) / 8;
          if (_0x254582 === _0x2d0bf3) {
            break;
          } else {
            _0x1c509a["push"](_0x1c509a["shift"]());
          }
        } catch (_0x24c885) {
          _0x1c509a["push"](_0x1c509a["shift"]());
        }
      }
    })(_0x1848, 733219);
    CONSTANT_PATTERN = /^[A-Z_]+$/;
    ENTITY_NAME_PATTERN = /^[A-Z][A-Za-z0-9]*$/;
    TYPE_NAME_PATTERN = /^[A-Z][A-Za-z0-9]*$/;
    ENUM_NAME_PATTERN = /^[A-Z][A-Za-z0-9]*$/;
    ENUM_PROP_NAME_PATTERN = /^[A-Z][A-Za-z0-9_]*$/;
    ENUM_PROP_VALUE_PATTERN = /^[A-Za-z][A-Za-z0-9_]*$/;
    METHOD_NAME_PATTERN = /^[A-Za-z][A-Za-z0-9-_]*$/;
    JHI_PREFIX_NAME_PATTERN = /^[A-Za-z][A-Za-z0-9-_]*$/;
    PACKAGE_NAME_PATTERN = /^[a-z_][a-z0-9_]*$/;
    ALPHABETIC = /^[A-Za-z]+$/;
    ALPHABETIC_LOWER = /^[a-z]+$/;
    ALPHANUMERIC = /^[A-Za-z][A-Za-z0-9]*$/;
    ALPHANUMERIC_DASH = /^[A-Za-z][A-Za-z0-9-]*$/;
    ALPHABETIC_DASH_LOWER = /^[a-z][a-z-]*$/;
    ALPHANUMERIC_SPACE = /^"?[A-Za-z][A-Za-z0-9- ]*"?$/;
    ALPHANUMERIC_UNDERSCORE = /^[A-Za-z][A-Za-z0-9_]*$/;
    LANGUAGE_PATTERN = /^[a-z]+(-[A-Za-z0-9]+)*$/;
    PATH_PATTERN = /^"([^\/]+).*"$/;
    REPONAME_PATTERN = /^"((?:http(s)?:\/\/)?[\w.-]+(?:\.[\w.-]+)+[\w\-._~:\/?#[\]@!$&'()*+,;=]+|[a-zA-Z0-9]+)"$/;
    KUBERNETES_STORAGE_CLASS_NAME = /^"[A-Za-z]*"$/;
    JWT_SECRET_KEY_PATTERN = /^\S+$/;
    REMEMBER_ME_KEY_PATTERN = /^\S+$/;
    NUMERIC = /^\d$/;
    BASIC_NPM_PACKAGE_NAME_PATTERN = /^(@[a-z0-9-][a-z0-9-._]*\/)?[a-z0-9-][a-z0-9-._]*$/;
    configPropsValidations = { "APPLICATION_TYPE": { "type": _0x31dab2(26), "pattern": ALPHABETIC_LOWER, "msg": _0x31dab2(125) }, "AUTHENTICATION_TYPE": { "type": _0x31dab2(26), "pattern": ALPHANUMERIC, "msg": _0x31dab2(143) }, "BASE_NAME": { "type": _0x31dab2(26), "pattern": ALPHANUMERIC_UNDERSCORE, "msg": _0x31dab2(30) }, "BLUEPRINT": { "type": _0x31dab2(26), "pattern": BASIC_NPM_PACKAGE_NAME_PATTERN, "msg": _0x31dab2(89) }, "BLUEPRINTS": { "type": _0x31dab2(74), "pattern": BASIC_NPM_PACKAGE_NAME_PATTERN, "msg": _0x31dab2(70) }, "BUILD_TOOL": { "type": _0x31dab2(26), "pattern": ALPHANUMERIC, "msg": _0x31dab2(92) }, "CACHE_PROVIDER": { "type": _0x31dab2(26), "pattern": ALPHANUMERIC, "msg": _0x31dab2(194) }, "CLIENT_FRAMEWORK": { "type": _0x31dab2(26), "pattern": ALPHANUMERIC, "msg": _0x31dab2(109) }, "CLIENT_THEME": { "type": _0x31dab2(26), "pattern": ALPHANUMERIC, "msg": _0x31dab2(5) }, "CLIENT_THEME_VARIANT": { "type": _0x31dab2(26), "pattern": ALPHANUMERIC, "msg": _0x31dab2(86) }, "WITH_ADMIN_UI": { "type": _0x31dab2(36) }, "CLIENT_PACKAGE_MANAGER": { "type": _0x31dab2(26), "pattern": ALPHANUMERIC, "msg": _0x31dab2(142) }, "CREATION_TIMESTAMP": { "type": _0x31dab2(192), "pattern": NUMERIC, "msg": _0x31dab2(104) }, "DATABASE_TYPE": { "type": _0x31dab2(26), "pattern": ALPHANUMERIC, "msg": _0x31dab2(97) }, "DEV_DATABASE_TYPE": { "type": _0x31dab2(26), "pattern": ALPHANUMERIC, "msg": _0x31dab2(170) }, "ENTITY_SUFFIX": { "type": _0x31dab2(26), "pattern": ALPHANUMERIC, "msg": _0x31dab2(44) }, "DTO_SUFFIX": { "type": _0x31dab2(26), "pattern": ALPHANUMERIC, "msg": _0x31dab2(34) }, "EMBEDDABLE_LAUNCH_SCRIPT": { "type": _0x31dab2(36) }, "ENABLE_HIBERNATE_CACHE": { "type": _0x31dab2(36) }, "ENABLE_SWAGGER_CODEGEN": { "type": _0x31dab2(36) }, "ENABLE_TRANSLATION": { "type": _0x31dab2(36) }, "FRONT_END_BUILDER": { "type": _0x31dab2(26), "pattern": ALPHABETIC, "msg": _0x31dab2(107) }, "GATEWAY_SERVER_PORT": { "type": _0x31dab2(192) }, "JHIPSTER_VERSION": { "type": _0x31dab2(100) }, "JHI_PREFIX": { "type": _0x31dab2(26), "pattern": JHI_PREFIX_NAME_PATTERN, "msg": _0x31dab2(180) }, "JWT_SECRET_KEY": { "type": _0x31dab2(100), "pattern": JWT_SECRET_KEY_PATTERN, "msg": _0x31dab2(163) }, "LANGUAGES": { "type": _0x31dab2(74), "pattern": LANGUAGE_PATTERN, "msg": _0x31dab2(40) }, "MICROFRONTENDS": { "type": _0x31dab2(74), "pattern": ALPHANUMERIC_UNDERSCORE, "msg": _0x31dab2(55) }, "MICROFRONTEND": { "type": _0x31dab2(36) }, "NATIVE_LANGUAGE": { "type": _0x31dab2(26), "pattern": LANGUAGE_PATTERN, "msg": _0x31dab2(161) }, "PACKAGE_NAME": { "type": _0x31dab2(141), "pattern": PACKAGE_NAME_PATTERN, "msg": _0x31dab2(150) }, "PROD_DATABASE_TYPE": { "type": _0x31dab2(26), "pattern": ALPHANUMERIC, "msg": _0x31dab2(103) }, "REACTIVE": { "type": _0x31dab2(36) }, "REMEMBER_ME_KEY": { "type": _0x31dab2(100), "pattern": REMEMBER_ME_KEY_PATTERN, "msg": _0x31dab2(78) }, "SEARCH_ENGINE": { "type": _0x31dab2(26), "pattern": ALPHANUMERIC, "msg": _0x31dab2(90) }, "SERVER_PORT": { "type": _0x31dab2(192) }, "SERVICE_DISCOVERY_TYPE": { "type": _0x31dab2(26), "pattern": ALPHABETIC_LOWER, "msg": _0x31dab2(183) }, "SKIP_CLIENT": { "type": _0x31dab2(36) }, "SKIP_SERVER": { "type": _0x31dab2(36) }, "SKIP_USER_MANAGEMENT": { "type": _0x31dab2(36) }, "TEST_FRAMEWORKS": { "type": _0x31dab2(74), "pattern": ALPHANUMERIC, "msg": _0x31dab2(102) }, "WEBSOCKET": { "type": _0x31dab2(26), "pattern": ALPHANUMERIC_DASH, "msg": _0x31dab2(2) }, "ENABLE_GRADLE_ENTERPRISE": { "type": _0x31dab2(36) }, "GRADLE_ENTERPRISE_HOST": { "type": _0x31dab2(100), "pattern": JWT_SECRET_KEY_PATTERN, "msg": _0x31dab2(33) }, "ORM_TOOL": { "type": _0x31dab2(26), "pattern": ALPHABETIC_LOWER, "msg": _0x31dab2(145) }, "MOBILE_FRAMEWORK": { "type": _0x31dab2(26), "pattern": ALPHABETIC_LOWER, "msg": _0x31dab2(98) }, "MOBILE_THEME": { "type": _0x31dab2(26), "pattern": ALPHABETIC_LOWER, "msg": _0x31dab2(105) }, "WITH_WEBSITE": { "type": _0x31dab2(36), "msg": _0x31dab2(38) }, "BUILT_IN_SERVICES": { "type": _0x31dab2(74), "pattern": ALPHANUMERIC, "msg": _0x31dab2(22) }, "FRONT_OR_BACK": { "type": _0x31dab2(74), "pattern": ALPHABETIC, "msg": _0x31dab2(67) }, "JOB_SCHEDULER": { "type": _0x31dab2(26), "pattern": ALPHABETIC, "msg": _0x31dab2(24) }, "JAVA_VERSION": { "type": _0x31dab2(100) }, "USE_LOMBOK": { "type": _0x31dab2(36) }, "MULTI_MODULE": { "type": _0x31dab2(36) }, "USE_COMMON_TABLE": { "type": _0x31dab2(36) }, "USE_MULTI_TENANT": { "type": _0x31dab2(36) }, "SOFT_DELETE": { "type": _0x31dab2(36) }, ...application_definition_default["validatorConfig"] };
    deploymentConfigPropsValidations = { "DEPLOYMENT_TYPE": { "type": _0x31dab2(26), "pattern": ALPHABETIC_DASH_LOWER, "msg": _0x31dab2(21) }, "GATEWAY_TYPE": { "type": _0x31dab2(26), "pattern": ALPHABETIC, "msg": _0x31dab2(15) }, "MONITORING": { "type": _0x31dab2(26), "pattern": ALPHABETIC_LOWER, "msg": _0x31dab2(66) }, "DIRECTORY_PATH": { "type": _0x31dab2(100), "pattern": PATH_PATTERN, "msg": _0x31dab2(13) }, "APPS_FOLDERS": { "type": _0x31dab2(74), "pattern": ALPHANUMERIC_UNDERSCORE, "msg": _0x31dab2(182) }, "CLUSTERED_DB_APPS": { "type": _0x31dab2(74), "pattern": ALPHANUMERIC, "msg": _0x31dab2(58) }, "SERVICE_DISCOVERY_TYPE": { "type": _0x31dab2(26), "pattern": ALPHABETIC_LOWER, "msg": _0x31dab2(183) }, "DOCKER_REPOSITORY_NAME": { "type": _0x31dab2(100), "pattern": REPONAME_PATTERN, "msg": _0x31dab2(190) }, "DOCKER_PUSH_COMMAND": { "type": _0x31dab2(100), "pattern": ALPHANUMERIC_SPACE, "msg": _0x31dab2(12) }, "KUBERNETES_NAMESPACE": { "type": _0x31dab2(26), "pattern": ALPHANUMERIC_DASH, "msg": _0x31dab2(160) }, "KUBERNETES_SERVICE_TYPE": { "type": _0x31dab2(26), "pattern": ALPHABETIC, "msg": _0x31dab2(46) }, "KUBERNETES_STORAGE_CLASS_NAME": { "type": _0x31dab2(100), "pattern": KUBERNETES_STORAGE_CLASS_NAME, "msg": _0x31dab2(187) }, "KUBERNETES_USE_DYNAMIC_STORAGE": { "type": _0x31dab2(36) }, "INGRESS_DOMAIN": { "type": _0x31dab2(100), "pattern": REPONAME_PATTERN, "msg": _0x31dab2(146) }, "INGRESS_TYPE": { "type": _0x31dab2(26), "pattern": ALPHABETIC, "msg": _0x31dab2(151) }, "ISTIO": { "type": _0x31dab2(36), "msg": _0x31dab2(94) }, "OPENSHIFT_NAMESPACE": { "type": _0x31dab2(26), "pattern": ALPHANUMERIC_DASH, "msg": _0x31dab2(133) }, "REGISTRY_REPLICAS": { "type": _0x31dab2(192) }, "STORAGE_TYPE": { "type": _0x31dab2(26), "pattern": ALPHABETIC_LOWER, "msg": _0x31dab2(139) } };
    parser2 = JDLParser["getParser"]();
    parser2["parse"]();
    BaseJDLCSTVisitorWithDefaults = parser2["getBaseCstVisitorConstructorWithDefaults"]();
    JDLSyntaxValidatorVisitor = class extends BaseJDLCSTVisitorWithDefaults {
      ["errors"];
      constructor() {
        super();
        this["validateVisitor"]();
        this["errors"] = [];
      }
      ["rotisiVetadilav".split("").reverse().join("")]() {
      }
      ["checkNameSyntax"](_0x3c1276, _0x49eeb8, _0x262a87) {
        const _0x4a43dd = _0x4076;
        const _0x5cd366 = { "BWVYQ": function(_0x3e4dc5, _0x3b1cd0) {
          return _0x3e4dc5(_0x3b1cd0);
        } };
        if (!_0x49eeb8["test"](_0x3c1276["image"])) {
          this["errors"]["push"]({ "message": _0x4a43dd(39) + _0x262a87 + _0x4a43dd(8) + _0x5cd366["BWVYQ"](trimAnchors, _0x49eeb8["toString"]()) + _0x4a43dd(111) + _0x3c1276["image"] + ".", "token": _0x3c1276 });
        }
      }
      ["checkIsSingleName"](_0x1f9821) {
        const _0x45ec60 = _0x4076;
        const _0x426fdf = { "tIFTw": function(_0x334d8f, _0x285df6) {
          return _0x334d8f >= _0x285df6;
        }, "ICjLV": function(_0x2c407e, _0x7b2ec2) {
          return _0x2c407e ^ _0x7b2ec2;
        } };
        if (_0x1f9821["tokenType"] && _0x1f9821["tokenType"]["CATEGORIES"]["includes"](tokens2["BOOLEAN"])) {
          return ![];
        }
        const _0x3d56d8 = _0x1f9821["children"]["DOT"];
        if (_0x3d56d8 && _0x426fdf["tIFTw"](_0x3d56d8["length"], _0x426fdf["ICjLV"](826218, 826219))) {
          this["errors"]["push"]({ "message": _0x45ec60(189), "token": getFirstToken(_0x1f9821) });
          return ![];
        }
        return !![];
      }
      ["checkExpectedValueType"](_0x30c90c, _0x3fd905) {
        const _0x184690 = _0x4076;
        const _0x4e9712 = { "SmSQA": _0x184690(26), "bAROY": function(_0x777294, _0x511e06) {
          return _0x777294 !== _0x511e06;
        }, "fZSAl": _0x184690(141), "lhbLt": function(_0x9ca778, _0x3d4478) {
          return _0x9ca778(_0x3d4478);
        }, "jNXlT": function(_0x4fedb2, _0x4a339b) {
          return _0x4fedb2 !== _0x4a339b;
        }, "eqWgM": function(_0x17957d, _0x21857f) {
          return _0x17957d(_0x21857f);
        }, "rbhqE": _0x184690(74), "VZlhH": function(_0x1fe5e1, _0x545248) {
          return _0x1fe5e1(_0x545248);
        }, "lkaFr": _0x184690(192), "VThdk": function(_0x3d25b9, _0x5a5202) {
          return _0x3d25b9(_0x5a5202);
        }, "XRWXN": _0x184690(100), "pfhYs": function(_0x52b6db, _0x30b19e) {
          return _0x52b6db !== _0x30b19e;
        }, "ybCsd": function(_0x52447f, _0x58dd32) {
          return _0x52447f(_0x58dd32);
        }, "grwKl": _0x184690(36), "PKCXc": function(_0x5336aa, _0x31f2dd, _0x3d8367) {
          return _0x5336aa(_0x31f2dd, _0x3d8367);
        }, "TwgUG": function(_0x45a88a, _0x3000f3) {
          return _0x45a88a(_0x3000f3);
        } };
        switch (_0x30c90c) {
          case _0x4e9712["SmSQA"]:
            if (_0x4e9712["bAROY"](_0x3fd905["name"], _0x4e9712["fZSAl"]) && _0x3fd905["tokenType"] && !includes_default(_0x3fd905["tokenType"]["CATEGORIES"], tokens2["BOOLEAN"])) {
              this["errors"]["push"]({ "message": _0x184690(52) + _0x4e9712["lhbLt"](getFirstToken, _0x3fd905)["image"] + '"', "token": getFirstToken(_0x3fd905) });
              return ![];
            }
            return this["checkIsSingleName"](_0x3fd905);
          case _0x184690(141):
            if (_0x4e9712["jNXlT"](_0x3fd905["name"], _0x184690(141))) {
              this["errors"]["push"]({ "message": _0x184690(137) + _0x4e9712["eqWgM"](getFirstToken, _0x3fd905)["image"] + '"', "token": getFirstToken(_0x3fd905) });
              return ![];
            }
            return !![];
          case _0x184690(74):
            if (_0x4e9712["bAROY"](_0x3fd905["name"], _0x4e9712["rbhqE"])) {
              this["errors"]["push"]({ "message": _0x184690(20) + getFirstToken(_0x3fd905)["image"] + '"', "token": _0x4e9712["VZlhH"](getFirstToken, _0x3fd905) });
              return ![];
            }
            return !![];
          case _0x4e9712["lkaFr"]:
            if (_0x3fd905["tokenType"] !== tokens2["INTEGER"]) {
              this["errors"]["push"]({ "message": _0x184690(176) + _0x4e9712["VThdk"](getFirstToken, _0x3fd905)["image"] + '"', "token": _0x4e9712["VThdk"](getFirstToken, _0x3fd905) });
              return ![];
            }
            return !![];
          case _0x4e9712["XRWXN"]:
            if (_0x4e9712["pfhYs"](_0x3fd905["tokenType"], tokens2["STRING"])) {
              this["errors"]["push"]({ "message": _0x184690(115) + _0x4e9712["ybCsd"](getFirstToken, _0x3fd905)["image"] + '"', "token": _0x4e9712["VThdk"](getFirstToken, _0x3fd905) });
              return ![];
            }
            return !![];
          case _0x4e9712["grwKl"]:
            if (!_0x4e9712["PKCXc"](tokenMatcher, _0x3fd905, tokens2["BOOLEAN"])) {
              this["errors"]["push"]({ "message": _0x184690(156) + _0x4e9712["TwgUG"](getFirstToken, _0x3fd905)["image"] + '"', "token": _0x4e9712["eqWgM"](getFirstToken, _0x3fd905) });
              return ![];
            }
            return !![];
          default:
            throw _0x4e9712["TwgUG"](Error, _0x184690(96) + _0x30c90c + "'.");
        }
      }
      ["checkConfigPropSyntax"](_0x11b18e, _0x3427a4) {
        const _0x154b1d = _0x4076;
        const _0xc70b29 = { "saDQd": function(_0x377f51, _0x4a7dd4) {
          return _0x377f51(_0x4a7dd4);
        } };
        const _0x43f77e = _0x11b18e["tokenType"]["name"];
        const _0x3c6214 = configPropsValidations[_0x43f77e];
        if (!_0x3c6214) {
          throw _0xc70b29["saDQd"](Error, _0x154b1d(60) + _0x43f77e + "'.");
        }
        if (this["checkExpectedValueType"](_0x3c6214["type"], _0x3427a4) && _0x3c6214["pattern"] && _0x3427a4["children"] && _0x3427a4["children"]["NAME"]) {
          _0x3427a4["children"]["NAME"]["forEach"]((_0x5000ca) => this["checkNameSyntax"](_0x5000ca, _0x3c6214["pattern"], _0x3c6214["msg"]));
        }
      }
      ["checkDeploymentConfigPropSyntax"](_0x25a0b1, _0x7c4c0a) {
        const _0x2b5473 = _0x4076;
        const _0x3f48cc = { "NKxpX": function(_0x10f715, _0x29cda2) {
          return _0x10f715(_0x29cda2);
        } };
        const _0xd0ee4f = _0x25a0b1["tokenType"]["name"];
        const _0x3f74a7 = deploymentConfigPropsValidations[_0xd0ee4f];
        if (!_0x3f74a7) {
          throw _0x3f48cc["NKxpX"](Error, _0x2b5473(123) + _0xd0ee4f + "'.");
        }
        if (this["checkExpectedValueType"](_0x3f74a7["type"], _0x7c4c0a) && _0x3f74a7["pattern"] && _0x7c4c0a["children"] && _0x7c4c0a["children"]["NAME"]) {
          _0x7c4c0a["children"]["NAME"]["forEach"]((_0xe98fef) => this["checkNameSyntax"](_0xe98fef, _0x3f74a7["pattern"], _0x3f74a7["msg"]));
        } else if (_0x7c4c0a["image"] && _0x3f74a7["pattern"]) {
          this["checkNameSyntax"](_0x7c4c0a, _0x3f74a7["pattern"], _0x3f74a7["msg"]);
        }
      }
      ["constantDeclaration"](_0x76a174) {
        const _0x427939 = _0x4076;
        const _0x2de38e = { "fcDQK": function(_0x4aaa71, _0x5ae95c) {
          return _0x4aaa71 ^ _0x5ae95c;
        }, "kkFUf": _0x427939(42) };
        super["constantDeclaration"](_0x76a174);
        this["checkNameSyntax"](_0x76a174["NAME"][_0x2de38e["fcDQK"](367287, 367287)], CONSTANT_PATTERN, _0x2de38e["kkFUf"]);
      }
      ["entityDeclaration"](_0x34c81d) {
        const _0x5749d5 = _0x4076;
        const _0xfeae13 = { "ujtin": function(_0x5c3ded, _0x5d7db9) {
          return _0x5c3ded ^ _0x5d7db9;
        }, "CFUVe": _0x5749d5(14) };
        super["entityDeclaration"](_0x34c81d);
        this["checkNameSyntax"](_0x34c81d["NAME"][_0xfeae13["ujtin"](816424, 816424)], ENTITY_NAME_PATTERN, _0xfeae13["CFUVe"]);
      }
      ["fieldDeclaration"](_0x3ceb9e) {
        const _0x18ef11 = _0x4076;
        const _0x4c657d = { "vynWb": function(_0x1ce099, _0x1c6739) {
          return _0x1ce099 ^ _0x1c6739;
        }, "ayDpH": _0x18ef11(6) };
        super["fieldDeclaration"](_0x3ceb9e);
        this["checkNameSyntax"](_0x3ceb9e["NAME"][_0x4c657d["vynWb"](354296, 354296)], ALPHANUMERIC, _0x4c657d["ayDpH"]);
      }
      ["type"](_0x486fbc) {
        const _0x4b4b13 = _0x4076;
        const _0x587dd2 = { "rdUkP": function(_0x4cd41f, _0x276211) {
          return _0x4cd41f ^ _0x276211;
        }, "OVePB": _0x4b4b13(64) };
        super["type"](_0x486fbc);
        this["checkNameSyntax"](_0x486fbc["NAME"][_0x587dd2["rdUkP"](326426, 326426)], TYPE_NAME_PATTERN, _0x587dd2["OVePB"]);
      }
      ["minMaxValidation"](_0x230a82) {
        const _0x5e1ee8 = _0x4076;
        const _0x3bbf4b = { "tTAUH": function(_0x51ccf8, _0x6029fe) {
          return _0x51ccf8 ^ _0x6029fe;
        }, "OKRkg": _0x5e1ee8(42) };
        super["minMaxValidation"](_0x230a82);
        if (_0x230a82["NAME"]) {
          this["checkNameSyntax"](_0x230a82["NAME"][_0x3bbf4b["tTAUH"](935251, 935251)], CONSTANT_PATTERN, _0x3bbf4b["OKRkg"]);
        }
      }
      ["relationshipSide"](_0x17d2bf) {
        const _0x4b6f79 = _0x4076;
        const _0x12ee24 = { "EJLre": function(_0x57a772, _0x26fe7c) {
          return _0x57a772 ^ _0x26fe7c;
        }, "wwgSm": _0x4b6f79(14), "btEuT": _0x4b6f79(184), "GgkjA": function(_0x5c7f44, _0x28cc5a) {
          return _0x5c7f44 ^ _0x28cc5a;
        } };
        super["relationshipSide"](_0x17d2bf);
        this["checkNameSyntax"](_0x17d2bf["NAME"][_0x12ee24["EJLre"](301894, 301894)], ENTITY_NAME_PATTERN, _0x12ee24["wwgSm"]);
        if (Array["isArray"](_0x17d2bf["injectedField"])) {
          this["checkNameSyntax"](_0x17d2bf["injectedField"][_0x12ee24["EJLre"](859741, 859741)], ALPHANUMERIC, _0x12ee24["btEuT"]);
          if (_0x17d2bf["injectedFieldParam"]) {
            this["checkNameSyntax"](_0x17d2bf["injectedFieldParam"][_0x12ee24["GgkjA"](231881, 231881)], ALPHANUMERIC, _0x12ee24["btEuT"]);
          }
        }
      }
      ["enumDeclaration"](_0x33c488) {
        const _0x21d782 = _0x4076;
        const _0x1202bf = { "AJnMA": function(_0x4ccf59, _0x51298a) {
          return _0x4ccf59 ^ _0x51298a;
        }, "vQdtN": _0x21d782(83) };
        super["enumDeclaration"](_0x33c488);
        this["checkNameSyntax"](_0x33c488["NAME"][_0x1202bf["AJnMA"](683760, 683760)], ENUM_NAME_PATTERN, _0x1202bf["vQdtN"]);
      }
      ["enumPropList"](_0x11c837) {
        const _0x4d093b = _0x4076;
        const _0x5a47a4 = { "yNzHj": function(_0x596a1f, _0x3c002b) {
          return _0x596a1f ^ _0x3c002b;
        }, "YMyMq": _0x4d093b(68), "dabxj": _0x4d093b(65) };
        super["enumPropList"](_0x11c837);
        _0x11c837["enumProp"]["forEach"]((_0x9bf044) => {
          const _0x3a74cf = _0x9bf044["children"]["enumPropKey"][_0x5a47a4["yNzHj"](339493, 339493)];
          this["checkNameSyntax"](_0x3a74cf, ENUM_PROP_NAME_PATTERN, _0x5a47a4["YMyMq"]);
          const _0x1a8f32 = _0x9bf044["children"]["enumPropValue"];
          if (_0x1a8f32) {
            this["checkNameSyntax"](_0x1a8f32[0], ENUM_PROP_VALUE_PATTERN, _0x5a47a4["dabxj"]);
          }
        });
      }
      ["entityList"](_0x234ffa) {
        const _0x193ab2 = _0x4076;
        const _0x4c3c14 = { "oOwvE": function(_0x4e9d98, _0x304a5c) {
          return _0x4e9d98 === _0x304a5c;
        }, "BtvDr": _0x193ab2(84), "AgvyD": function(_0x332feb, _0x28e432) {
          return _0x332feb ^ _0x28e432;
        }, "ITnCP": _0x193ab2(35) };
        super["entityList"](_0x234ffa);
        if (_0x234ffa["NAME"]) {
          _0x234ffa["NAME"]["forEach"]((_0x19e1b9) => {
            const _0x3e28fe = _0x4076;
            if (_0x4c3c14["oOwvE"](_0x19e1b9["image"], _0x4c3c14["BtvDr"])) {
              return;
            }
            this["checkNameSyntax"](_0x19e1b9, ENTITY_NAME_PATTERN, _0x3e28fe(14));
          });
        }
        if (_0x234ffa["method"]) {
          this["checkNameSyntax"](_0x234ffa["method"][_0x4c3c14["AgvyD"](405992, 405992)], METHOD_NAME_PATTERN, _0x193ab2(53));
        }
        if (_0x234ffa["methodPath"]) {
          this["checkNameSyntax"](_0x234ffa["methodPath"][0], PATH_PATTERN, _0x4c3c14["ITnCP"]);
        }
      }
      ["noisulcxe".split("").reverse().join("")](_0x413dc1) {
        super["exclusion"](_0x413dc1);
        _0x413dc1["NAME"]["forEach"]((_0x1abe1f) => {
          const _0x5541ff = _0x4076;
          this["checkNameSyntax"](_0x1abe1f, ENTITY_NAME_PATTERN, _0x5541ff(14));
        });
      }
      ["filterDef"](_0xb22ccd) {
        const _0x56795b = _0x4076;
        const _0x2e4bb1 = { "MtBSn": function(_0x1215d2, _0xad5a95) {
          return _0x1215d2 === _0xad5a95;
        }, "XyiYb": _0x56795b(84) };
        if (_0xb22ccd["NAME"]) {
          _0xb22ccd["NAME"]["forEach"]((_0xafe179) => {
            const _0x377518 = _0x4076;
            if (_0x2e4bb1["MtBSn"](_0xafe179["image"], _0x2e4bb1["XyiYb"])) {
              return;
            }
            this["checkNameSyntax"](_0xafe179, ENTITY_NAME_PATTERN, _0x377518(14));
          });
        }
      }
      ["applicationConfigDeclaration"](_0x48aa1c) {
        this["visit"](_0x48aa1c["configValue"], _0x48aa1c["CONFIG_KEY"][0]);
      }
      ["configValue"](_0x29bb64, _0x1b8c6d) {
        const _0x2f7953 = { "yMPcr": function(_0x272473, _0x237f60) {
          return _0x272473(_0x237f60);
        }, "fcUUy": function(_0x43f447, _0x430c09) {
          return _0x43f447(_0x430c09);
        } };
        const _0x387e36 = _0x2f7953["yMPcr"](head_default, _0x2f7953["fcUUy"](head_default, Object["values"](_0x29bb64)));
        this["checkConfigPropSyntax"](_0x1b8c6d, _0x387e36);
      }
      ["deploymentConfigDeclaration"](_0x203813) {
        const _0x201bbc = { "UGScy": function(_0x57343f, _0x22f9e7) {
          return _0x57343f ^ _0x22f9e7;
        } };
        this["visit"](_0x203813["deploymentConfigValue"], _0x203813["DEPLOYMENT_KEY"][_0x201bbc["UGScy"](574616, 574616)]);
      }
      ["deploymentConfigValue"](_0x2d718d, _0x4c0ea5) {
        const _0x2fb7e5 = { "zcWMg": function(_0x1abb0a, _0x3e9522) {
          return _0x1abb0a(_0x3e9522);
        } };
        const _0x45a4bd = head_default(_0x2fb7e5["zcWMg"](head_default, values_default(_0x2d718d)));
        this["checkDeploymentConfigPropSyntax"](_0x4c0ea5, _0x45a4bd);
      }
    };
    checkConfigKeys(tokens2, Object["keys"](configPropsValidations));
  }
});

// node_modules/generator-begcode/dist/jdl/parsing/api.js
var api_exports = {};
__export(api_exports, {
  getCst: () => getCst,
  getSyntacticAutoCompleteSuggestions: () => getSyntacticAutoCompleteSuggestions,
  parse: () => parse
});
function parse(input, startRule = "prog") {
  const cst = getCst(input, startRule);
  const astBuilderVisitor = new JDLAstBuilderVisitor();
  return astBuilderVisitor.visit(cst);
}
function getCst(input, startRule = "prog") {
  const lexResult = JDLLexer.tokenize(input);
  if (lexResult.errors.length > 0) {
    throw Error(lexResult.errors[0].message);
  }
  parserSingleton.input = lexResult.tokens;
  const cst = parserSingleton[startRule]();
  if (parserSingleton.errors.length > 0) {
    throwParserError(parserSingleton.errors);
  }
  const extraSyntaxErrors = performAdditionalSyntaxChecks(cst);
  if (extraSyntaxErrors.length > 0) {
    throwSyntaxError(extraSyntaxErrors);
  }
  return cst;
}
function throwParserError(errors) {
  const parserError = errors[0];
  if (parserError.name === "MismatchedTokenException") {
    throwErrorAboutInvalidToken(parserError);
  }
  const errorMessage = `${parserError.name}: ${parserError.message}`;
  const { token } = parserError;
  const errorMessageLocation = token.tokenType !== EOF ? `
	at line: ${token.startLine}, column: ${token.startColumn}` : "";
  throw Error(`${errorMessage}${errorMessageLocation}`);
}
function throwErrorAboutInvalidToken(parserError) {
  const { token } = parserError;
  const errorMessageBeginning = `Found an invalid token '${token.image}'`;
  const errorMessageLocation = token.tokenType !== EOF ? `, at line: ${token.startLine} and column: ${token.startColumn}` : "";
  const errorMessageComplement = "Please make sure your JDL content does not use invalid characters, keywords or options.";
  throw Error(`${parserError.name}: ${errorMessageBeginning}${errorMessageLocation}.
	${errorMessageComplement}`);
}
function throwSyntaxError(errors) {
  throw Error(errors.map((error) => `${error.message}
	at line: ${error.token.startLine}, column: ${error.token.startColumn}`).join("\n"));
}
function getSyntacticAutoCompleteSuggestions(input, startRule = "prog") {
  const lexResult = JDLLexer.tokenize(input);
  parserSingleton.input = lexResult.tokens;
  const syntacticSuggestions = parserSingleton.computeContentAssist(startRule, lexResult.tokens);
  return uniq_default(syntacticSuggestions.map((suggestion) => suggestion.nextTokenType));
}
var parserSingleton, rules;
var init_api6 = __esm({
  "node_modules/generator-begcode/dist/jdl/parsing/api.js"() {
    init_lodash();
    init_api5();
    init_jdl_ast_builder_visitor();
    init_lexer2();
    init_jdl_parser();
    init_validator();
    init_parsing_system_checker();
    parserSingleton = JDLParser.getParser();
    parserSingleton.parse();
    rules = parserSingleton.getGAstProductions();
    checkTokens(Object.values(tokens2), Object.values(rules));
  }
});

// node_modules/generator-begcode/dist/jdl/parsing/jdl-post-parsing-tasks.js
function performJDLPostParsingTasks(parsedContent2) {
  return resolveEntityNames(parsedContent2);
}
function resolveEntityNames(parsedContent2) {
  parsedContent2.applications = resolveEntityNamesForApplications(parsedContent2);
  return parsedContent2;
}
function resolveEntityNamesForApplications(parsedContent2) {
  const entityNames2 = parsedContent2.entities.map((entity) => entity.name);
  return parsedContent2.applications.map((application) => {
    application.entities = resolveApplicationEntityNames(application, entityNames2);
    return application;
  });
}
function resolveApplicationEntityNames(application, entityNames2) {
  const { entityList, excluded } = application.entities;
  let applicationEntityNames = new Set(entityList);
  if (entityList.includes("*")) {
    applicationEntityNames = new Set(entityNames2);
  } else {
    checkEntityNamesInApplication(application.config.baseName, applicationEntityNames, entityNames2);
  }
  excluded.forEach((excludedEntityName) => {
    applicationEntityNames.delete(excludedEntityName);
  });
  return [...applicationEntityNames];
}
function checkEntityNamesInApplication(applicationName, entityNamesInApplication, entityNames2) {
  const entityNameSet = new Set(entityNames2);
  entityNamesInApplication.forEach((entityNameInApplication) => {
    if (!entityNameSet.has(entityNameInApplication)) {
      throw new Error(`The entity ${entityNameInApplication} which is declared in ${applicationName}'s entity list doesn't exist.`);
    }
  });
}
var init_jdl_post_parsing_tasks = __esm({
  "node_modules/generator-begcode/dist/jdl/parsing/jdl-post-parsing-tasks.js"() {
  }
});

// node_modules/generator-begcode/dist/jdl/utils/file-utils.js
function doesFileExist(file) {
  const statObject = getStatObject(file);
  return statObject && statObject.isFile();
}
function createFolderIfItDoesNotExist(directory) {
  if (!directory) {
    throw new Error("A directory must be passed to be created.");
  }
  const statObject = getStatObject(directory);
  if (statObject && statObject.isFile()) {
    throw new Error(`The directory to create '${directory}' is a file.`);
  }
  import_fs.default.mkdirSync(directory, { recursive: true });
}
function getStatObject(file) {
  try {
    return import_fs.default.statSync(file);
  } catch (error) {
    return false;
  }
}
var import_fs;
var init_file_utils = __esm({
  "node_modules/generator-begcode/dist/jdl/utils/file-utils.js"() {
    import_fs = __toESM(require("fs"), 1);
  }
});

// node_modules/generator-begcode/dist/jdl/readers/file-reader.js
function readFiles(iterable) {
  if (!iterable) {
    throw new Error("The passed files must not be nil.");
  }
  return iterable.map((path4) => readFile(path4));
}
function readFile(path4) {
  if (!path4) {
    throw new Error("The passed file must not be nil to be read.");
  }
  if (!doesFileExist(path4)) {
    throw new Error(`The passed file '${path4}' must exist and must not be a directory to be read.`);
  }
  return import_fs2.default.readFileSync(path4, "utf-8").toString();
}
var import_fs2;
var init_file_reader = __esm({
  "node_modules/generator-begcode/dist/jdl/readers/file-reader.js"() {
    import_fs2 = __toESM(require("fs"), 1);
    init_file_utils();
  }
});

// node_modules/generator-begcode/dist/jdl/readers/jdl-reader.js
function parseFromFiles(files) {
  checkFiles(files);
  checkAllTheFilesAreJDLFiles(files);
  return parse2(getFilesContent(files));
}
function parseFromContent(content) {
  if (!content) {
    throw new Error("A valid JDL content must be passed so as to be parsed.");
  }
  return parse2(content);
}
function checkFiles(files) {
  if (!files || files.length === 0) {
    throw new Error("The files must be passed to be parsed.");
  }
}
function getFilesContent(files) {
  return files.length === 1 ? readFile(files[0]) : aggregateFiles(files);
}
function checkAllTheFilesAreJDLFiles(files) {
  for (let i = 0; i < files.length; i++) {
    checkFileIsJDLFile(files[i]);
  }
}
function parse2(content) {
  const parsedContent2 = callApiMethod("parse", content);
  return performJDLPostParsingTasks(parsedContent2);
}
function callApiMethod(methodName, content) {
  if (!content) {
    throw new Error("File content must be passed, it is currently empty.");
  }
  try {
    const processedInput = filterJDLDirectives(removeInternalJDLComments(content));
    return api_exports[methodName](processedInput);
  } catch (error) {
    if (error instanceof SyntaxError) {
      logger_default.error(`Syntax error message:
	${error.message}`);
    }
    throw error;
  }
}
function removeInternalJDLComments(content) {
  return content.replace(/\/\/[^\n\r]*/gm, "");
}
function filterJDLDirectives(content) {
  return content.replace(/^\u0023.*/gm, "");
}
function checkFileIsJDLFile(file) {
  if (!file.endsWith(".jh") && !file.endsWith(".jdl")) {
    throw new Error(`The passed file '${file}' must end with '.jh' or '.jdl' to be valid.`);
  }
}
function aggregateFiles(files) {
  return readFiles(files).join("\n");
}
var init_jdl_reader = __esm({
  "node_modules/generator-begcode/dist/jdl/readers/jdl-reader.js"() {
    init_logger();
    init_api6();
    init_jdl_post_parsing_tasks();
    init_file_reader();
  }
});

// node_modules/generator-begcode/dist/jdl/models/jdl-enums.js
var JDLEnums;
var init_jdl_enums = __esm({
  "node_modules/generator-begcode/dist/jdl/models/jdl-enums.js"() {
    JDLEnums = class {
      enums;
      constructor() {
        this.enums = /* @__PURE__ */ new Map();
      }
      add(jdlEnum) {
        if (!jdlEnum) {
          throw new Error("Can't add a nil JDL enum to the JDL enums.");
        }
        this.enums.set(jdlEnum.name, jdlEnum);
      }
      get(enumName) {
        return this.enums.get(enumName);
      }
      has(enumName) {
        return this.enums.has(enumName);
      }
      size() {
        return this.enums.size;
      }
      forEach(passedFunction) {
        if (!passedFunction) {
          return;
        }
        this.enums.forEach((jdlEnum) => {
          passedFunction(jdlEnum);
        });
      }
      toString() {
        let string = "";
        this.enums.forEach((jdlEnum) => {
          string += `${jdlEnum.toString()}
`;
        });
        return string;
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/models/jdl-relationships.js
function relationshipTypeToString(relationships, type) {
  let relationship = `relationship ${type} {
`;
  relationships.forEach((internalRelationship) => {
    let lines = internalRelationship.toString().split("\n");
    lines = lines.slice(1, lines.length - 1);
    relationship += `${lines.join("\n")}
`;
  });
  relationship = `${relationship.slice(0, relationship.length - 1)}
}`;
  return relationship;
}
var JDLRelationships;
var init_jdl_relationships = __esm({
  "node_modules/generator-begcode/dist/jdl/models/jdl-relationships.js"() {
    init_jhipster2();
    init_relationship_types();
    JDLRelationships = class {
      relationships;
      constructor() {
        this.relationships = {
          OneToOne: /* @__PURE__ */ new Map(),
          OneToMany: /* @__PURE__ */ new Map(),
          ManyToOne: /* @__PURE__ */ new Map(),
          ManyToMany: /* @__PURE__ */ new Map()
        };
      }
      add(relationship) {
        if (!relationship) {
          throw new Error("A relationship must be passed so as to be added.");
        }
        this.relationships[relationship.type].set(relationship.getId(), relationship);
      }
      getOneToOne(relationshipId) {
        return this.get(relationship_types_default.ONE_TO_ONE, relationshipId);
      }
      getOneToMany(relationshipId) {
        return this.get(relationship_types_default.ONE_TO_MANY, relationshipId);
      }
      getManyToOne(relationshipId) {
        return this.get(relationship_types_default.MANY_TO_ONE, relationshipId);
      }
      getManyToMany(relationshipId) {
        return this.get(relationship_types_default.MANY_TO_MANY, relationshipId);
      }
      get(type, relationshipId) {
        if (!relationshipTypeExists(type)) {
          throw new Error(`A valid relationship type must be passed so as to retrieve the relationship, got '${type}'.`);
        }
        if (!relationshipId) {
          throw new Error("A relationship id must be passed so as to retrieve the relationship.");
        }
        return this.relationships[type].get(relationshipId);
      }
      oneToOneQuantity() {
        return this.relationships.OneToOne.size;
      }
      oneToManyQuantity() {
        return this.relationships.OneToMany.size;
      }
      manyToOneQuantity() {
        return this.relationships.ManyToOne.size;
      }
      manyToManyQuantity() {
        return this.relationships.ManyToMany.size;
      }
      size() {
        return this.oneToOneQuantity() + this.oneToManyQuantity() + this.manyToOneQuantity() + this.manyToManyQuantity();
      }
      forEach(passedFunction) {
        if (!passedFunction) {
          return;
        }
        this.toArray().forEach((jdlRelationship) => {
          passedFunction(jdlRelationship);
        });
      }
      toArray() {
        const relationships = [];
        Object.keys(this.relationships).forEach((type) => {
          this.relationships[type].forEach((relationship) => {
            relationships.push(relationship);
          });
        });
        return relationships;
      }
      toString() {
        if (this.size() === 0) {
          return "";
        }
        let string = "";
        Object.keys(this.relationships).forEach((type) => {
          if (this.relationships[type].size !== 0) {
            const result = relationshipTypeToString(this.relationships[type], type);
            string += `${result}
`;
          }
        });
        return string.slice(0, string.length - 1);
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/models/jdl-options.js
function addUnaryOption(options, optionToAdd) {
  const key = optionToAdd.name;
  if (!options[key]) {
    options[key] = optionToAdd;
    return;
  }
  options[key].addEntitiesFromAnotherOption(optionToAdd);
}
function addBinaryOption(options, optionToAdd) {
  const { name, value } = optionToAdd;
  if (!options[name]) {
    options[name] = {
      [value]: optionToAdd
    };
  } else if (!options[name][value]) {
    options[name][value] = optionToAdd;
  } else {
    options[name][value].addEntitiesFromAnotherOption(optionToAdd);
  }
}
var JDLOptions;
var init_jdl_options = __esm({
  "node_modules/generator-begcode/dist/jdl/models/jdl-options.js"() {
    JDLOptions = class {
      options;
      optionSize;
      constructor() {
        this.options = {};
        this.optionSize = 0;
      }
      addOption(option) {
        if (!option || !option.getType) {
          throw new Error("Can't add nil option.");
        }
        if (option.getType() === "UNARY") {
          addUnaryOption(this.options, option);
        } else {
          addBinaryOption(this.options, option);
        }
        this.optionSize++;
      }
      getOptions() {
        const options = [];
        Object.values(this.options).forEach((item) => {
          if (item.getType && item.getType() === "UNARY") {
            options.push(item);
            return;
          }
          Object.values(item).forEach((option) => options.push(option));
        });
        return options;
      }
      getOptionsForName(optionName) {
        if (!optionName) {
          return [];
        }
        return this.getOptions().filter((option) => option.name === optionName);
      }
      has(optionName) {
        if (!optionName) {
          return false;
        }
        return !!this.options[optionName] || this.getOptions().filter((option) => option.name === optionName).length !== 0;
      }
      size() {
        return this.optionSize;
      }
      forEach(passedFunction, thisArg) {
        if (!passedFunction) {
          return;
        }
        this.getOptions().forEach((jdlOption) => {
          passedFunction.call(thisArg, jdlOption);
        });
      }
      toString(indent = 0) {
        if (this.optionSize === 0) {
          return "";
        }
        const options = this.getOptions();
        const spaceBeforeEachOption = " ".repeat(indent);
        return options.map((jdlOption) => `${spaceBeforeEachOption}${jdlOption.toString()}`).join("\n");
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/models/jdl-aigcs.js
function aigcTypeToString(aigcs, type) {
  let aigc = `aigc ${type} {
`;
  aigcs.forEach((internalAigc) => {
    let lines = internalAigc.toString().split("\n");
    lines = lines.slice(1, lines.length - 1);
    aigc += `${lines.join("\n")}
`;
  });
  aigc = `${aigc.slice(0, aigc.length - 1)}
}`;
  return aigc;
}
var JDLAigcs;
var init_jdl_aigcs = __esm({
  "node_modules/generator-begcode/dist/jdl/models/jdl-aigcs.js"() {
    init_jhipster2();
    init_aigc_types();
    JDLAigcs = class {
      aigcs;
      constructor() {
        this.aigcs = {
          Method: /* @__PURE__ */ new Map(),
          Api: /* @__PURE__ */ new Map(),
          Feature: /* @__PURE__ */ new Map()
        };
      }
      add(aigc) {
        if (!aigc) {
          throw new Error("A aigc must be passed so as to be added.");
        }
        this.aigcs[aigc.type].set(aigc.getId(), aigc);
      }
      getMethod(aigcId) {
        return this.get(aigc_types_default.METHOD, aigcId);
      }
      getApi(aigcId) {
        return this.get(aigc_types_default.API, aigcId);
      }
      getFeature(aigcId) {
        return this.get(aigc_types_default.FEATURE, aigcId);
      }
      get(type, aigcId) {
        if (!aigcTypeExists(type)) {
          throw new Error(`A valid aigc type must be passed so as to retrieve the aigc, got '${type}'.`);
        }
        if (!aigcId) {
          throw new Error("A aigc id must be passed so as to retrieve the aigc.");
        }
        return this.aigcs[type].get(aigcId);
      }
      methodQuantity() {
        return this.aigcs.Method.size;
      }
      apiQuantity() {
        return this.aigcs.Api.size;
      }
      featureQuantity() {
        return this.aigcs.Feature.size;
      }
      size() {
        return this.methodQuantity() + this.apiQuantity() + this.featureQuantity();
      }
      forEach(passedFunction) {
        if (!passedFunction) {
          return;
        }
        this.toArray().forEach((aigc) => {
          passedFunction(aigc);
        });
      }
      toArray() {
        const aigcs = [];
        Object.keys(this.aigcs).forEach((type) => {
          this.aigcs[type].forEach((aigc) => {
            aigcs.push(aigc);
          });
        });
        return aigcs;
      }
      toString() {
        if (this.size() === 0) {
          return "";
        }
        let string = "";
        Object.keys(this.aigcs).forEach((type) => {
          if (this.aigcs[type].size !== 0) {
            const result = aigcTypeToString(this.aigcs[type], type);
            string += `${result}
`;
          }
        });
        return string.slice(0, string.length - 1);
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/models/jdl-object.js
function applicationsToString(applications) {
  let string = "";
  Object.keys(applications).forEach((applicationName) => {
    string += `${applications[applicationName].toString()}
`;
  });
  return string;
}
function deploymentsToString(deployments) {
  let string = "";
  Object.values(deployments).forEach((deployment) => {
    string += `${deployment.toString()}
`;
  });
  return string;
}
function entitiesToString(entities3) {
  let string = "";
  Object.keys(entities3).forEach((entityName) => {
    string += `${entities3[entityName].toString()}
`;
  });
  return string.slice(0, string.length - 1);
}
function relationshipsToString(relationships) {
  const string = relationships.toString();
  if (string === "") {
    return "";
  }
  return `${string}
`;
}
function aigcsToString(aigcs) {
  const string = aigcs.toString();
  if (string === "") {
    return "";
  }
  return `${string}
`;
}
function optionsToString(options) {
  const string = options.toString();
  if (string === "") {
    return "";
  }
  return `${string}
`;
}
var JDLObject;
var init_jdl_object = __esm({
  "node_modules/generator-begcode/dist/jdl/models/jdl-object.js"() {
    init_jdl_enums();
    init_jdl_relationships();
    init_jdl_options();
    init_jhipster2();
    init_jdl_aigcs();
    JDLObject = class {
      applications;
      deployments;
      entities;
      enums;
      relationships;
      options;
      aigcs;
      constructor() {
        this.applications = {};
        this.deployments = {};
        this.entities = {};
        this.enums = new JDLEnums();
        this.relationships = new JDLRelationships();
        this.options = new JDLOptions();
        this.aigcs = new JDLAigcs();
      }
      getOptions() {
        return this.options.getOptions();
      }
      addApplication(application) {
        if (!application) {
          throw new Error("Can't add nil application.");
        }
        const baseName = application.getConfigurationOptionValue("baseName");
        this.applications[baseName] = application;
      }
      getApplicationQuantity() {
        return Object.keys(this.applications).length;
      }
      getApplication(applicationName) {
        if (!applicationName) {
          return void 0;
        }
        return this.applications[applicationName];
      }
      getApplications() {
        return Object.values(this.applications);
      }
      forEachApplication(passedFunction) {
        if (!passedFunction) {
          return;
        }
        Object.keys(this.applications).forEach((applicationName) => {
          const application = this.applications[applicationName];
          passedFunction(application);
        });
      }
      addDeployment(deployment) {
        if (!deployment) {
          throw new Error("Can't add nil deployment.");
        }
        this.deployments[deployment.deploymentType] = deployment;
      }
      getDeploymentQuantity() {
        return Object.keys(this.deployments).length;
      }
      forEachDeployment(passedFunction) {
        if (!passedFunction) {
          return;
        }
        Object.keys(this.deployments).forEach((deploymentName, index, array) => {
          const deployment = this.deployments[deploymentName];
          passedFunction(deployment, index, array);
        });
      }
      addEntity(entity) {
        if (!entity) {
          throw new Error("Can't add nil entity.");
        }
        this.entities[entity.name] = entity;
      }
      getEntity(entityName) {
        if (!entityName) {
          throw new Error("An entity name must be passed so as to be retrieved.");
        }
        return this.entities[entityName];
      }
      getEntities() {
        return Object.values(this.entities);
      }
      getEntityQuantity() {
        return this.getEntityNames().length;
      }
      getEntityNames() {
        return Object.keys(this.entities);
      }
      forEachEntity(passedFunction) {
        if (!passedFunction) {
          return;
        }
        Object.keys(this.entities).forEach((entityName, index, array) => {
          const entity = this.entities[entityName];
          passedFunction(entity, index, array);
        });
      }
      addEnum(enumToAdd) {
        if (!enumToAdd) {
          throw new Error("Can't add nil enum.");
        }
        this.enums.add(enumToAdd);
      }
      hasEnum(enumName) {
        return this.enums.has(enumName);
      }
      getEnum(enumName) {
        return this.enums.get(enumName);
      }
      getEnumQuantity() {
        return this.enums.size();
      }
      forEachEnum(passedFunction) {
        if (!passedFunction) {
          return;
        }
        this.enums.forEach((jdlEnum) => {
          passedFunction(jdlEnum);
        });
      }
      addRelationship(relationship) {
        if (!relationship) {
          throw new Error("Can't add nil relationship.");
        }
        this.relationships.add(relationship);
      }
      addAigc(aigc) {
        if (!aigc) {
          throw new Error("Can't add nil aigc.");
        }
        this.aigcs.add(aigc);
      }
      getRelationshipQuantity(applicationName) {
        if (!applicationName) {
          return this.relationships.size();
        }
        const applicationEntityNames = this.applications[applicationName].entityNames;
        let count = 0;
        this.relationships.forEach((relationship) => {
          if (applicationEntityNames.has(relationship.from) || applicationEntityNames.has(relationship.to)) {
            count++;
          }
        });
        return count;
      }
      getAigcQuantity(applicationName) {
        if (!applicationName) {
          return this.aigcs.size();
        }
        const applicationEntityNames = this.applications[applicationName].entityNames;
        let count = 0;
        this.aigcs.forEach((aigc) => {
          if (applicationEntityNames.has(aigc.from)) {
            count++;
          }
        });
        return count;
      }
      forEachRelationship(passedFunction) {
        if (!passedFunction) {
          return;
        }
        this.relationships.forEach((jdlRelationship) => {
          passedFunction(jdlRelationship);
        });
      }
      forEachAigc(passedFunction) {
        if (!passedFunction) {
          return;
        }
        this.aigcs.forEach((aigc) => {
          passedFunction(aigc);
        });
      }
      getRelationships() {
        return this.relationships.toArray();
      }
      getAigcs() {
        return this.aigcs.toArray();
      }
      addOption(option) {
        if (!option || !option.getType) {
          throw new Error("Can't add nil option.");
        }
        this.options.addOption(option);
      }
      getOptionsForName(optionName) {
        return this.options.getOptionsForName(optionName);
      }
      forEachOption(passedFunction) {
        if (!passedFunction) {
          return;
        }
        this.options.forEach(passedFunction);
      }
      hasOption(optionName) {
        if (!optionName) {
          return false;
        }
        return this.options.has(optionName);
      }
      isEntityInMicroservice(entityName) {
        const options = this.getOptionsForName(binary_options_default.Options.MICROSERVICE);
        return options.some((option) => option.entityNames.has("*") || option.entityNames.has(entityName));
      }
      getOptionQuantity() {
        return this.options.size();
      }
      toString() {
        let string = "";
        if (this.getApplicationQuantity() !== 0) {
          string += `${applicationsToString(this.applications)}
`;
        }
        if (this.getDeploymentQuantity() !== 0) {
          string += `${deploymentsToString(this.deployments)}
`;
        }
        if (this.getEntityQuantity() !== 0) {
          string += `${entitiesToString(this.entities)}
`;
        }
        if (this.getEnumQuantity() !== 0) {
          string += `${this.enums.toString()}
`;
        }
        if (this.getRelationshipQuantity() !== 0) {
          string += `${relationshipsToString(this.relationships)}`;
        }
        if (this.getAigcQuantity() !== 0) {
          string += `${aigcsToString(this.aigcs)}`;
        }
        if (this.getOptionQuantity() !== 0) {
          string += `
${optionsToString(this.options)}`;
        }
        return string;
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/utils/set-utils.js
function addAll(set, elements) {
  if (!set) {
    throw new Error("A Set must be passed so as to insert elements.");
  }
  if (!elements || elements.length === 0) {
    return set;
  }
  elements.forEach((element) => set.add(element));
  return set;
}
function join(set, separator = ",") {
  if (!set) {
    throw new Error("A Set must be passed so as to join elements.");
  }
  return Array.from(set).join(separator);
}
var init_set_utils = __esm({
  "node_modules/generator-begcode/dist/jdl/utils/set-utils.js"() {
  }
});

// node_modules/generator-begcode/dist/jdl/models/abstract-jdl-option.js
function defaults3() {
  return {
    entityNames: /* @__PURE__ */ new Set(["*"]),
    excludedNames: /* @__PURE__ */ new Set()
  };
}
var AbstractJDLOption;
var init_abstract_jdl_option = __esm({
  "node_modules/generator-begcode/dist/jdl/models/abstract-jdl-option.js"() {
    init_object_utils();
    init_set_utils();
    AbstractJDLOption = class {
      name;
      entityNames;
      excludedNames;
      constructor(args) {
        const merged = merge(defaults3(), args);
        if (!merged.name) {
          throw new Error("The option's name must be passed to create an option.");
        }
        this.name = merged.name;
        this.entityNames = new Set(merged.entityNames);
        if (this.entityNames.size === 0) {
          this.entityNames.add("*");
        }
        this.excludedNames = new Set(merged.excludedNames);
      }
      addEntityName(entityName) {
        if (!entityName) {
          throw new Error("An entity name has to be passed so as to be added to the option.");
        }
        if (this.excludedNames.has(entityName)) {
          return false;
        }
        if (this.entityNames.has("*")) {
          this.entityNames.delete("*");
        }
        return this.entityNames.add(entityName);
      }
      addEntitiesFromAnotherOption(option) {
        if (!option) {
          return false;
        }
        addAll(this.entityNames, option.entityNames);
        addAll(this.excludedNames, option.excludedNames);
        return true;
      }
      excludeEntityName(entityName) {
        if (!entityName) {
          throw new Error("An entity name has to be passed so as to be excluded from the option.");
        }
        if (this.entityNames.has(entityName)) {
          return;
        }
        this.excludedNames.add(entityName);
      }
      getType() {
        throw new Error("Unsupported operation");
      }
      setEntityNames(newEntityNames) {
        this.entityNames = new Set(newEntityNames);
      }
      resolveEntityNames(entityNames2) {
        if (!entityNames2) {
          throw new Error("Entity names have to be passed to resolve the option's entities.");
        }
        const resolvedEntityNames = this.entityNames.has("*") ? new Set(entityNames2) : this.entityNames;
        this.excludedNames.forEach((excludedEntityName) => {
          resolvedEntityNames.delete(excludedEntityName);
        });
        return resolvedEntityNames;
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/models/jdl-binary-option.js
var JDLBinaryOption;
var init_jdl_binary_option = __esm({
  "node_modules/generator-begcode/dist/jdl/models/jdl-binary-option.js"() {
    init_abstract_jdl_option();
    init_binary_options();
    init_set_utils();
    JDLBinaryOption = class extends AbstractJDLOption {
      value;
      constructor(args) {
        super(args);
        if (args.value == null) {
          throw new Error("A binary option must have a value.");
        }
        this.value = args.value;
      }
      getType() {
        return "BINARY";
      }
      toString() {
        const entityNames2 = join(this.entityNames, ", ");
        entityNames2.slice(1, entityNames2.length - 1);
        let optionName = this.name;
        if (this.name === binary_options_default.Options.PAGINATION) {
          optionName = "paginate";
        }
        const firstPart = `${optionName} ${entityNames2} with ${this.value}`;
        if (this.excludedNames.size === 0) {
          return firstPart;
        }
        const excludedNames = join(this.excludedNames, ", ");
        excludedNames.slice(1, this.excludedNames.length - 1);
        return `${firstPart} except ${excludedNames}`;
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/models/jdl-application-configuration.js
function getFormattedConfigOptionsString(options, indent) {
  const filteredOptions = filterOutUnwantedOptions(options);
  return Object.keys(filteredOptions).sort().map((optionName) => {
    const option = options[optionName];
    return `${indent}${option}`;
  }).join("\n");
}
function filterOutUnwantedOptions(options) {
  return filterOutOptionsThatShouldNotBeExported(filterOutOptionsWithoutValues(options));
}
function filterOutOptionsWithoutValues(options) {
  const filteredOptions = { ...options };
  if (!(OptionNames5.ENTITY_SUFFIX in options) || !options[OptionNames5.ENTITY_SUFFIX].getValue()) {
    delete filteredOptions[OptionNames5.ENTITY_SUFFIX];
  }
  if (!(OptionNames5.DTO_SUFFIX in options) || !options[OptionNames5.DTO_SUFFIX].getValue()) {
    delete filteredOptions[OptionNames5.DTO_SUFFIX];
  }
  if (!(OptionNames5.CLIENT_THEME_VARIANT in options) || !options[OptionNames5.CLIENT_THEME_VARIANT].getValue()) {
    delete filteredOptions[OptionNames5.CLIENT_THEME_VARIANT];
  }
  return filteredOptions;
}
function filterOutOptionsThatShouldNotBeExported(options) {
  const filteredOptions = { ...options };
  delete filteredOptions[OptionNames5.PACKAGE_FOLDER];
  return filteredOptions;
}
var OptionNames5, JDLApplicationConfiguration;
var init_jdl_application_configuration = __esm({
  "node_modules/generator-begcode/dist/jdl/models/jdl-application-configuration.js"() {
    init_application_options2();
    ({ OptionNames: OptionNames5 } = application_options_default);
    JDLApplicationConfiguration = class {
      options;
      namespace;
      constructor(namespace) {
        this.options = {};
        this.namespace = namespace;
      }
      hasOption(optionName) {
        if (!optionName) {
          return false;
        }
        return optionName in this.options;
      }
      getOption(optionName) {
        if (!optionName) {
          throw new Error("An option name has to be passed to get the option.");
        }
        if (!(optionName in this.options)) {
          return void 0;
        }
        return this.options[optionName];
      }
      setOption(option) {
        if (!option) {
          throw new Error("An option has to be passed to set an option.");
        }
        this.options[option.name] = option;
      }
      forEachOption(passedFunction) {
        if (!passedFunction) {
          return;
        }
        Object.values(this.options).forEach((option) => {
          passedFunction(option);
        });
      }
      toString(indent = 0) {
        const spaceBeforeConfigKeyword = " ".repeat(indent);
        const namespace = this.namespace ? `:${this.namespace}` : "";
        if (Object.keys(this.options).length === 0) {
          return `${spaceBeforeConfigKeyword}config${namespace} {}`;
        }
        const spaceBeforeOption = " ".repeat(2 * indent);
        const config = getFormattedConfigOptionsString(this.options, spaceBeforeOption);
        return `${spaceBeforeConfigKeyword}config${namespace} {
${config}
${spaceBeforeConfigKeyword}}`;
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/models/jdl-application-configuration-option.js
var JDLApplicationConfigurationOption;
var init_jdl_application_configuration_option = __esm({
  "node_modules/generator-begcode/dist/jdl/models/jdl-application-configuration-option.js"() {
    JDLApplicationConfigurationOption = class {
      name;
      value;
      constructor(name, value) {
        this.name = name;
        this.value = value;
      }
      getValue() {
        return this.value;
      }
      toString() {
        return `${this.name} ${this.value}`;
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/models/string-jdl-application-configuration-option.js
var StringJDLApplicationConfigurationOption;
var init_string_jdl_application_configuration_option = __esm({
  "node_modules/generator-begcode/dist/jdl/models/string-jdl-application-configuration-option.js"() {
    init_jdl_application_configuration_option();
    StringJDLApplicationConfigurationOption = class extends JDLApplicationConfigurationOption {
      quoted;
      constructor(name, value, quoted = false) {
        super(name, value);
        this.quoted = quoted;
      }
      toString() {
        const value = this.quoted && !this.value.includes('"') ? `"${this.value}"` : this.value;
        return `${this.name} ${value}`;
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/models/integer-jdl-application-configuration-option.js
var IntegerJDLApplicationConfigurationOption;
var init_integer_jdl_application_configuration_option = __esm({
  "node_modules/generator-begcode/dist/jdl/models/integer-jdl-application-configuration-option.js"() {
    init_jdl_application_configuration_option();
    IntegerJDLApplicationConfigurationOption = class extends JDLApplicationConfigurationOption {
    };
  }
});

// node_modules/generator-begcode/dist/jdl/models/boolean-jdl-application-configuration-option.js
var BooleanJDLApplicationConfigurationOption;
var init_boolean_jdl_application_configuration_option = __esm({
  "node_modules/generator-begcode/dist/jdl/models/boolean-jdl-application-configuration-option.js"() {
    init_jdl_application_configuration_option();
    BooleanJDLApplicationConfigurationOption = class extends JDLApplicationConfigurationOption {
    };
  }
});

// node_modules/generator-begcode/dist/jdl/models/list-jdl-application-configuration-option.js
var ListJDLApplicationConfigurationOption;
var init_list_jdl_application_configuration_option = __esm({
  "node_modules/generator-begcode/dist/jdl/models/list-jdl-application-configuration-option.js"() {
    init_jdl_application_configuration_option();
    init_set_utils();
    ListJDLApplicationConfigurationOption = class extends JDLApplicationConfigurationOption {
      constructor(name, value) {
        super(name, new Set(value));
      }
      getValue() {
        return Array.from(this.value);
      }
      toString() {
        return `${this.name} [${join(this.value, ", ")}]`;
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/models/jdl-application-definition.js
var JDLApplicationDefinition;
var init_jdl_application_definition = __esm({
  "node_modules/generator-begcode/dist/jdl/models/jdl-application-definition.js"() {
    init_application_options2();
    JDLApplicationDefinition = class {
      optionValues = jhipsterOptionValues;
      optionTypes = jhipsterOptionTypes;
      quotedOptionNames = jhipsterQuotedOptionNames;
      getTypeForOption(optionName) {
        if (!optionName) {
          throw new Error("A name has to be passed to get the option type.");
        }
        if (!this.optionTypes[optionName]) {
          throw new Error(`Unrecognised application option name: ${optionName}.`);
        }
        return this.optionTypes[optionName].type;
      }
      doesOptionValueExist(name, value) {
        if (!this.doesOptionExist(name)) {
          return false;
        }
        const values2 = this.optionValues[name];
        if (typeof values2 !== "object" || Array.isArray(values2)) {
          return true;
        }
        if (Array.isArray(value)) {
          return value.every((val) => values2[val] != null);
        }
        return values2[value] != null;
      }
      doesOptionExist(optionName) {
        return !!optionName && optionName in this.optionTypes;
      }
      shouldTheValueBeQuoted(optionName) {
        if (!optionName) {
          throw new Error("An option name has to be passed to know whether it is quoted.");
        }
        return this.quotedOptionNames.includes(optionName);
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/models/jdl-application-configuration-factory.js
function createApplicationConfigurationFromObject(configurationObject = {}) {
  const configuration3 = new JDLApplicationConfiguration();
  Object.keys(configurationObject).forEach((optionName) => {
    const optionValue = configurationObject[optionName];
    if (!applicationDefinition.doesOptionExist(optionName)) {
      logger_default.debug(`Unrecognized application option name and value: '${optionName}' and '${optionValue}'.`);
      return;
    }
    configuration3.setOption(createApplicationJDLConfigurationOption(optionName, optionValue));
  });
  return configuration3;
}
function createApplicationNamespaceConfigurationFromObject(parsedNamespaceConfigs = {}) {
  return Object.entries(parsedNamespaceConfigs).map(([namespace, parsedConfig]) => {
    const configuration3 = new JDLApplicationConfiguration(namespace);
    for (const [optionName, optionValue] of Object.entries(parsedConfig)) {
      configuration3.setOption(createUnknownJDLConfigurationOption(optionName, optionValue));
    }
    return configuration3;
  });
}
function createUnknownJDLConfigurationOption(name, value) {
  let type;
  if (typeof value === "boolean") {
    type = "boolean";
  } else if (/^\d+$/.test(value)) {
    value = parseInt(value, 10);
    type = "integer";
  } else if (Array.isArray(value)) {
    type = "list";
  } else if (typeof value === "string") {
    type = "string";
  } else {
    throw new Error(`Unknown value type for option ${name}`);
  }
  return createJDLConfigurationOption(type, name, value);
}
function createApplicationJDLConfigurationOption(name, value) {
  const type = applicationDefinition.getTypeForOption(name);
  return createJDLConfigurationOption(type, name, value);
}
function createJDLConfigurationOption(type, name, value) {
  switch (type) {
    case "string":
      return new StringJDLApplicationConfigurationOption(name, value, applicationDefinition.shouldTheValueBeQuoted(name));
    case "integer":
      return new IntegerJDLApplicationConfigurationOption(name, value);
    case "boolean":
      return new BooleanJDLApplicationConfigurationOption(name, value);
    case "list":
      return new ListJDLApplicationConfigurationOption(name, value);
    default:
      throw new Error(`Unrecognized option type: ${type}.`);
  }
}
var applicationDefinition;
var init_jdl_application_configuration_factory = __esm({
  "node_modules/generator-begcode/dist/jdl/models/jdl-application-configuration-factory.js"() {
    init_logger();
    init_jdl_application_configuration();
    init_string_jdl_application_configuration_option();
    init_integer_jdl_application_configuration_option();
    init_boolean_jdl_application_configuration_option();
    init_list_jdl_application_configuration_option();
    init_jdl_application_definition();
    applicationDefinition = new JDLApplicationDefinition();
  }
});

// node_modules/generator-begcode/dist/jdl/models/jdl-application-entities.js
var JDLApplicationEntities;
var init_jdl_application_entities = __esm({
  "node_modules/generator-begcode/dist/jdl/models/jdl-application-entities.js"() {
    init_set_utils();
    JDLApplicationEntities = class {
      entityNames;
      constructor(entityNames2 = []) {
        this.entityNames = new Set(entityNames2);
      }
      add(entityName) {
        if (!entityName) {
          throw new Error("An entity name has to be passed so as to be added.");
        }
        this.entityNames.add(entityName);
      }
      addEntityNames(entityNames2 = []) {
        const filteredNames = entityNames2.filter((entityName) => !!entityName);
        this.entityNames = /* @__PURE__ */ new Set([...this.entityNames, ...filteredNames]);
      }
      has(entityName) {
        return this.entityNames.has(entityName);
      }
      forEach(passedFunction) {
        if (!passedFunction) {
          return;
        }
        this.entityNames.forEach((entityName) => {
          passedFunction(entityName);
        });
      }
      toArray() {
        return Array.from(this.entityNames);
      }
      size() {
        return this.entityNames.size;
      }
      toString(indent = 0) {
        if (this.entityNames.size === 0) {
          return "";
        }
        const spaceBefore = " ".repeat(indent);
        return `${spaceBefore}entities ${join(this.entityNames, ", ")}`;
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/models/jdl-application.js
var JDLApplication;
var init_jdl_application = __esm({
  "node_modules/generator-begcode/dist/jdl/models/jdl-application.js"() {
    init_jdl_application_configuration_factory();
    init_jdl_application_entities();
    init_jdl_options();
    JDLApplication = class {
      config;
      namespaceConfigs;
      entityNames;
      options;
      constructor({ config = {}, entityNames: entityNames2 = [], namespaceConfigs = {} } = {}) {
        this.config = createApplicationConfigurationFromObject(config);
        this.namespaceConfigs = createApplicationNamespaceConfigurationFromObject(namespaceConfigs);
        this.entityNames = new JDLApplicationEntities(entityNames2);
        this.options = new JDLOptions();
      }
      setConfigurationOption(option) {
        if (!option) {
          throw new Error("An option has to be passed to set an option.");
        }
        this.config.setOption(option);
      }
      hasConfigurationOption(optionName) {
        return this.config.hasOption(optionName);
      }
      getConfigurationOptionValue(optionName) {
        if (!optionName) {
          throw new Error("An option name has to be passed to get a value.");
        }
        if (!this.config.hasOption(optionName)) {
          return void 0;
        }
        const option = this.config.getOption(optionName);
        return option.getValue();
      }
      forEachConfigurationOption(passedFunction) {
        this.config.forEachOption(passedFunction);
      }
      forEachNamespaceConfiguration(passedFunction) {
        for (const namespaceConfig of this.namespaceConfigs) {
          passedFunction(namespaceConfig);
        }
      }
      addEntityName(entityName) {
        if (!entityName) {
          throw new Error("An entity name has to be passed so as to be added to the application.");
        }
        this.entityNames.add(entityName);
      }
      addEntityNames(entityNames2 = []) {
        this.entityNames.addEntityNames(entityNames2);
      }
      getEntityNames() {
        return this.entityNames.toArray();
      }
      hasEntityName(entityName) {
        if (!entityName) {
          return false;
        }
        return this.entityNames.has(entityName);
      }
      forEachEntityName(passedFunction) {
        this.entityNames.forEach(passedFunction);
      }
      addOption(jdlOption) {
        if (!jdlOption) {
          throw new Error("Can't add a nil option.");
        }
        this.options.addOption(jdlOption);
      }
      forEachOption(passedFunction) {
        if (!passedFunction) {
          return;
        }
        this.options.forEach(passedFunction);
      }
      getOptionQuantity() {
        return this.options.size();
      }
      toString() {
        let stringifiedApplication = `application {
${this.config.toString(2)}
${this.namespaceConfigs.map((config) => `${config.toString(2)}
`).join()}`;
        if (this.entityNames.size() !== 0) {
          stringifiedApplication += `
${this.entityNames.toString(2)}
`;
        }
        if (this.options.size() !== 0) {
          stringifiedApplication += `
${this.options.toString(2)}
`;
        }
        stringifiedApplication += "}";
        return stringifiedApplication;
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/models/jdl-application-factory.js
function createJDLApplication(config, namespaceConfigs) {
  return new JDLApplication({ config: { baseName: "begcode", ...config }, namespaceConfigs });
}
var init_jdl_application_factory = __esm({
  "node_modules/generator-begcode/dist/jdl/models/jdl-application-factory.js"() {
    init_jdl_application();
  }
});

// node_modules/generator-begcode/dist/jdl/models/jdl-unary-option.js
var JDLUnaryOption;
var init_jdl_unary_option = __esm({
  "node_modules/generator-begcode/dist/jdl/models/jdl-unary-option.js"() {
    init_abstract_jdl_option();
    init_set_utils();
    JDLUnaryOption = class extends AbstractJDLOption {
      getType() {
        return "UNARY";
      }
      toString() {
        const entityNames2 = join(this.entityNames, ", ");
        entityNames2.slice(1, entityNames2.length - 1);
        const firstPart = `${this.name} ${entityNames2}`;
        if (this.excludedNames.size === 0) {
          return firstPart;
        }
        const excludedNames = join(this.excludedNames, ", ");
        excludedNames.slice(1, this.excludedNames.length - 1);
        return `${firstPart} except ${excludedNames}`;
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/converters/parsed-jdl-to-jdl-object/option-converter.js
function convertOptions(parsedOptions, useOptions) {
  if (!parsedOptions) {
    throw new Error("Options have to be passed so as to be converted.");
  }
  const convertedUnaryOptions = convertUnaryOptions(parsedOptions);
  const convertedBinaryOptions = convertBinaryOptions(parsedOptions);
  const convertedUseOptions = convertUseOptions(useOptions);
  return [...convertedUnaryOptions, ...convertedBinaryOptions, ...convertedUseOptions];
}
function convertUnaryOptions(parsedOptions) {
  const convertedUnaryOptions = [];
  unary_options_default.forEach((unaryOptionName) => {
    const parsedUnaryOption = parsedOptions[unaryOptionName];
    if (!parsedUnaryOption || !parsedUnaryOption.list || parsedUnaryOption.list.length === 0) {
      return;
    }
    convertedUnaryOptions.push(new JDLUnaryOption({
      name: unaryOptionName,
      entityNames: parsedUnaryOption.list,
      excludedNames: parsedUnaryOption.excluded
    }));
  });
  return convertedUnaryOptions;
}
function convertBinaryOptions(parsedOptions) {
  const convertedBinaryOptions = [];
  binary_options_default.forEach((binaryOptionName) => {
    if (!parsedOptions[binaryOptionName]) {
      return;
    }
    const optionValues = Object.keys(parsedOptions[binaryOptionName]);
    optionValues.forEach((optionValue) => {
      const parsedBinaryOption = parsedOptions[binaryOptionName][optionValue];
      convertedBinaryOptions.push(new JDLBinaryOption({
        name: binaryOptionName,
        value: optionValue,
        entityNames: parsedBinaryOption.list,
        excludedNames: parsedBinaryOption.excluded
      }));
    });
  });
  return convertedBinaryOptions;
}
function convertUseOptions(useOptions) {
  const convertedUseOptions = [];
  useOptions.forEach((useValue) => {
    const { optionValues, list, excluded } = useValue;
    optionValues.forEach((optionValue) => {
      if (!OptionValues4[optionValue]) {
        return;
      }
      convertedUseOptions.push(new JDLBinaryOption({
        name: getOptionName2(OptionValues4[optionValue]),
        value: optionValue,
        entityNames: list,
        excludedNames: excluded
      }));
    });
  });
  return convertedUseOptions;
}
var OptionValues4, getOptionName2;
var init_option_converter = __esm({
  "node_modules/generator-begcode/dist/jdl/converters/parsed-jdl-to-jdl-object/option-converter.js"() {
    init_jdl_unary_option();
    init_jdl_binary_option();
    init_jhipster2();
    ({ OptionValues: OptionValues4, getOptionName: getOptionName2 } = binary_options_default);
  }
});

// node_modules/generator-begcode/dist/jdl/converters/parsed-jdl-to-jdl-object/application-converter.js
function convertApplications(parsedApplications) {
  if (!parsedApplications) {
    throw new Error("Applications have to be passed so as to be converted.");
  }
  return parsedApplications.map((parsedApplication) => {
    const jdlApplication = createJDLApplication(parsedApplication.config, parsedApplication.namespaceConfigs);
    jdlApplication.addEntityNames(parsedApplication.entities);
    const entityOptions = getEntityOptionsInApplication(parsedApplication);
    checkEntityNamesInOptions(jdlApplication.getConfigurationOptionValue(BASE_NAME3), entityOptions, parsedApplication.entities);
    entityOptions.forEach((option) => jdlApplication.addOption(option));
    return jdlApplication;
  });
}
function getEntityOptionsInApplication(parsedApplication) {
  return convertOptions(parsedApplication.options, parsedApplication.useOptions);
}
function checkEntityNamesInOptions(applicationName, entityOptions, entityNamesInApplication) {
  const entityNamesInApplicationSet = new Set(entityNamesInApplication);
  entityOptions.forEach((option) => {
    const entityNamesForTheOption = option.resolveEntityNames(entityNamesInApplication);
    entityNamesForTheOption.forEach((entityNameForTheOption) => {
      if (!entityNamesInApplicationSet.has(entityNameForTheOption)) {
        throw new Error(`The entity ${entityNameForTheOption} in the ${option.name} option isn't declared in ${applicationName}'s entity list.`);
      }
    });
  });
}
var BASE_NAME3;
var init_application_converter = __esm({
  "node_modules/generator-begcode/dist/jdl/converters/parsed-jdl-to-jdl-object/application-converter.js"() {
    init_jdl_application_factory();
    init_option_converter();
    init_application_options2();
    ({ OptionNames: { BASE_NAME: BASE_NAME3 } } = application_options_default);
  }
});

// node_modules/generator-begcode/dist/jdl/models/jdl-entity.js
function defaults4() {
  return {
    fields: {},
    annotations: {}
  };
}
function formatFieldObjects(jdlFieldObjects) {
  let string = "";
  Object.keys(jdlFieldObjects).forEach((jdlField) => {
    string += `${formatFieldObject(jdlFieldObjects[jdlField])}`;
  });
  string = `${string.slice(0, string.length - 1)}`;
  return string;
}
function formatFieldObject(jdlFieldObject) {
  let string = "";
  const lines = jdlFieldObject.toString().split("\n");
  for (let j = 0; j < lines.length; j++) {
    string += `  ${lines[j]}
`;
  }
  string = `${string.slice(0, string.length - 1)}
`;
  return string;
}
var JDLEntity;
var init_jdl_entity = __esm({
  "node_modules/generator-begcode/dist/jdl/models/jdl-entity.js"() {
    init_lodash();
    init_object_utils();
    init_jhipster2();
    JDLEntity = class {
      name;
      tableName;
      fields;
      comment;
      annotations;
      constructor(args) {
        const merged = merge(defaults4(), args);
        if (!merged.name) {
          throw new Error("The entity name is mandatory to create an entity.");
        }
        this.name = merged.name;
        this.tableName = merged.tableName;
        this.fields = merged.fields;
        this.comment = merged.comment;
        this.annotations = merged.annotations ?? {};
      }
      addFields(fields = []) {
        fields.forEach((field) => this.addField(field));
      }
      addField(field) {
        if (!field) {
          throw new Error("Can't add nil field to the JDL entity.");
        }
        this.fields[field.name] = field;
      }
      forEachField(functionToApply) {
        if (!functionToApply) {
          throw new Error("A function must be passed to iterate over fields");
        }
        Object.values(this.fields).forEach(functionToApply);
      }
      toString() {
        let stringifiedEntity = "";
        if (this.comment) {
          stringifiedEntity += `/**
${this.comment.split("\n").map((line) => ` * ${line}
`).join("")} */
`;
        }
        Object.entries(this.annotations).forEach(([key, value]) => {
          key = upperFirst_default(key);
          if (value === true) {
            stringifiedEntity += `@${key}
`;
          } else if (typeof value === "string") {
            stringifiedEntity += `@${key}("${value}")
`;
          } else {
            stringifiedEntity += `@${key}(${value})
`;
          }
        });
        stringifiedEntity += `entity ${this.name}`;
        if (this.tableName && shouldWriteEntityTableName(this.name, this.tableName)) {
          stringifiedEntity += ` (${this.tableName})`;
        }
        if (Object.keys(this.fields).length !== 0) {
          stringifiedEntity += ` {
${formatFieldObjects(this.fields)}
}`;
        }
        return stringifiedEntity;
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/models/index.js
var init_models = __esm({
  "node_modules/generator-begcode/dist/jdl/models/index.js"() {
    init_jdl_entity();
    init_jdl_enum();
  }
});

// node_modules/generator-begcode/dist/jdl/utils/format-utils.js
function formatComment(comment) {
  if (!comment) {
    return void 0;
  }
  const parts = comment.trim().split("\n");
  if (parts.length === 1 && parts[0].indexOf("*") !== 0) {
    return parts[0];
  }
  return parts.reduce((previousValue, currentValue) => {
    let delimiter = "";
    if (previousValue !== "") {
      delimiter = "\\n";
    }
    return previousValue.concat(delimiter, currentValue.trim().replace(/[*]*\s*/, ""));
  }, "");
}
var init_format_utils = __esm({
  "node_modules/generator-begcode/dist/jdl/utils/format-utils.js"() {
  }
});

// node_modules/generator-begcode/dist/jdl/converters/parsed-jdl-to-jdl-object/entity-converter.js
function convertEntities(parsedEntities, jdlFieldGetterFunction) {
  if (!parsedEntities) {
    throw new Error("Entities have to be passed so as to be converted.");
  }
  return parsedEntities.map((parsedEntity) => {
    const jdlEntity = new JDLEntity({
      name: parsedEntity.name,
      tableName: parsedEntity.tableName,
      comment: formatComment(parsedEntity.documentation),
      annotations: Object.fromEntries(parsedEntity.annotations?.map((annotation) => [
        lowerFirst_default(annotation.optionName),
        annotation.type === "UNARY" ? true : annotation.optionValue
      ]) ?? [])
    });
    const jdlFields = jdlFieldGetterFunction.call(void 0, parsedEntity);
    jdlEntity.addFields(jdlFields);
    return jdlEntity;
  });
}
var init_entity_converter = __esm({
  "node_modules/generator-begcode/dist/jdl/converters/parsed-jdl-to-jdl-object/entity-converter.js"() {
    init_lodash();
    init_models();
    init_format_utils();
  }
});

// node_modules/generator-begcode/dist/jdl/converters/parsed-jdl-to-jdl-object/enum-converter.js
function convertEnums(enumerations) {
  if (!enumerations) {
    throw new Error("Enumerations have to be passed so as to be converted.");
  }
  return enumerations.map((enumeration) => convertEnum(enumeration));
}
function convertEnum(enumeration) {
  return new JDLEnum({
    name: enumeration.name,
    values: enumeration.values,
    comment: formatComment(enumeration.documentation)
  });
}
var init_enum_converter = __esm({
  "node_modules/generator-begcode/dist/jdl/converters/parsed-jdl-to-jdl-object/enum-converter.js"() {
    init_models();
    init_format_utils();
  }
});

// node_modules/generator-begcode/dist/jdl/models/jdl-field.js
function defaults5() {
  return {
    validations: {},
    options: {}
  };
}
var JDLField;
var init_jdl_field = __esm({
  "node_modules/generator-begcode/dist/jdl/models/jdl-field.js"() {
    init_lodash();
    init_object_utils();
    JDLField = class {
      name;
      type;
      comment;
      validations;
      options;
      constructor(args) {
        const merged = merge(defaults5(), args);
        if (!merged.name || !merged.type) {
          throw new Error(`The field name and type are mandatory to create a field. name: ${merged.name}, type: ${merged.type}.`);
        }
        this.name = merged.name;
        this.type = merged.type;
        this.comment = merged.comment;
        this.validations = merged.validations;
        this.options = merged.options;
      }
      addValidation(validation) {
        if (!validation) {
          throw new Error("Can't add a nil JDL validation to the JDL field.");
        }
        this.validations[validation.name] = validation;
      }
      forEachValidation(functionToApply) {
        if (!functionToApply) {
          throw new Error("A function must be passed to iterate over validations");
        }
        Object.values(this.validations).forEach(functionToApply);
      }
      validationQuantity() {
        return Object.keys(this.validations).length;
      }
      forEachOption(functionToApply) {
        if (!functionToApply) {
          throw new Error("A function must be passed to iterate over options");
        }
        Object.entries(this.options).forEach(functionToApply);
      }
      optionQuantity() {
        return Object.keys(this.options).length;
      }
      toString() {
        let string = "";
        if (this.comment) {
          string += `/**
${this.comment.split("\n").map((line) => ` * ${line}
`).join("")} */
`;
        }
        Object.entries(this.options ?? {}).forEach(([key, value]) => {
          key = upperFirst_default(key);
          if (value === true) {
            string += `@${key}
`;
          } else if (typeof value === "string") {
            string += `@${key}("${value}")
`;
          } else {
            string += `@${key}(${value})
`;
          }
        });
        string += `${this.name} ${this.type}`;
        Object.keys(this.validations).forEach((validationName) => {
          string += ` ${this.validations[validationName].toString()}`;
        });
        return string;
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/converters/parsed-jdl-to-jdl-object/field-converter.js
function convertField(field) {
  if (!field) {
    throw new Error("A field has to be passed so as to be converted.");
  }
  const name = lowerFirst2(field.name);
  const jdlField = new JDLField({
    name,
    type: field.type
  });
  if (field.documentation) {
    jdlField.comment = formatComment(field.documentation);
  }
  return jdlField;
}
var init_field_converter = __esm({
  "node_modules/generator-begcode/dist/jdl/converters/parsed-jdl-to-jdl-object/field-converter.js"() {
    init_jdl_field();
    init_format_utils();
    init_string_utils();
  }
});

// node_modules/generator-begcode/dist/jdl/models/jdl-validation.js
function defaults6() {
  return {
    name: REQUIRED3,
    value: ""
  };
}
function formatValidationValue(name, value) {
  if (name === PATTERN4) {
    return getPatternValidationValue(value);
  }
  return value;
}
function getPatternValidationValue(value) {
  if (value instanceof RegExp) {
    return value.toString();
  }
  return `/${value}/`;
}
var REQUIRED3, PATTERN4, JDLValidation;
var init_jdl_validation = __esm({
  "node_modules/generator-begcode/dist/jdl/models/jdl-validation.js"() {
    init_object_utils();
    init_jhipster2();
    ({ Validations: { REQUIRED: REQUIRED3, PATTERN: PATTERN4 } } = validations_default);
    JDLValidation = class {
      name;
      value;
      constructor(args) {
        const merged = merge(defaults6(), args);
        this.name = merged.name;
        this.value = merged.value;
      }
      toString() {
        let string = `${this.name}`;
        if (this.value || this.value === 0) {
          string += `(${formatValidationValue(this.name, this.value)})`;
        }
        return string;
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/converters/parsed-jdl-to-jdl-object/validation-converter.js
function convertValidations(validations, constantValueGetter) {
  if (!validations) {
    throw new Error("Validations have to be passed so as to be converted.");
  }
  return validations.reduce((jdlValidations, parsedValidation) => {
    if (parsedValidation) {
      jdlValidations.push(convertValidation(parsedValidation, constantValueGetter));
    }
    return jdlValidations;
  }, []);
}
function convertValidation(validation, constantValueGetter) {
  let { value } = validation;
  if (validation.constant) {
    value = constantValueGetter.call(void 0, value);
  }
  if (validation.key === PATTERN5) {
    value = formatThePatternValidationValue(value);
  }
  return new JDLValidation({
    name: validation.key,
    value
  });
}
function formatThePatternValidationValue(value) {
  if (!value.includes("'")) {
    return value;
  }
  const chunks = value.split("'").map((chunk) => {
    if (!chunk.endsWith("\\")) {
      return `${chunk}\\`;
    }
    return chunk;
  });
  return chunks.join("\\'");
}
var PATTERN5;
var init_validation_converter = __esm({
  "node_modules/generator-begcode/dist/jdl/converters/parsed-jdl-to-jdl-object/validation-converter.js"() {
    init_jdl_validation();
    init_jhipster2();
    ({ Validations: { PATTERN: PATTERN5 } } = validations_default);
  }
});

// node_modules/generator-begcode/dist/jdl/models/jdl-relationship.js
function mergeDefaultsWithOverrides(overrides) {
  const defaultOptions = defaults7();
  const mergedOptions = {
    ...defaultOptions,
    ...overrides
  };
  mergedOptions.options.global = mergedOptions.options.global || {};
  mergedOptions.options.source = mergedOptions.options.source || {};
  mergedOptions.options.destination = mergedOptions.options.destination || {};
  return mergedOptions;
}
function defaults7() {
  return {
    side: void 0,
    injectedFieldInFrom: null,
    injectedFieldInTo: null,
    isInjectedFieldInFromRequired: false,
    isInjectedFieldInToRequired: false,
    options: {
      global: {},
      destination: {},
      source: {}
    },
    commentInFrom: "",
    commentInTo: ""
  };
}
var REQUIRED4, JDLRelationship;
var init_jdl_relationship = __esm({
  "node_modules/generator-begcode/dist/jdl/models/jdl-relationship.js"() {
    init_lodash();
    init_jhipster2();
    init_relationship_types();
    ({ REQUIRED: REQUIRED4 } = Validations);
    JDLRelationship = class {
      side;
      from;
      to;
      type;
      options;
      injectedFieldInFrom;
      injectedFieldInTo;
      isInjectedFieldInFromRequired;
      isInjectedFieldInToRequired;
      commentInFrom;
      commentInTo;
      constructor(args) {
        const merged = mergeDefaultsWithOverrides(args);
        if (!merged.from || !merged.to) {
          throw new Error("Source and destination entities must be passed to create a relationship.");
        }
        if (!relationshipTypeExists(merged.type) || !(merged.injectedFieldInFrom || merged.injectedFieldInTo)) {
          throw new Error("A valid type and at least one injected field must be passed to create a relationship.");
        }
        this.side = merged.side;
        this.from = merged.from;
        this.to = merged.to;
        this.type = merged.type;
        this.options = merged.options;
        this.injectedFieldInFrom = merged.injectedFieldInFrom;
        this.injectedFieldInTo = merged.injectedFieldInTo;
        this.isInjectedFieldInFromRequired = merged.isInjectedFieldInFromRequired;
        this.isInjectedFieldInToRequired = merged.isInjectedFieldInToRequired;
        this.commentInFrom = merged.commentInFrom;
        this.commentInTo = merged.commentInTo;
      }
      getId() {
        return `${this.type}_${this.from}${this.injectedFieldInFrom ? `{${this.injectedFieldInFrom}}` : ""}_${this.to}${this.injectedFieldInTo ? `{${this.injectedFieldInTo}}` : ""}`;
      }
      hasGlobalOption(option) {
        return option in this.options.global;
      }
      forEachGlobalOption(passedFunction) {
        Object.entries(this.options.global).forEach(([key, value]) => {
          passedFunction(key, value);
        });
      }
      forEachSourceOption(passedFunction) {
        Object.entries(this.options.source).forEach(([key, value]) => {
          passedFunction(key, value);
        });
      }
      forEachDestinationOption(passedFunction) {
        Object.entries(this.options.destination).forEach(([key, value]) => {
          passedFunction(key, value);
        });
      }
      toString() {
        let string = `relationship ${this.type} {
  `;
        if (this.commentInFrom) {
          string += `/**
${this.commentInFrom.split("\n").map((line) => `   * ${line}
`).join("")}   */
  `;
        }
        const sourceOptions = this.options.source;
        if (Object.keys(sourceOptions).length !== 0) {
          Object.keys(sourceOptions).forEach((name) => {
            const value = sourceOptions[name];
            name = upperFirst_default(name);
            string += `@${name}${value != null && value !== true ? `(${value}) ` : " "}`;
          });
        }
        string += `${this.from}`;
        if (this.injectedFieldInFrom) {
          string += `{${this.injectedFieldInFrom}${this.isInjectedFieldInFromRequired ? ` ${REQUIRED4}` : ""}}`;
        }
        string += " to";
        if (this.commentInTo) {
          string += `
  /**
${this.commentInTo.split("\n").map((line) => `   * ${line}
`).join("")}   */
  `;
        } else {
          string += " ";
        }
        const destinationOptions = this.options.destination;
        if (Object.keys(destinationOptions).length !== 0) {
          Object.keys(destinationOptions).forEach((name) => {
            const value = destinationOptions[name];
            name = upperFirst_default(name);
            string += `@${name}${value != null && value !== true ? `(${value}) ` : " "}`;
          });
        }
        string += `${this.to}`;
        if (this.injectedFieldInTo) {
          string += `{${this.injectedFieldInTo}${this.isInjectedFieldInToRequired ? ` ${REQUIRED4}` : ""}}`;
        }
        const globalOptions = this.options.global;
        if (Object.keys(globalOptions).length !== 0) {
          string += " with ";
          Object.keys(globalOptions).forEach((name) => {
            string += `${name}, `;
          });
          string = string.substring(0, string.length - 2);
        }
        string += "\n}";
        return string.replace(/ \n/g, "\n").replace(/[ ]{4}/g, "  ");
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/converters/parsed-jdl-to-jdl-object/relationship-converter.js
function convertRelationships(parsedRelationships, annotationToOptionConverter) {
  if (!parsedRelationships) {
    throw new Error("Relationships have to be passed so as to be converted.");
  }
  return parsedRelationships.map((parsedRelationship) => {
    const relationshipConfiguration = {
      from: parsedRelationship.from.name,
      to: parsedRelationship.to.name,
      type: asJdlRelationshipType(parsedRelationship.cardinality),
      injectedFieldInFrom: parsedRelationship.from.injectedField,
      injectedFieldInTo: parsedRelationship.to.injectedField,
      isInjectedFieldInFromRequired: parsedRelationship.from.required,
      isInjectedFieldInToRequired: parsedRelationship.to.required,
      commentInFrom: formatComment(parsedRelationship.from.documentation),
      commentInTo: formatComment(parsedRelationship.to.documentation),
      options: {
        global: annotationToOptionConverter.call(void 0, parsedRelationship.options.global),
        source: annotationToOptionConverter.call(void 0, parsedRelationship.options.source),
        destination: annotationToOptionConverter.call(void 0, parsedRelationship.options.destination)
      }
    };
    if (!relationshipConfiguration.injectedFieldInFrom && !relationshipConfiguration.injectedFieldInTo) {
      relationshipConfiguration.injectedFieldInFrom = lowerFirst2(relationshipConfiguration.to);
      relationshipConfiguration.injectedFieldInTo = lowerFirst2(relationshipConfiguration.from);
    }
    return new JDLRelationship(relationshipConfiguration);
  });
}
var init_relationship_converter = __esm({
  "node_modules/generator-begcode/dist/jdl/converters/parsed-jdl-to-jdl-object/relationship-converter.js"() {
    init_jdl_relationship();
    init_string_utils();
    init_format_utils();
    init_relationship_types();
  }
});

// node_modules/generator-begcode/dist/jdl/models/jdl-deployment.js
function stringifyConfig(applicationConfig2) {
  let config = "deployment {";
  Object.entries(applicationConfig2).forEach(([option, value]) => {
    if (!isEqual_default(defaults8(applicationConfig2.deploymentType)[option], value) || option === "deploymentType") {
      config = `${config}
    ${option}${stringifyOptionValue(option, value)}`;
    }
  });
  return `${config}
  }`;
}
function stringifyOptionValue(name, value) {
  if (arrayTypes.includes(name)) {
    if (value.size === 0) {
      return " []";
    }
    return ` [${join(value, ", ")}]`;
  }
  if (value === null || value === void 0) {
    return "";
  }
  return ` ${value}`;
}
function defaults8(deploymentType) {
  return deployment_options_default.Options.defaults(deploymentType);
}
var Options5, arrayTypes, NO_SERVICE_DISCOVERY4, JDLDeployment;
var init_jdl_deployment = __esm({
  "node_modules/generator-begcode/dist/jdl/models/jdl-deployment.js"() {
    init_lodash();
    init_jhipster2();
    init_object_utils();
    init_set_utils();
    ({ Options: Options5 } = deployment_options_default);
    arrayTypes = ["appsFolders", "clusteredDbApps"];
    NO_SERVICE_DISCOVERY4 = service_discovery_types_default.NO;
    JDLDeployment = class {
      constructor(args) {
        if (!args || !args.deploymentType) {
          throw new Error("The deploymentType is mandatory to create a deployment.");
        }
        const merged = merge(defaults8(args.deploymentType), args);
        Object.entries(merged).forEach(([key, option]) => {
          if (Array.isArray(option) && arrayTypes.includes(key)) {
            this[key] = new Set(option);
          } else if (key === application_options_default.OptionNames.SERVICE_DISCOVERY_TYPE && option === Options5.serviceDiscoveryType.no) {
            this[key] = NO_SERVICE_DISCOVERY4;
          } else {
            this[key] = option;
          }
        });
      }
      toString() {
        return stringifyConfig(this);
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/converters/parsed-jdl-to-jdl-object/deployment-converter.js
function convertDeployments(parsedDeployments) {
  if (!parsedDeployments) {
    throw new Error("Deployments have to be passed so as to be converted.");
  }
  return parsedDeployments.map((parsedDeployment) => new JDLDeployment(parsedDeployment));
}
var init_deployment_converter = __esm({
  "node_modules/generator-begcode/dist/jdl/converters/parsed-jdl-to-jdl-object/deployment-converter.js"() {
    init_jdl_deployment();
  }
});

// node_modules/generator-begcode/dist/jdl/models/jdl-aigc.js
function mergeDefaultsWithOverrides2(overrides) {
  const defaultOptions = defaults9();
  return {
    ...defaultOptions,
    ...overrides
  };
}
function defaults9() {
  return {
    injectedFieldInFrom: null,
    commentInFrom: ""
  };
}
var JDLAigc;
var init_jdl_aigc = __esm({
  "node_modules/generator-begcode/dist/jdl/models/jdl-aigc.js"() {
    init_aigc_types();
    JDLAigc = class {
      from;
      to;
      type;
      injectedFieldInFrom;
      commentInFrom;
      constructor(args) {
        const merged = mergeDefaultsWithOverrides2(args);
        if (!merged.from) {
          throw new Error("Source and destination entities must be passed to create a relationship.");
        }
        if (!aigcTypeExists(merged.type)) {
          throw new Error("A valid type and at least one injected field must be passed to create a relationship.");
        }
        this.from = merged.from;
        this.to = merged.to;
        this.type = merged.type;
        this.injectedFieldInFrom = merged.injectedFieldInFrom;
        this.commentInFrom = merged.commentInFrom;
      }
      getId() {
        return `${this.type}_${this.from}${this.injectedFieldInFrom ? `{${this.injectedFieldInFrom}}` : ""}_${this.to}`;
      }
      toString() {
        let string = `aigc ${this.type} {
  `;
        if (this.commentInFrom) {
          string += `/**
${this.commentInFrom.split("\n").map((line) => `   * ${line}
`).join("")}   */
  `;
        }
        string += `${this.from}`;
        if (this.injectedFieldInFrom) {
          string += `{${this.injectedFieldInFrom}}`;
        }
        string += " to";
        string += " ";
        string += `${this.to}`;
        string += "\n}";
        return string.replace(/ \n/g, "\n").replace(/[ ]{4}/g, "  ");
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/converters/parsed-jdl-to-jdl-object/aigc-converter.js
function convertAigcs(aigcs) {
  if (!aigcs) {
    throw new Error("Relationships have to be passed so as to be converted.");
  }
  return aigcs.map((aigc) => {
    const relationshipConfiguration = {
      from: aigc.from.name,
      to: aigc.to[0].image,
      type: asJdlAigcType(aigc.cardinality),
      injectedFieldInFrom: aigc.from.injectedField,
      commentInFrom: formatComment(aigc.from.documentation)
    };
    return new JDLAigc(relationshipConfiguration);
  });
}
var init_aigc_converter = __esm({
  "node_modules/generator-begcode/dist/jdl/converters/parsed-jdl-to-jdl-object/aigc-converter.js"() {
    init_jdl_aigc();
    init_format_utils();
    init_aigc_types();
  }
});

// node_modules/generator-begcode/dist/jdl/converters/parsed-jdl-to-jdl-object/parsed-jdl-to-jdl-object-converter.js
function parseFromConfigurationObject(configurationObject) {
  parsedContent = configurationObject.parsedContent || configurationObject.document;
  if (!parsedContent) {
    throw new Error("The parsed JDL content must be passed.");
  }
  init(configurationObject);
  fillApplications();
  fillDeployments();
  fillEnums();
  fillClassesAndFields();
  fillAssociations();
  fillAigcs();
  fillOptions();
  return jdlObject;
}
function init(passedConfiguration) {
  configuration = passedConfiguration;
  jdlObject = new JDLObject();
  entityNames = parsedContent.entities.map((entity) => entity.name);
  applicationsPerEntityName = {};
}
function fillApplications() {
  const jdlApplications = convertApplications(parsedContent.applications, configuration, entityNames);
  jdlApplications.forEach((jdlApplication) => {
    jdlObject.addApplication(jdlApplication);
    fillApplicationsPerEntityName(jdlApplication);
  });
}
function fillApplicationsPerEntityName(application) {
  application.forEachEntityName((entityName) => {
    applicationsPerEntityName[entityName] = applicationsPerEntityName[entityName] || [];
    applicationsPerEntityName[entityName].push(application);
  });
}
function fillDeployments() {
  const jdlDeployments = convertDeployments(parsedContent.deployments);
  jdlDeployments.forEach((jdlDeployment) => {
    jdlObject.addDeployment(jdlDeployment);
  });
}
function fillEnums() {
  const jdlEnums = convertEnums(parsedContent.enums);
  jdlEnums.forEach((jdlEnum) => {
    jdlObject.addEnum(jdlEnum);
  });
}
function fillClassesAndFields() {
  const jdlEntities = convertEntities(parsedContent.entities, getJDLFieldsFromParsedEntity);
  jdlEntities.forEach((jdlEntity) => {
    jdlObject.addEntity(jdlEntity);
  });
}
function getJDLFieldsFromParsedEntity(entity) {
  const fields = [];
  for (let i = 0; i < entity.body.length; i++) {
    const field = entity.body[i];
    const jdlField = convertField(field);
    jdlField.validations = getValidations(field);
    jdlField.options = convertAnnotationsToOptions(field.annotations);
    fields.push(jdlField);
  }
  return fields;
}
function getValidations(field) {
  return convertValidations(field.validations, getConstantValueFromConstantName).reduce((jdlValidations, jdlValidation) => {
    jdlValidations[jdlValidation.name] = jdlValidation;
    return jdlValidations;
  }, {});
}
function getConstantValueFromConstantName(constantName) {
  return parsedContent.constants[constantName];
}
function fillAssociations() {
  const jdlRelationships = convertRelationships(parsedContent.relationships, convertAnnotationsToOptions);
  jdlRelationships.forEach((jdlRelationship) => {
    jdlObject.addRelationship(jdlRelationship);
  });
}
function fillAigcs() {
  const jdlAigcs = convertAigcs(parsedContent.aigcs);
  jdlAigcs.forEach((jdlAigc) => {
    jdlObject.addAigc(jdlAigc);
  });
}
function convertAnnotationsToOptions(annotations) {
  const result = {};
  annotations.forEach((annotation) => {
    const annotationName = lowerFirst_default(annotation.optionName);
    const value = annotation.optionValue ? annotation.optionValue : true;
    if (annotationName in result) {
      const previousValue = result[annotationName];
      if (Array.isArray(previousValue)) {
        if (!previousValue.includes(value)) {
          previousValue.push(value);
        }
      } else if (value !== previousValue) {
        result[annotationName] = [previousValue, value];
      }
    } else {
      result[annotationName] = value;
    }
  });
  return result;
}
function fillOptions() {
  if (configuration.applicationType === application_types_default.MICROSERVICE && !parsedContent.options.microservice) {
    globallyAddMicroserviceOption(configuration.applicationName);
  }
  fillUnaryAndBinaryOptions();
}
function globallyAddMicroserviceOption(applicationName) {
  jdlObject.addOption(new JDLBinaryOption({
    name: binary_options_default.Options.MICROSERVICE,
    value: applicationName,
    entityNames
  }));
}
function fillUnaryAndBinaryOptions() {
  if (configuration.applicationType === application_types_default.MICROSERVICE) {
    jdlObject.addOption(new JDLBinaryOption({
      name: binary_options_default.Options.CLIENT_ROOT_FOLDER,
      value: configuration.applicationName,
      entityNames
    }));
  }
  const convertedOptions = convertOptions(parsedContent.options, parsedContent.useOptions);
  convertedOptions.forEach((convertedOption) => {
    jdlObject.addOption(convertedOption);
  });
}
var parsedContent, configuration, jdlObject, entityNames, applicationsPerEntityName, parsed_jdl_to_jdl_object_converter_default;
var init_parsed_jdl_to_jdl_object_converter = __esm({
  "node_modules/generator-begcode/dist/jdl/converters/parsed-jdl-to-jdl-object/parsed-jdl-to-jdl-object-converter.js"() {
    init_lodash();
    init_jdl_object();
    init_jdl_binary_option();
    init_jhipster2();
    init_application_converter();
    init_entity_converter();
    init_enum_converter();
    init_field_converter();
    init_validation_converter();
    init_option_converter();
    init_relationship_converter();
    init_deployment_converter();
    init_aigc_converter();
    parsed_jdl_to_jdl_object_converter_default = {
      parseFromConfigurationObject
    };
  }
});

// node_modules/generator-begcode/dist/jdl/readers/json-file-reader.js
function readJSONFile(filePath) {
  return JSON.parse(readFile(filePath));
}
function toFilePath(entityName) {
  if (!entityName) {
    throw new Error("The passed entity name must not be nil to be converted to file path.");
  }
  return import_path.default.join(".jhipster", `${upperFirst2(entityName)}.json`);
}
var import_path;
var init_json_file_reader = __esm({
  "node_modules/generator-begcode/dist/jdl/readers/json-file-reader.js"() {
    import_path = __toESM(require("path"), 1);
    init_string_utils();
    init_file_reader();
  }
});

// node_modules/generator-begcode/dist/jdl/converters/jdl-to-json/jdl-to-json-basic-entity-converter.js
function convert(jdlEntities) {
  if (!jdlEntities) {
    throw new Error("JDL entities must be passed to get the basic entity information.");
  }
  return createJSONEntities(jdlEntities);
}
function createJSONEntities(jdlEntities) {
  const convertedEntities = /* @__PURE__ */ new Map();
  jdlEntities.forEach((jdlEntity) => {
    const entityName = jdlEntity.name;
    convertedEntities.set(entityName, new json_entity_default({
      entityName,
      entityTableName: jdlEntity.tableName ?? getTableNameFromEntityNameFallback(entityName),
      documentation: formatComment(jdlEntity.comment),
      annotations: jdlEntity.annotations
    }));
  });
  return convertedEntities;
}
var jdl_to_json_basic_entity_converter_default;
var init_jdl_to_json_basic_entity_converter = __esm({
  "node_modules/generator-begcode/dist/jdl/converters/jdl-to-json/jdl-to-json-basic-entity-converter.js"() {
    init_json_entity();
    init_format_utils();
    init_entity_table_name_creator();
    jdl_to_json_basic_entity_converter_default = {
      convert
    };
  }
});

// node_modules/generator-begcode/dist/jdl/converters/jdl-to-json/jdl-to-json-field-converter.js
function convert2(jdlObject4) {
  if (!jdlObject4) {
    throw new Error("A JDL Object must be passed to convert JDL fields to JSON.");
  }
  const convertedFields = /* @__PURE__ */ new Map();
  jdlObject4.forEachEntity((jdlEntity) => {
    const convertedEntityFields = getConvertedFieldsForEntity(jdlEntity, jdlObject4);
    convertedFields.set(jdlEntity.name, convertedEntityFields);
  });
  return convertedFields;
}
function getConvertedFieldsForEntity(jdlEntity, jdlObject4) {
  const convertedEntityFields = [];
  jdlEntity.forEachField((jdlField) => {
    let fieldData = {
      fieldName: camelCase2(jdlField.name),
      fieldType: jdlField.type
    };
    const comment = formatComment(jdlField.comment);
    if (comment) {
      fieldData.documentation = comment;
    }
    if (jdlObject4.hasEnum(jdlField.type)) {
      fieldData.fieldValues = jdlObject4.getEnum(fieldData.fieldType).getValuesAsString();
      const fieldTypeComment = jdlObject4.getEnum(fieldData.fieldType).comment;
      if (fieldTypeComment) {
        fieldData.fieldTypeDocumentation = fieldTypeComment;
      }
      const fieldValuesJavadocs = jdlObject4.getEnum(fieldData.fieldType).getValueJavadocs();
      if (fieldValuesJavadocs && Object.keys(fieldValuesJavadocs).length > 0) {
        fieldData.fieldValuesJavadocs = fieldValuesJavadocs;
      }
    }
    if (fieldData.fieldType && isBlobType2(fieldData.fieldType)) {
      const blobFieldData = getBlobFieldData(fieldData.fieldType);
      fieldData = {
        ...fieldData,
        ...blobFieldData
      };
    }
    if (jdlField.validationQuantity() !== 0) {
      const fieldValidations = getFieldValidations(jdlField);
      fieldData = {
        ...fieldData,
        ...fieldValidations
      };
    }
    if (jdlField.optionQuantity() !== 0) {
      const fieldOptions = getOptionsForField(jdlField);
      fieldData = {
        ...fieldData,
        ...fieldOptions
      };
    }
    convertedEntityFields.push(fieldData);
  });
  return convertedEntityFields;
}
function getBlobFieldData(fieldType) {
  const blobFieldData = {
    fieldType: BYTES
  };
  switch (fieldType) {
    case IMAGE_BLOB:
      blobFieldData.fieldTypeBlobContent = IMAGE;
      break;
    case BLOB:
    case ANY_BLOB:
      blobFieldData.fieldTypeBlobContent = ANY;
      break;
    case TEXT_BLOB:
      blobFieldData.fieldTypeBlobContent = TEXT;
      break;
    default:
      throw new Error(`Unrecognised Blob type: ${fieldType}.`);
  }
  return blobFieldData;
}
function getFieldValidations(jdlField) {
  const fieldValidations = {
    fieldValidateRules: []
  };
  jdlField.forEachValidation((validation) => {
    fieldValidations.fieldValidateRules.push(validation.name);
    if (validation.name !== REQUIRED5 && validation.name !== UNIQUE3) {
      fieldValidations[`fieldValidateRules${capitalize_default(validation.name)}`] = validation.value;
    }
  });
  return fieldValidations;
}
function getOptionsForField(jdlField) {
  const fieldOptions = {
    options: {}
  };
  fieldOptions.options = {};
  jdlField.forEachOption(([key, value]) => {
    fieldOptions.options[key] = value;
  });
  return fieldOptions;
}
var UNIQUE3, REQUIRED5, isBlobType2, ANY_BLOB, BLOB, IMAGE_BLOB, TEXT_BLOB, ANY, IMAGE, TEXT, BYTES, jdl_to_json_field_converter_default;
var init_jdl_to_json_field_converter = __esm({
  "node_modules/generator-begcode/dist/jdl/converters/jdl-to-json/jdl-to-json-field-converter.js"() {
    init_lodash();
    init_jhipster2();
    init_format_utils();
    init_string_utils();
    init_field_types();
    ({ Validations: { UNIQUE: UNIQUE3, REQUIRED: REQUIRED5 } } = validations_default);
    ({ isBlobType: isBlobType2 } = field_types_default);
    ({ ANY_BLOB, BLOB, IMAGE_BLOB, TEXT_BLOB } = field_types_default.CommonDBTypes);
    ({ ANY, IMAGE, TEXT } = field_types_default.BlobTypes);
    ({ BYTES } = field_types_default.RelationalOnlyDBTypes);
    jdl_to_json_field_converter_default = { convert: convert2 };
  }
});

// node_modules/generator-begcode/dist/jdl/converters/jdl-to-json/jdl-to-json-relationship-converter.js
function convert3(jdlRelationships = [], entityNames2 = []) {
  if (jdlRelationships.length === 0 || entityNames2.length === 0) {
    return /* @__PURE__ */ new Map();
  }
  convertedRelationships = new Map(entityNames2.map((entityName) => [entityName, []]));
  const relatedRelationships = getRelatedRelationships(jdlRelationships, entityNames2);
  relatedRelationships.forEach((relatedRelationship, currentEntityName) => {
    setRelationshipsFromEntity(relatedRelationship, currentEntityName);
    setRelationshipsToEntity(relatedRelationship, currentEntityName);
  });
  return convertedRelationships;
}
function getRelatedRelationships(relationships, entityNames2) {
  const relatedRelationships = /* @__PURE__ */ new Map();
  entityNames2.forEach((entityName) => {
    const relationshipsRelatedToEntity = {
      from: [],
      to: []
    };
    relationships.forEach((jdlRelationship) => {
      if (jdlRelationship.from === entityName) {
        relationshipsRelatedToEntity.from.push(jdlRelationship);
      }
      if (jdlRelationship.to === entityName && (jdlRelationship.injectedFieldInTo || Object.keys(jdlRelationship.options.source).length !== 0)) {
        relationshipsRelatedToEntity.to.push(jdlRelationship);
      }
    });
    relatedRelationships.set(entityName, relationshipsRelatedToEntity);
  });
  return relatedRelationships;
}
function setRelationshipsFromEntity(relatedRelationships, entityName) {
  relatedRelationships.from.forEach((relationshipToConvert) => {
    const otherSplitField = extractField(relationshipToConvert.injectedFieldInTo);
    const convertedRelationship = {
      relationshipSide: "left",
      relationshipType: kebabCase_default(relationshipToConvert.type),
      otherEntityName: camelCase2(relationshipToConvert.to)
    };
    if (otherSplitField.relationshipName) {
      convertedRelationship.otherEntityRelationshipName = lowerFirst2(otherSplitField.relationshipName);
    }
    if (relationshipToConvert.isInjectedFieldInFromRequired) {
      convertedRelationship.relationshipValidateRules = REQUIRED6;
    }
    if (relationshipToConvert.commentInFrom) {
      convertedRelationship.documentation = relationshipToConvert.commentInFrom;
    }
    const options = {};
    if (relationshipToConvert.options && relationshipToConvert.options.source && Object.keys(relationshipToConvert.options.source).length > 0) {
      options.source = relationshipToConvert.options.source;
    }
    if (relationshipToConvert.options && relationshipToConvert.options.global && Object.keys(relationshipToConvert.options.global).length > 0) {
      options.global = relationshipToConvert.options.global;
    }
    if (relationshipToConvert.options && relationshipToConvert.options.destination && Object.keys(relationshipToConvert.options.destination).length > 0) {
      options.destination = relationshipToConvert.options.destination;
    }
    if (Object.keys(options).length > 0) {
      convertedRelationship.options = options;
    }
    const splitField = extractField(relationshipToConvert.injectedFieldInFrom);
    convertedRelationship.relationshipName = camelCase2(splitField.relationshipName || relationshipToConvert.to);
    if (splitField.otherEntityField) {
      convertedRelationship.otherEntityField = lowerFirst2(splitField.otherEntityField);
    }
    setOptionsForRelationshipSourceSide(relationshipToConvert, convertedRelationship);
    const convertedEntityRelationships = convertedRelationships.get(entityName);
    convertedEntityRelationships.push(convertedRelationship);
  });
}
function setRelationshipsToEntity(relatedRelationships, entityName) {
  relatedRelationships.to.forEach((relationshipToConvert) => {
    const otherSplitField = extractField(relationshipToConvert.injectedFieldInFrom);
    const convertedRelationship = {
      relationshipSide: "right",
      relationshipType: otherRelationshipType(kebabCase_default(relationshipToConvert.type)),
      otherEntityName: camelCase2(relationshipToConvert.from)
    };
    if (otherSplitField.relationshipName) {
      convertedRelationship.otherEntityRelationshipName = lowerFirst2(otherSplitField.relationshipName) || camelCase2(relationshipToConvert.to);
    }
    if (relationshipToConvert.isInjectedFieldInToRequired) {
      convertedRelationship.relationshipValidateRules = REQUIRED6;
    }
    if (relationshipToConvert.commentInTo) {
      convertedRelationship.documentation = relationshipToConvert.commentInTo;
    }
    const options = {};
    if (relationshipToConvert.options && relationshipToConvert.options.source && Object.keys(relationshipToConvert.options.source).length > 0) {
      options.source = relationshipToConvert.options.source;
    }
    if (relationshipToConvert.options && relationshipToConvert.options.global && Object.keys(relationshipToConvert.options.global).length > 0) {
      options.global = relationshipToConvert.options.global;
    }
    if (relationshipToConvert.options && relationshipToConvert.options.destination && Object.keys(relationshipToConvert.options.destination).length > 0) {
      options.destination = relationshipToConvert.options.destination;
    }
    if (Object.keys(options).length > 0) {
      convertedRelationship.options = options;
    }
    const splitField = extractField(relationshipToConvert.injectedFieldInTo);
    convertedRelationship.relationshipName = camelCase2(splitField.relationshipName || relationshipToConvert.from);
    if (splitField.otherEntityField) {
      convertedRelationship.otherEntityField = lowerFirst2(splitField.otherEntityField);
    }
    relationshipToConvert.injectedFieldInTo = relationshipToConvert.injectedFieldInTo ?? lowerFirst2(relationshipToConvert.from);
    setOptionsForRelationshipDestinationSide(relationshipToConvert, convertedRelationship);
    const convertedEntityRelationships = convertedRelationships.get(entityName);
    convertedEntityRelationships.push(convertedRelationship);
  });
}
function setOptionsForRelationshipSourceSide(relationshipToConvert, convertedRelationship) {
  convertedRelationship.options = convertedRelationship.options || {};
  relationshipToConvert.forEachGlobalOption((optionName, optionValue) => {
    if (optionName === BUILT_IN_ENTITY3) {
      convertedRelationship.relationshipWithBuiltInEntity = optionValue;
    } else {
      convertedRelationship.options[optionName] = optionValue;
    }
  });
  relationshipToConvert.forEachDestinationOption((optionName, optionValue) => {
    convertedRelationship.options[optionName] = optionValue;
  });
  if (Object.keys(convertedRelationship.options).length === 0) {
    delete convertedRelationship.options;
  }
}
function setOptionsForRelationshipDestinationSide(relationshipToConvert, convertedRelationship) {
  convertedRelationship.options = convertedRelationship.options || {};
  relationshipToConvert.forEachGlobalOption((optionName, optionValue) => {
    convertedRelationship.options[optionName] = optionValue;
  });
  relationshipToConvert.forEachSourceOption((optionName, optionValue) => {
    convertedRelationship.options[optionName] = optionValue;
  });
  if (Object.keys(convertedRelationship.options).length === 0) {
    delete convertedRelationship.options;
  }
}
function extractField(field) {
  const splitField = {
    relationshipName: ""
  };
  if (field) {
    const chunks = field.replace("(", "/").replace(")", "").split("/");
    splitField.relationshipName = chunks[0];
    if (chunks.length > 1) {
      splitField.otherEntityField = chunks[1];
    }
  }
  return splitField;
}
var REQUIRED6, BUILT_IN_ENTITY3, convertedRelationships, jdl_to_json_relationship_converter_default, otherRelationshipType;
var init_jdl_to_json_relationship_converter = __esm({
  "node_modules/generator-begcode/dist/jdl/converters/jdl-to-json/jdl-to-json-relationship-converter.js"() {
    init_lodash();
    init_jhipster2();
    init_string_utils();
    ({ Validations: { REQUIRED: REQUIRED6 } } = validations_default);
    ({ BUILT_IN_ENTITY: BUILT_IN_ENTITY3 } = relationship_options_default);
    jdl_to_json_relationship_converter_default = { convert: convert3 };
    otherRelationshipType = (relationshipType) => relationshipType.split("-").reverse().join("-");
  }
});

// node_modules/generator-begcode/dist/jdl/converters/jdl-to-json/jdl-to-json-option-converter.js
function convert4(jdlOptionHolder) {
  if (!jdlOptionHolder) {
    throw new Error("A JDL object or application must be passed to convert JDL options to JSON.");
  }
  convertedOptionContent = /* @__PURE__ */ new Map();
  resolveEntityNamesForEachOption(jdlOptionHolder);
  setConvertedOptionContents(jdlOptionHolder);
  return convertedOptionContent;
}
function resolveEntityNamesForEachOption(jdlOptionHolder) {
  jdlOptionHolder.forEachOption((jdlOption) => {
    if (jdlOption.entityNames.has("*")) {
      jdlOption.setEntityNames(jdlOptionHolder.getEntityNames().filter((entityName) => !jdlOption.excludedNames.has(entityName)));
    }
  });
}
function setConvertedOptionContents(jdlOptionHolder) {
  jdlOptionHolder.forEachOption((jdlOption) => {
    setOptionsToEachEntityName(jdlOption);
  });
}
function setOptionsToEachEntityName(jdlOption) {
  const { key, value } = getJSONOptionKeyAndValue(jdlOption);
  jdlOption.entityNames.forEach((entityName) => {
    setOptionToEntityName({ optionName: key, optionValue: value }, entityName);
  });
  jdlOption.entityNames.forEach((entityName) => {
    const serviceOptionValue = convertedOptionContent.get(entityName).service;
    if ((!serviceOptionValue || serviceOptionValue === NO_SERVICE2) && [DTO, FILTER].includes(jdlOption.name)) {
      logger_default.info(`The ${jdlOption.name} option is set for ${entityName}, the '${serviceClassOptionValue}' value for the 'service' is gonna be set for this entity if no other value has been set.`);
      setOptionToEntityName({ optionName: "service", optionValue: serviceClassOptionValue }, entityName);
    }
  });
  if (jdlOption.name === SEARCH) {
    preventEntitiesFromBeingSearched(jdlOption.excludedNames);
  }
}
function getJSONOptionKeyAndValue(jdlOption) {
  switch (jdlOption.name) {
    case SKIP_CLIENT3:
    case SKIP_SERVER2:
    case READ_ONLY:
    case EMBEDDED:
      return { key: jdlOption.name, value: true };
    case MICROSERVICE3:
      return { key: "microserviceName", value: jdlOption.value };
    case NO_FLUENT_METHOD:
      return { key: "fluentMethods", value: false };
    case ANGULAR_SUFFIX:
      return { key: "angularJSSuffix", value: jdlOption.value };
    case SEARCH:
      return { key: "searchEngine", value: jdlOption.value };
    case FILTER:
      return { key: "jpaMetamodelFiltering", value: true };
    default:
      return { key: jdlOption.name, value: jdlOption.getType() === "UNARY" ? true : jdlOption.value };
  }
}
function preventEntitiesFromBeingSearched(entityNames2) {
  entityNames2.forEach((entityName) => {
    setOptionToEntityName({ optionName: "searchEngine", optionValue: NO_SEARCH_ENGINE2 }, entityName);
  });
}
function setOptionToEntityName(option, entityName) {
  const { optionName, optionValue } = option;
  const optionContentForEntity = convertedOptionContent.get(entityName) ?? {};
  optionContentForEntity[optionName] = optionValue;
  convertedOptionContent.set(entityName, optionContentForEntity);
}
var FILTER, NO_FLUENT_METHOD, READ_ONLY, EMBEDDED, SKIP_CLIENT3, SKIP_SERVER2, ServiceTypes4, NO_SEARCH_ENGINE2, NO_SERVICE2, ANGULAR_SUFFIX, MICROSERVICE3, SEARCH, DTO, serviceClassOptionValue, convertedOptionContent, jdl_to_json_option_converter_default;
var init_jdl_to_json_option_converter = __esm({
  "node_modules/generator-begcode/dist/jdl/converters/jdl-to-json/jdl-to-json-option-converter.js"() {
    init_logger();
    init_jhipster2();
    ({ FILTER, NO_FLUENT_METHOD, READ_ONLY, EMBEDDED, SKIP_CLIENT: SKIP_CLIENT3, SKIP_SERVER: SKIP_SERVER2 } = unary_options_default);
    ({ ServiceTypes: ServiceTypes4 } = entity_options_default);
    ({ NO: NO_SEARCH_ENGINE2 } = search_engine_types_default);
    NO_SERVICE2 = ServiceTypes4.NO;
    ({ Options: { ANGULAR_SUFFIX, MICROSERVICE: MICROSERVICE3, SEARCH, DTO } } = binary_options_default);
    serviceClassOptionValue = binary_options_default.Values.service.SERVICE_CLASS;
    jdl_to_json_option_converter_default = { convert: convert4 };
  }
});

// node_modules/generator-begcode/dist/jdl/converters/jdl-to-json/jdl-to-json-aigc-converter.js
function convert5(jdlAigcs = [], entityNames2 = []) {
  if (jdlAigcs.length === 0 || entityNames2.length === 0) {
    return /* @__PURE__ */ new Map();
  }
  convertedAigcs = new Map(entityNames2.map((entityName) => [entityName, []]));
  const relatedAigcs = getRelatedAigcs(jdlAigcs, entityNames2);
  relatedAigcs.forEach((relatedAigc, currentEntityName) => {
    setRelationshipsFromEntity2(relatedAigc, currentEntityName);
  });
  return convertedAigcs;
}
function getRelatedAigcs(jdlAigcs, entityNames2) {
  const relatedAigcs = /* @__PURE__ */ new Map();
  entityNames2.forEach((entityName) => {
    const aigcsRelatedToEntity = {
      from: [],
      to: []
    };
    jdlAigcs.forEach((jdlAigc) => {
      if (jdlAigc.from === entityName) {
        aigcsRelatedToEntity.from.push(jdlAigc);
      }
    });
    relatedAigcs.set(entityName, aigcsRelatedToEntity);
  });
  return relatedAigcs;
}
function setRelationshipsFromEntity2(relatedAigcs, entityName) {
  relatedAigcs.from.forEach((aigcToConvert) => {
    const convertedAigc = {
      aigcType: kebabCase_default(aigcToConvert.type),
      targetType: aigcToConvert.to
    };
    if (aigcToConvert.commentInFrom) {
      convertedAigc.documentation = aigcToConvert.commentInFrom;
    }
    const splitField = extractField2(aigcToConvert.injectedFieldInFrom);
    if (splitField.aigcName) {
      convertedAigc.aigcName = splitField.aigcName;
    }
    const convertedEntityRelationships = convertedAigcs.get(entityName);
    convertedEntityRelationships.push(convertedAigc);
  });
}
function extractField2(field) {
  const splitField = {
    aigcName: ""
  };
  if (field) {
    const chunks = field.replace("(", "/").replace(")", "").split("/");
    splitField.aigcName = chunks[0];
  }
  return splitField;
}
var REQUIRED7, BUILT_IN_ENTITY4, convertedAigcs, jdl_to_json_aigc_converter_default;
var init_jdl_to_json_aigc_converter = __esm({
  "node_modules/generator-begcode/dist/jdl/converters/jdl-to-json/jdl-to-json-aigc-converter.js"() {
    init_lodash();
    init_jhipster2();
    init_string_utils();
    ({ Validations: { REQUIRED: REQUIRED7 } } = validations_default);
    ({ BUILT_IN_ENTITY: BUILT_IN_ENTITY4 } = relationship_options_default);
    jdl_to_json_aigc_converter_default = { convert: convert5 };
  }
});

// node_modules/generator-begcode/dist/jdl/converters/jdl-to-json/jdl-without-application-to-json-converter.js
function convert6(args = {}) {
  if (!args.jdlObject || !args.applicationName || !args.databaseType) {
    throw new Error("The JDL object, the application's name, and its the database type are mandatory.");
  }
  init2(args);
  setBasicEntityInformation();
  setOptions();
  setFields();
  setRelationships();
  setAigcs();
  setApplicationToEntities();
  return /* @__PURE__ */ new Map([[args.applicationName, Object.values(entities)]]);
}
function init2(args) {
  if (jdlObject2) {
    resetState();
  }
  jdlObject2 = args.jdlObject;
  entities = {};
}
function resetState() {
  jdlObject2 = null;
  entities = null;
}
function setBasicEntityInformation() {
  const convertedEntities = jdl_to_json_basic_entity_converter_default.convert(jdlObject2.getEntities());
  convertedEntities.forEach((jsonEntity, entityName) => {
    entities[entityName] = jsonEntity;
  });
}
function setOptions() {
  const convertedOptionContents = jdl_to_json_option_converter_default.convert(jdlObject2);
  convertedOptionContents.forEach((optionContent, entityName) => {
    if (!entities[entityName]) {
      console.log("---entityName-notfound--", entityName);
      return;
    }
    entities[entityName].setOptions(optionContent);
  });
}
function setFields() {
  const convertedFields = jdl_to_json_field_converter_default.convert(jdlObject2);
  convertedFields.forEach((entityFields, entityName) => {
    entities[entityName].addFields(entityFields);
  });
}
function setRelationships() {
  const convertedRelationships2 = jdl_to_json_relationship_converter_default.convert(jdlObject2.getRelationships(), jdlObject2.getEntityNames());
  convertedRelationships2.forEach((entityRelationships, entityName) => {
    entities[entityName].addRelationships(entityRelationships);
  });
}
function setAigcs() {
  const convertedAigs = jdl_to_json_aigc_converter_default.convert(jdlObject2.getAigcs(), jdlObject2.getEntityNames());
  convertedAigs.forEach((aigcs, entityName) => {
    entities[entityName].addAigcs(aigcs);
  });
}
function setApplicationToEntities() {
  Object.keys(entities).forEach((entityName) => {
    entities[entityName].applications = "*";
  });
}
var entities, jdlObject2, jdl_without_application_to_json_converter_default;
var init_jdl_without_application_to_json_converter = __esm({
  "node_modules/generator-begcode/dist/jdl/converters/jdl-to-json/jdl-without-application-to-json-converter.js"() {
    init_jdl_to_json_basic_entity_converter();
    init_jdl_to_json_field_converter();
    init_jdl_to_json_relationship_converter();
    init_jdl_to_json_option_converter();
    init_jdl_to_json_aigc_converter();
    jdl_without_application_to_json_converter_default = {
      convert: convert6
    };
  }
});

// node_modules/generator-begcode/dist/jdl/converters/jdl-to-json/jdl-with-applications-to-json-converter.js
function convert7(args = {}) {
  if (!args.jdlObject) {
    throw new Error("The JDL object is mandatory.");
  }
  init3(args);
  setEntitiesPerApplication();
  if (entitiesPerApplication.size === 0) {
    const applicationNames = jdlObject3.getApplications().map((jdlApplication) => jdlApplication.getConfigurationOptionValue("baseName"));
    return new Map(applicationNames.map((applicationName) => [applicationName, []]));
  }
  setBasicEntityInformation2();
  setFields2();
  setRelationships2();
  setAigcs2();
  setApplicationToEntities2();
  const entitiesForEachApplication = getEntitiesForEachApplicationMap();
  setOptions2(entitiesForEachApplication);
  formatEntitiesForEachApplication(entitiesForEachApplication);
  addApplicationsWithoutEntities(entitiesForEachApplication);
  return entitiesForEachApplication;
}
function init3(args) {
  if (jdlObject3) {
    resetState2();
  }
  jdlObject3 = args.jdlObject;
  entities2 = {};
  entitiesPerApplication = /* @__PURE__ */ new Map();
}
function resetState2() {
  jdlObject3 = null;
  entities2 = null;
}
function setEntitiesPerApplication() {
  jdlObject3.forEachApplication((jdlApplication) => {
    const entityNames2 = jdlApplication.getEntityNames();
    if (entityNames2.length === 0) {
      return;
    }
    const baseName = jdlApplication.getConfigurationOptionValue("baseName");
    entitiesPerApplication.set(baseName, entityNames2);
  });
}
function setBasicEntityInformation2() {
  const convertedEntities = jdl_to_json_basic_entity_converter_default.convert(jdlObject3.getEntities());
  convertedEntities.forEach((jsonEntity, entityName) => {
    entities2[entityName] = jsonEntity;
  });
}
function setFields2() {
  const convertedFields = jdl_to_json_field_converter_default.convert(jdlObject3);
  convertedFields.forEach((entityFields, entityName) => {
    entities2[entityName].addFields(entityFields);
  });
}
function setRelationships2() {
  const convertedRelationships2 = jdl_to_json_relationship_converter_default.convert(jdlObject3.getRelationships(), jdlObject3.getEntityNames());
  convertedRelationships2.forEach((entityRelationships, entityName) => {
    entities2[entityName].addRelationships(entityRelationships);
  });
}
function setAigcs2() {
  const convertedAigs = jdl_to_json_aigc_converter_default.convert(jdlObject3.getAigcs(), jdlObject3.getEntityNames());
  convertedAigs.forEach((aigcs, entityName) => {
    entities2[entityName].addAigc(aigcs);
  });
}
function setApplicationToEntities2() {
  jdlObject3.forEachApplication((jdlApplication) => {
    const baseName = jdlApplication.getConfigurationOptionValue("baseName");
    jdlApplication.forEachEntityName((entityName) => {
      if (!entities2[entityName]) {
        return;
      }
      entities2[entityName].applications.push(baseName);
    });
  });
}
function setOptions2(entitiesForEachApplication) {
  const convertedOptionContents = jdl_to_json_option_converter_default.convert(jdlObject3);
  convertedOptionContents.forEach((optionContent, entityName) => {
    if (!entities2[entityName]) {
      console.log("---entityName---", entityName);
    }
    entities2[entityName].setOptions(optionContent);
  });
  jdlObject3.forEachApplication((jdlApplication) => {
    const convertedOptionContentsForApplication = jdl_to_json_option_converter_default.convert(jdlApplication);
    const applicationName = jdlApplication.getConfigurationOptionValue("baseName");
    const applicationEntities = entitiesForEachApplication.get(applicationName);
    convertedOptionContentsForApplication.forEach((optionContent, entityName) => {
      if (!applicationEntities[entityName]) {
        return;
      }
      applicationEntities[entityName].setOptions(optionContent);
    });
  });
}
function getEntitiesForEachApplicationMap() {
  const entitiesForEachApplication = /* @__PURE__ */ new Map();
  entitiesPerApplication.forEach((entityNames2, applicationName) => {
    const entitiesInObject = entityNames2.filter((entityName) => !!entities2[entityName]).map((entityName) => entities2[entityName]).reduce((accumulator, currentEntity) => {
      return {
        ...accumulator,
        [currentEntity.name]: currentEntity
      };
    }, {});
    entitiesForEachApplication.set(applicationName, entitiesInObject);
  });
  return entitiesForEachApplication;
}
function formatEntitiesForEachApplication(entitiesForEachApplication) {
  entitiesForEachApplication.forEach((applicationEntities, applicationName) => {
    entitiesForEachApplication.set(applicationName, Object.values(applicationEntities));
  });
}
function addApplicationsWithoutEntities(entitiesForEachApplication) {
  jdlObject3.forEachApplication((jdlApplication) => {
    if (jdlApplication.getEntityNames().length === 0) {
      entitiesForEachApplication.set(jdlApplication.getConfigurationOptionValue("baseName"), []);
    }
  });
}
var entities2, jdlObject3, entitiesPerApplication;
var init_jdl_with_applications_to_json_converter = __esm({
  "node_modules/generator-begcode/dist/jdl/converters/jdl-to-json/jdl-with-applications-to-json-converter.js"() {
    init_jdl_to_json_basic_entity_converter();
    init_jdl_to_json_field_converter();
    init_jdl_to_json_relationship_converter();
    init_jdl_to_json_aigc_converter();
    init_jdl_to_json_option_converter();
  }
});

// node_modules/generator-begcode/dist/jdl/exporters/config.js
var mergeYoRcContent;
var init_config = __esm({
  "node_modules/generator-begcode/dist/jdl/exporters/config.js"() {
    init_export_utils();
    mergeYoRcContent = (oldConfig, newConfig) => {
      const merged = { [GENERATOR_NAME]: {} };
      for (const ns of /* @__PURE__ */ new Set([...Object.keys(oldConfig), ...Object.keys(newConfig)])) {
        merged[ns] = { ...oldConfig[ns], ...newConfig[ns] };
      }
      if (oldConfig[GENERATOR_NAME]?.creationTimestamp) {
        merged[GENERATOR_NAME].creationTimestamp = oldConfig[GENERATOR_NAME].creationTimestamp;
      }
      return merged;
    };
  }
});

// node_modules/generator-begcode/dist/jdl/exporters/export-utils.js
function writeConfigFile(config, yoRcPath = ".yo-rc.json") {
  let newYoRc = { ...config };
  if (doesFileExist(yoRcPath)) {
    const yoRc = JSON.parse(import_fs3.default.readFileSync(yoRcPath, { encoding: "utf-8" }));
    newYoRc = mergeYoRcContent(yoRc, config);
  }
  import_fs3.default.writeFileSync(yoRcPath, JSON.stringify(newYoRc, null, 2).concat("\n"));
}
var import_fs3, GENERATOR_NAME;
var init_export_utils = __esm({
  "node_modules/generator-begcode/dist/jdl/exporters/export-utils.js"() {
    import_fs3 = __toESM(require("fs"), 1);
    init_file_utils();
    init_config();
    GENERATOR_NAME = "generator-begcode";
  }
});

// node_modules/generator-begcode/dist/jdl/exporters/applications/jhipster-application-formatter.js
function formatApplicationsToExport(applications, configuration3) {
  if (!applications) {
    throw new Error("Applications have to be passed to be exported.");
  }
  return Object.values(applications).map((application) => {
    return setUpApplicationStructure(application, configuration3);
  });
}
function formatApplicationToExport(application, configuration3 = {}) {
  return setUpApplicationStructure(application, configuration3);
}
function setUpApplicationStructure(application) {
  let applicationToExport = {
    [GENERATOR_NAME]: {}
  };
  applicationToExport[GENERATOR_NAME] = getApplicationConfig(application);
  if (application.namespaceConfigs.length > 0) {
    applicationToExport.namespaceConfigs = getApplicationNamespaceConfig(application);
  }
  applicationToExport[GENERATOR_NAME].entities = application.getEntityNames();
  if (application.hasConfigurationOption("creationTimestamp")) {
    applicationToExport[GENERATOR_NAME].creationTimestamp = parseInt(application.getConfigurationOptionValue("creationTimestamp"), 10);
  }
  applicationToExport = cleanUpOptions(applicationToExport);
  return applicationToExport;
}
function getApplicationConfig(application) {
  const result = {};
  application.forEachConfigurationOption((option) => {
    result[option.name] = option.getValue();
  });
  return result;
}
function getApplicationNamespaceConfig(application) {
  if (application.namespaceConfigs.length === 0) {
    return void 0;
  }
  const result = {};
  application.forEachNamespaceConfiguration((configurationOption) => {
    result[configurationOption.namespace] = result[configurationOption.namespace] ?? {};
    configurationOption.forEachOption((option) => {
      result[configurationOption.namespace][option.name] = option.getValue();
    });
  });
  return result;
}
function cleanUpOptions(application) {
  if (!application[GENERATOR_NAME].frontEndBuilder) {
    delete application[GENERATOR_NAME].frontEndBuilder;
  }
  delete application.entityNames;
  if (application[GENERATOR_NAME].blueprints) {
    application[GENERATOR_NAME].blueprints = application[GENERATOR_NAME].blueprints.map((blueprintName) => ({
      name: blueprintName
    }));
  }
  if (application[GENERATOR_NAME].microfrontends) {
    application[GENERATOR_NAME].microfrontends = application[GENERATOR_NAME].microfrontends.map((baseName) => ({
      baseName
    }));
  }
  return application;
}
var init_jhipster_application_formatter = __esm({
  "node_modules/generator-begcode/dist/jdl/exporters/applications/jhipster-application-formatter.js"() {
    init_export_utils();
  }
});

// node_modules/generator-begcode/dist/jdl/validators/validator.js
function checkForAbsentAttributes(validator, object) {
  const absentAttributes = [];
  validator.fieldsToCheck.forEach((attribute) => {
    if (!object[attribute]) {
      absentAttributes.push(attribute);
    }
  });
  if (absentAttributes.length !== 0) {
    const plural = absentAttributes.length > 1;
    throw new Error(`The ${validator.objectType} attribute${plural ? "s" : ""} ${absentAttributes.join(", ")} ${plural ? "were not" : "was not"} found.`);
  }
}
var Validator;
var init_validator2 = __esm({
  "node_modules/generator-begcode/dist/jdl/validators/validator.js"() {
    Validator = class {
      objectType;
      fieldsToCheck;
      constructor(objectType, fieldsToCheck) {
        this.objectType = objectType;
        this.fieldsToCheck = fieldsToCheck;
      }
      validate(object, _options) {
        if (!object) {
          throw new Error(`No ${this.objectType}.`);
        }
        checkForAbsentAttributes(this, object);
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/validators/deployment-validator.js
function validateDockerComposeRelatedDeployment(jdlDeployment, options = {}) {
  if (jdlDeployment.gatewayType !== Options6.gatewayType.springCloudGateway && options.applicationType === MICROSERVICE4) {
    throw new Error("A gateway type must be provided when dealing with microservices and the deployment type is docker-compose.");
  }
}
function validateKubernetesRelatedDeployment(jdlDeployment) {
  if (!jdlDeployment.kubernetesServiceType) {
    throw new Error("A kubernetes service type must be provided when dealing with kubernetes-related deployments.");
  }
  if (jdlDeployment.istio && !jdlDeployment.ingressDomain) {
    throw new Error("An ingress domain must be provided when dealing with kubernetes-related deployments, with istio and when the service type is ingress.");
  }
  if (jdlDeployment.kubernetesServiceType === Options6.kubernetesServiceType.ingress && !jdlDeployment.ingressType) {
    throw new Error("An ingress type is required when dealing with kubernetes-related deployments and when the service type is ingress.");
  }
}
function validateOpenshiftRelatedDeployment(jdlDeployment, options) {
  if (jdlDeployment.storageType) {
    if (options.prodDatabaseType === NO3) {
      throw new Error(`Can't have the storageType option set when there is no ${PROD_DATABASE_TYPE3}.`);
    }
    if (options.searchEngine === ELASTICSEARCH3) {
      throw new Error("Can't have the storageType option set when elasticsearch is the search engine.");
    }
    if (jdlDeployment.monitoring === Options6.monitoring.prometheus) {
      throw new Error("Can't have the storageType option set when the monitoring is done with prometheus.");
    }
  }
}
var Options6, MICROSERVICE4, NO3, ELASTICSEARCH3, OptionNames6, PROD_DATABASE_TYPE3, DeploymentValidator;
var init_deployment_validator = __esm({
  "node_modules/generator-begcode/dist/jdl/validators/deployment-validator.js"() {
    init_validator2();
    init_jhipster2();
    ({ Options: Options6 } = deployment_options_default);
    ({ MICROSERVICE: MICROSERVICE4 } = application_types_default);
    ({ NO: NO3 } = database_types_default);
    ({ ELASTICSEARCH: ELASTICSEARCH3 } = search_engine_types_default);
    ({ OptionNames: OptionNames6 } = application_options_default);
    ({ PROD_DATABASE_TYPE: PROD_DATABASE_TYPE3 } = OptionNames6);
    DeploymentValidator = class extends Validator {
      constructor() {
        super("deployment", ["deploymentType", "appsFolders", "directoryPath"]);
      }
      validate(jdlDeployment, options = {}) {
        super.validate(jdlDeployment);
        switch (jdlDeployment.deploymentType) {
          case Options6.deploymentType.dockerCompose:
            validateDockerComposeRelatedDeployment(jdlDeployment, options);
            break;
          case Options6.deploymentType.kubernetes:
            validateKubernetesRelatedDeployment(jdlDeployment);
            break;
          case Options6.deploymentType.openshift:
            validateOpenshiftRelatedDeployment(jdlDeployment, options);
            break;
          default:
            throw new Error(`The deployment type ${jdlDeployment.deploymentType} isn't supported.`);
        }
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/exporters/jhipster-deployment-exporter.js
function exportDeployments(deployments) {
  if (!deployments) {
    throw new Error("Deployments have to be passed to be exported.");
  }
  return Object.values(deployments).map((deployment) => {
    checkForErrors(deployment);
    deployment = setUpDeploymentStructure(deployment);
    writeDeploymentConfigs(deployment);
    return deployment;
  });
}
function checkForErrors(deployment) {
  const validator = new DeploymentValidator();
  validator.validate(deployment);
}
function setUpDeploymentStructure(deployment) {
  let deploymentToExport = {};
  deploymentToExport[GENERATOR_NAME] = JSON.parse(JSON.stringify(deployment, null, 2).concat("\n"));
  deploymentToExport[GENERATOR_NAME].appsFolders = deployment.appsFolders;
  deploymentToExport[GENERATOR_NAME].clusteredDbApps = deployment.clusteredDbApps;
  deploymentToExport = setUpArrayOptions(deploymentToExport);
  return deploymentToExport;
}
function setUpArrayOptions(deployment) {
  deployment[GENERATOR_NAME].appsFolders = Array.from(deployment[GENERATOR_NAME].appsFolders);
  deployment[GENERATOR_NAME].clusteredDbApps = Array.from(deployment[GENERATOR_NAME].clusteredDbApps);
  return deployment;
}
function writeDeploymentConfigs(deployment) {
  const folderName = deployment[GENERATOR_NAME].deploymentType;
  if (doesFileExist(folderName)) {
    throw new Error(`A file named '${folderName}' already exists, so a folder of the same name can't be created for the application.`);
  }
  createFolderIfItDoesNotExist(folderName);
  writeConfigFile(deployment, import_path2.default.join(folderName, ".yo-rc.json"));
}
var import_path2;
var init_jhipster_deployment_exporter = __esm({
  "node_modules/generator-begcode/dist/jdl/exporters/jhipster-deployment-exporter.js"() {
    import_path2 = __toESM(require("path"), 1);
    init_file_utils();
    init_deployment_validator();
    init_export_utils();
  }
});

// node_modules/generator-begcode/dist/jdl/exporters/jhipster-entity-exporter.js
function exportEntities(passedConfiguration) {
  init4(passedConfiguration);
  if (configuration2.entities.length === 0) {
    return configuration2.entities;
  }
  const subFolder = passedConfiguration.application.forSeveralApplications ? configuration2.application.name : "";
  configuration2.entities = updateEntities(subFolder);
  if (shouldFilterOutEntitiesBasedOnMicroservice()) {
    configuration2.entities = filterOutEntitiesByMicroservice();
  }
  return configuration2.entities;
}
function init4(passedConfiguration) {
  if (!passedConfiguration || !passedConfiguration.entities) {
    throw new Error("Entities have to be passed to be exported.");
  }
  configuration2 = passedConfiguration;
}
function updateEntities(subFolder) {
  return configuration2.entities.map((entity) => {
    const filePath = import_path3.default.join(subFolder, toFilePath(entity.name));
    return updateEntityToGenerateWithExistingOne(filePath, entity);
  });
}
function updateEntityToGenerateWithExistingOne(filePath, entity) {
  if (doesFileExist(filePath)) {
    const fileOnDisk = readJSONFile(filePath);
    if (!entity.annotations?.changelogDate && fileOnDisk?.annotations?.changelogDate) {
      entity.annotations = entity.annotations || {};
      entity.annotations.changelogDate = fileOnDisk.annotations.changelogDate;
      return { ...fileOnDisk, ...entity };
    }
  }
  return entity;
}
function shouldFilterOutEntitiesBasedOnMicroservice() {
  return configuration2.application.type && configuration2.application.type === application_types_default.MICROSERVICE && configuration2.application.name;
}
function filterOutEntitiesByMicroservice() {
  return configuration2.entities.filter((entity) => {
    return !(entity.microserviceName && entity.microserviceName.toLowerCase() !== configuration2.application.name.toLowerCase());
  });
}
var import_path3, configuration2;
var init_jhipster_entity_exporter = __esm({
  "node_modules/generator-begcode/dist/jdl/exporters/jhipster-entity-exporter.js"() {
    import_path3 = __toESM(require("path"), 1);
    init_jhipster2();
    init_json_file_reader();
    init_file_utils();
    configuration2 = {};
  }
});

// node_modules/generator-begcode/dist/jdl/validators/entity-validator.js
function checkForReservedClassName(jdlEntity) {
  if (isReservedClassName2(jdlEntity.name)) {
    throw new Error(`The name '${jdlEntity.name}' is a reserved keyword and can not be used as an entity class name.`);
  }
}
var isReservedClassName2, EntityValidator;
var init_entity_validator = __esm({
  "node_modules/generator-begcode/dist/jdl/validators/entity-validator.js"() {
    init_validator2();
    init_jhipster2();
    ({ isReservedClassName: isReservedClassName2 } = reserved_keywords_default);
    EntityValidator = class extends Validator {
      constructor() {
        super("entity", ["name"]);
      }
      validate(jdlEntity, options = {}) {
        super.validate(jdlEntity);
        if (options.checkReservedKeywords) {
          checkForReservedClassName(jdlEntity);
        }
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/validators/field-validator.js
var FieldValidator;
var init_field_validator = __esm({
  "node_modules/generator-begcode/dist/jdl/validators/field-validator.js"() {
    init_validator2();
    FieldValidator = class extends Validator {
      constructor() {
        super("field", ["name", "type"]);
      }
      validate(jdlField) {
        super.validate(jdlField);
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/validators/validation-validator.js
function checkForInvalidName(jdlValidation) {
  if (!exists4(jdlValidation.name)) {
    throw new Error(`The validation ${jdlValidation.name} doesn't exist.`);
  }
}
function checkForRequiredValue(jdlValidation) {
  if (jdlValidation.value == null && needsValue2(jdlValidation.name)) {
    throw new Error(`The validation ${jdlValidation.name} requires a value.`);
  }
}
function checkForInvalidNumericValue(jdlValidation) {
  if (jdlValidation.value.toString().includes(".")) {
    throw new Error(`Decimal values are forbidden for the ${jdlValidation.name} validation.`);
  }
}
var exists4, needsValue2, MINLENGTH2, MAXLENGTH2, MAXBYTES2, MINBYTES2, ValidationValidator;
var init_validation_validator = __esm({
  "node_modules/generator-begcode/dist/jdl/validators/validation-validator.js"() {
    init_validator2();
    init_jhipster2();
    ({ Validations: { exists: exists4, needsValue: needsValue2, MINLENGTH: MINLENGTH2, MAXLENGTH: MAXLENGTH2, MAXBYTES: MAXBYTES2, MINBYTES: MINBYTES2 } } = validations_default);
    ValidationValidator = class extends Validator {
      constructor() {
        super("validation", ["name"]);
      }
      validate(jdlValidation) {
        super.validate(jdlValidation);
        checkForInvalidName(jdlValidation);
        checkForRequiredValue(jdlValidation);
        if ([MINLENGTH2, MAXLENGTH2, MAXBYTES2, MINBYTES2].includes(jdlValidation.name)) {
          checkForInvalidNumericValue(jdlValidation);
        }
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/validators/relationship-validator.js
function checkType(jdlRelationship) {
  if (!relationshipTypeExists(jdlRelationship.type)) {
    throw new Error(`The relationship type '${jdlRelationship.type}' doesn't exist.`);
  }
}
function checkInjectedFields(jdlRelationship) {
  if (!(jdlRelationship.injectedFieldInFrom || jdlRelationship.injectedFieldInTo)) {
    throw new Error("At least one injected field is required.");
  }
}
function checkForRequiredReflexiveRelationship(jdlRelationship) {
  if (jdlRelationship.from.toLowerCase() === jdlRelationship.to.toLowerCase() && (jdlRelationship.isInjectedFieldInFromRequired || jdlRelationship.isInjectedFieldInToRequired)) {
    throw new Error(`Required relationships to the same entity are not supported, for relationship from and to '${jdlRelationship.from}'.`);
  }
}
function checkRelationshipType(jdlRelationship) {
  switch (jdlRelationship.type) {
    case ONE_TO_ONE:
      checkOneToOneRelationship(jdlRelationship);
      break;
    case MANY_TO_ONE:
    case MANY_TO_MANY:
    case ONE_TO_MANY:
      return;
    default:
      throw new Error(`This case shouldn't have happened with type ${jdlRelationship.type}.`);
  }
}
function checkOneToOneRelationship(jdlRelationship) {
  if (!jdlRelationship.injectedFieldInFrom) {
    throw new Error(`In the One-to-One relationship from ${jdlRelationship.from} to ${jdlRelationship.to}, the source entity must possess the destination, or you must invert the direction of the relationship.`);
  }
}
var ONE_TO_ONE, MANY_TO_MANY, MANY_TO_ONE, ONE_TO_MANY, RelationshipValidator;
var init_relationship_validator = __esm({
  "node_modules/generator-begcode/dist/jdl/validators/relationship-validator.js"() {
    init_validator2();
    init_jhipster2();
    init_relationship_types();
    ({ ONE_TO_ONE, MANY_TO_MANY, MANY_TO_ONE, ONE_TO_MANY } = relationship_types_default);
    RelationshipValidator = class extends Validator {
      constructor() {
        super("relationship", ["from", "to", "type"]);
      }
      validate(jdlRelationship) {
        super.validate(jdlRelationship);
        checkType(jdlRelationship);
        checkInjectedFields(jdlRelationship);
        checkForRequiredReflexiveRelationship(jdlRelationship);
        checkRelationshipType(jdlRelationship);
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/validators/enum-validator.js
function checkForReservedClassName2(jdlEnum) {
  if (isReservedClassName3(jdlEnum.name)) {
    throw new Error(`The enum name '${jdlEnum.name}' is reserved keyword and can not be used as enum class name.`);
  }
}
var isReservedClassName3, EnumValidator;
var init_enum_validator = __esm({
  "node_modules/generator-begcode/dist/jdl/validators/enum-validator.js"() {
    init_validator2();
    init_jhipster2();
    ({ isReservedClassName: isReservedClassName3 } = reserved_keywords_default);
    EnumValidator = class extends Validator {
      constructor() {
        super("enum", ["name"]);
      }
      validate(jdlEnum, options = {}) {
        super.validate(jdlEnum);
        if (options.checkReservedKeywords) {
          checkForReservedClassName2(jdlEnum);
        }
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/validators/option-validator.js
var OptionValidator;
var init_option_validator = __esm({
  "node_modules/generator-begcode/dist/jdl/validators/option-validator.js"() {
    init_validator2();
    OptionValidator = class extends Validator {
      constructor(optionType, additionalFieldToCheck) {
        const fieldsToCheck = ["name", "entityNames", "excludedNames", "getType"];
        if (additionalFieldToCheck) {
          fieldsToCheck.push(additionalFieldToCheck);
        }
        super(`${optionType} option`, fieldsToCheck);
      }
      validate(jdlOption) {
        super.validate(jdlOption);
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/validators/unary-option-validator.js
var UnaryOptionValidator;
var init_unary_option_validator = __esm({
  "node_modules/generator-begcode/dist/jdl/validators/unary-option-validator.js"() {
    init_option_validator();
    UnaryOptionValidator = class extends OptionValidator {
      constructor() {
        super("unary");
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/validators/binary-option-validator.js
function checkForInvalidValue(jdlOption) {
  if (!!jdlOption.value && !binary_options_default.exists(jdlOption.name, jdlOption.value)) {
    throw new Error(`The '${jdlOption.name}' option is not valid for value '${jdlOption.value}'.`);
  }
}
var BinaryOptionValidator;
var init_binary_option_validator = __esm({
  "node_modules/generator-begcode/dist/jdl/validators/binary-option-validator.js"() {
    init_binary_options();
    init_option_validator();
    BinaryOptionValidator = class extends OptionValidator {
      constructor() {
        super("binary", "value");
      }
      validate(jdlOption) {
        super.validate(jdlOption);
        checkForInvalidValue(jdlOption);
      }
    };
  }
});

// node_modules/generator-begcode/dist/jdl/validators/jdl-with-application-validator.js
function createValidator(jdlObject4, logger = console) {
  if (!jdlObject4) {
    throw new Error("A JDL object must be passed to check for business errors.");
  }
  return {
    checkForErrors: () => {
      jdlObject4.forEachApplication((jdlApplication) => {
        const blueprints = jdlApplication.getConfigurationOptionValue(BLUEPRINTS2);
        const checkReservedKeywords = (blueprints?.length ?? 0) === 0;
        checkForNamespaceConfigErrors(jdlApplication);
        checkForRelationshipErrors();
        checkForEntityErrors(jdlApplication, { checkReservedKeywords });
        checkForEnumErrors({ checkReservedKeywords });
        if (!checkReservedKeywords) {
          logger.warn("Blueprints are being used, the JDL validation phase is skipped.");
          return;
        }
        checkDeploymentsErrors();
        checkForOptionErrors();
      });
      checkForRelationshipsBetweenApplications();
    }
  };
  function checkForNamespaceConfigErrors(jdlApplication) {
    jdlApplication.forEachNamespaceConfiguration((config) => {
      const blueprints = jdlApplication.config.getOption("blueprints");
      if (!blueprints || !blueprints.getValue().some((blueprint) => blueprint === config.namespace)) {
        throw new Error(`Blueprint namespace config ${config.namespace} requires the blueprint ${config.namespace}`);
      }
    });
  }
  function checkForEntityErrors(jdlApplication, options) {
    if (jdlObject4.getEntityQuantity() === 0) {
      return;
    }
    const validator = new EntityValidator();
    jdlObject4.forEachEntity((jdlEntity) => {
      if (!jdlApplication.hasEntityName(jdlEntity.name)) {
        return;
      }
      validator.validate(jdlEntity, options);
      checkForFieldErrors(jdlEntity.name, jdlEntity.fields, jdlApplication);
    });
  }
  function checkForFieldErrors(_entityName, jdlFields, _jdlApplication) {
    const validator = new FieldValidator();
    Object.keys(jdlFields).forEach((fieldName) => {
      const jdlField = jdlFields[fieldName];
      validator.validate(jdlField);
      const isAnEnum = jdlObject4.hasEnum(jdlField.type);
      checkForValidationErrors(jdlField, isAnEnum);
    });
  }
  function checkForValidationErrors(jdlField, isAnEnum) {
    const validator = new ValidationValidator();
    Object.keys(jdlField.validations).forEach((validationName) => {
      const jdlValidation = jdlField.validations[validationName];
      validator.validate(jdlValidation);
      if (!field_types_default.hasValidation(jdlField.type, jdlValidation.name, isAnEnum)) {
        throw new Error(`The validation '${jdlValidation.name}' isn't supported for the type '${jdlField.type}'.`);
      }
    });
  }
  function checkForRelationshipErrors() {
    if (jdlObject4.getRelationshipQuantity() === 0) {
      return;
    }
    const validator = new RelationshipValidator();
    jdlObject4.forEachRelationship((jdlRelationship) => {
      validator.validate(jdlRelationship);
      checkForAbsentEntities({
        jdlRelationship,
        doesEntityExist: (entityName) => !!jdlObject4.getEntity(entityName)
      });
    });
  }
  function checkForEnumErrors(options) {
    if (jdlObject4.getEnumQuantity() === 0) {
      return;
    }
    const validator = new EnumValidator();
    jdlObject4.forEachEnum((jdlEnum) => {
      validator.validate(jdlEnum, options);
    });
  }
  function checkDeploymentsErrors() {
    if (jdlObject4.getDeploymentQuantity() === 0) {
      return;
    }
    const validator = new DeploymentValidator();
    jdlObject4.forEachDeployment((deployment) => {
      validator.validate(deployment);
    });
  }
  function checkForOptionErrors() {
    if (jdlObject4.getOptionQuantity() === 0) {
      return;
    }
    const unaryOptionValidator = new UnaryOptionValidator();
    const binaryOptionValidator = new BinaryOptionValidator();
    jdlObject4.getOptions().forEach((option) => {
      if (option.getType() === "UNARY") {
        unaryOptionValidator.validate(option);
      } else {
        binaryOptionValidator.validate(option);
      }
    });
  }
  function checkForRelationshipsBetweenApplications() {
    const applicationsPerEntityNames = getApplicationsPerEntityNames(jdlObject4);
    jdlObject4.forEachRelationship((jdlRelationship) => {
      checkIfRelationshipIsBetweenApplications({
        jdlRelationship,
        applicationsPerEntityName: applicationsPerEntityNames
      });
    });
  }
}
function checkForAbsentEntities({ jdlRelationship, doesEntityExist }) {
  const absentEntities = [];
  if (!doesEntityExist(jdlRelationship.from)) {
    absentEntities.push(jdlRelationship.from);
  }
  if (!doesEntityExist(jdlRelationship.to) && !jdlRelationship.options.global[BUILT_IN_ENTITY5]) {
    absentEntities.push(jdlRelationship.to);
  }
  if (absentEntities.length !== 0) {
    throw new Error(`In the relationship between ${jdlRelationship.from} and ${jdlRelationship.to}, ${absentEntities.join(" and ")} ${absentEntities.length === 1 ? "is" : "are"} not declared. If '${jdlRelationship.to}' is a built-in entity declare like '${jdlRelationship.from} to ${jdlRelationship.to} with builtInEntity'.`);
  }
}
function checkIfRelationshipIsBetweenApplications({ jdlRelationship, applicationsPerEntityName: applicationsPerEntityName2 }) {
  let applicationsForSourceEntity = applicationsPerEntityName2[jdlRelationship.from];
  let applicationsForDestinationEntity = applicationsPerEntityName2[jdlRelationship.to];
  if (!applicationsForDestinationEntity || !applicationsForSourceEntity) {
    return;
  }
  applicationsForSourceEntity = applicationsForSourceEntity.map((jdlApplication) => jdlApplication.getConfigurationOptionValue(BASE_NAME4));
  applicationsForDestinationEntity = applicationsForDestinationEntity.map((jdlApplication) => jdlApplication.getConfigurationOptionValue(BASE_NAME4));
  const difference2 = applicationsForSourceEntity.filter((application) => !applicationsForDestinationEntity.includes(application));
  if (difference2.length !== 0) {
    throw new Error(`Entities for the ${jdlRelationship.type} relationship from '${jdlRelationship.from}' to '${jdlRelationship.to}' do not belong to the same application.`);
  }
}
function getApplicationsPerEntityNames(jdlObject4) {
  const applicationsPerEntityName2 = {};
  jdlObject4.forEachApplication((jdlApplication) => {
    jdlApplication.forEachEntityName((entityName) => {
      applicationsPerEntityName2[entityName] = applicationsPerEntityName2[entityName] || [];
      applicationsPerEntityName2[entityName].push(jdlApplication);
    });
  });
  return applicationsPerEntityName2;
}
var OptionNames7, BUILT_IN_ENTITY5, BLUEPRINTS2, BASE_NAME4;
var init_jdl_with_application_validator = __esm({
  "node_modules/generator-begcode/dist/jdl/validators/jdl-with-application-validator.js"() {
    init_entity_validator();
    init_field_validator();
    init_jhipster2();
    init_validation_validator();
    init_relationship_validator();
    init_enum_validator();
    init_deployment_validator();
    init_unary_option_validator();
    init_binary_option_validator();
    ({ OptionNames: OptionNames7 } = application_options_default);
    ({ BUILT_IN_ENTITY: BUILT_IN_ENTITY5 } = relationship_options_default);
    ({ BLUEPRINTS: BLUEPRINTS2, BASE_NAME: BASE_NAME4 } = OptionNames7);
  }
});

// node_modules/generator-begcode/dist/jdl/validators/jdl-without-application-validator.js
function createValidator2(jdlObject4, applicationSettings = {}, logger = console) {
  if (!jdlObject4) {
    throw new Error("A JDL object must be passed to check for business errors.");
  }
  const { blueprints, databaseType } = applicationSettings;
  const checkReservedKeywords = Boolean((databaseType ?? "no") !== "no") && (blueprints?.length ?? 0) === 0;
  return {
    checkForErrors: () => {
      checkForEntityErrors({ checkReservedKeywords });
      checkForRelationshipErrors();
      checkForEnumErrors({ checkReservedKeywords });
      if (checkReservedKeywords) {
        checkDeploymentsErrors();
        checkForOptionErrors();
      } else {
        logger.warn("Blueprints are being used, the JDL validation phase is skipped.");
      }
    }
  };
  function checkForEntityErrors(options) {
    if (jdlObject4.getEntityQuantity() === 0) {
      return;
    }
    const validator = new EntityValidator();
    jdlObject4.forEachEntity((jdlEntity) => {
      validator.validate(jdlEntity, options);
      if (options.checkReservedKeywords) {
        if (isReservedTableName(jdlEntity.tableName, applicationSettings.databaseType)) {
          logger.warn(`The table name '${jdlEntity.tableName}' is a reserved keyword, so it will be prefixed with the value of 'jhiPrefix'.`);
        }
      }
      checkForFieldErrors(jdlEntity.name, jdlEntity.fields, options);
    });
  }
  function checkForFieldErrors(entityName, jdlFields, options) {
    const validator = new FieldValidator();
    const filtering = applicationSettings.databaseType === SQL5;
    Object.keys(jdlFields).forEach((fieldName) => {
      const jdlField = jdlFields[fieldName];
      validator.validate(jdlField);
      if (options.checkReservedKeywords) {
        if (isReservedFieldName(jdlField.name)) {
          logger.warn(`The name '${jdlField.name}' is a reserved keyword, so it will be prefixed with the value of 'jhiPrefix'.`);
        }
        if (filtering && isReservedPaginationWords(jdlField.name)) {
          throw new Error(`Field name '${fieldName}' found in ${entityName} is a reserved keyword, as it is used by Spring for pagination in the URL.`);
        }
      }
      const typeCheckingFunction = getTypeCheckingFunction(entityName, applicationSettings);
      if (!jdlObject4.hasEnum(jdlField.type) && !typeCheckingFunction(jdlField.type)) {
        throw new Error(`The type '${jdlField.type}' is an unknown field type for field '${fieldName}' of entity '${entityName}'.`);
      }
      const isAnEnum = jdlObject4.hasEnum(jdlField.type);
      checkForValidationErrors(jdlField, isAnEnum);
    });
  }
  function checkForValidationErrors(jdlField, isAnEnum) {
    const validator = new ValidationValidator();
    jdlField.forEachValidation((jdlValidation) => {
      validator.validate(jdlValidation);
      if (!field_types_default.hasValidation(jdlField.type, jdlValidation.name, isAnEnum)) {
        throw new Error(`The validation '${jdlValidation.name}' isn't supported for the type '${jdlField.type}'.`);
      }
    });
  }
  function checkForRelationshipErrors() {
    if (jdlObject4.getRelationshipQuantity() === 0) {
      return;
    }
    const validator = new RelationshipValidator();
    jdlObject4.forEachRelationship((jdlRelationship) => {
      validator.validate(jdlRelationship);
      checkForAbsentEntities2({
        jdlRelationship,
        doesEntityExist: (entityName) => !!jdlObject4.getEntity(entityName)
      });
    });
  }
  function checkForEnumErrors(options) {
    if (jdlObject4.getEnumQuantity() === 0) {
      return;
    }
    const validator = new EnumValidator();
    jdlObject4.forEachEnum((jdlEnum) => {
      validator.validate(jdlEnum, options);
    });
  }
  function checkDeploymentsErrors() {
    if (jdlObject4.getDeploymentQuantity() === 0) {
      return;
    }
    const validator = new DeploymentValidator();
    jdlObject4.forEachDeployment((deployment) => {
      validator.validate(deployment);
    });
  }
  function checkForOptionErrors() {
    if (jdlObject4.getOptionQuantity() === 0) {
      return;
    }
    const unaryOptionValidator = new UnaryOptionValidator();
    const binaryOptionValidator = new BinaryOptionValidator();
    jdlObject4.getOptions().forEach((option) => {
      if (option.getType() === "UNARY") {
        unaryOptionValidator.validate(option);
      } else {
        binaryOptionValidator.validate(option);
      }
      checkForPaginationInAppWithCassandra(option, applicationSettings);
    });
  }
}
function getTypeCheckingFunction(entityName, applicationSettings) {
  if (applicationSettings.applicationType === application_types_default.GATEWAY) {
    return () => true;
  }
  return field_types_default.getIsType(applicationSettings.databaseType);
}
function checkForAbsentEntities2({ jdlRelationship, doesEntityExist }) {
  const absentEntities = [];
  if (!doesEntityExist(jdlRelationship.from)) {
    absentEntities.push(jdlRelationship.from);
  }
  if (!doesEntityExist(jdlRelationship.to) && !jdlRelationship.options.global[BUILT_IN_ENTITY6]) {
    absentEntities.push(jdlRelationship.to);
  }
  if (absentEntities.length !== 0) {
    throw new Error(`In the relationship between ${jdlRelationship.from} and ${jdlRelationship.to}, ${absentEntities.join(" and ")} ${absentEntities.length === 1 ? "is" : "are"} not declared. If '${jdlRelationship.to}' is a built-in entity declare like '${jdlRelationship.from} to ${jdlRelationship.to} with builtInEntity'.`);
  }
}
function checkForPaginationInAppWithCassandra(jdlOption, applicationSettings) {
  if (applicationSettings.databaseType === database_types_default.CASSANDRA && jdlOption.name === binary_options_default.Options.PAGINATION) {
    throw new Error("Pagination isn't allowed when the application uses Cassandra.");
  }
}
var BUILT_IN_ENTITY6, SQL5;
var init_jdl_without_application_validator = __esm({
  "node_modules/generator-begcode/dist/jdl/validators/jdl-without-application-validator.js"() {
    init_entity_validator();
    init_field_validator();
    init_jhipster2();
    init_validation_validator();
    init_relationship_validator();
    init_enum_validator();
    init_deployment_validator();
    init_unary_option_validator();
    init_binary_option_validator();
    init_reserved_keywords6();
    ({ BUILT_IN_ENTITY: BUILT_IN_ENTITY6 } = relationship_options_default);
    ({ SQL: SQL5 } = database_types_default);
  }
});

// node_modules/generator-begcode/dist/jdl/jdl-importer.js
function createImporterFromFiles(files, configuration3) {
  if (!files) {
    throw new Error("Files must be passed to create a new JDL importer.");
  }
  const content = parseFiles(files);
  return makeJDLImporter(content, configuration3 || {});
}
function createImporterFromContent(jdlString, configuration3) {
  if (!jdlString) {
    throw new Error("A JDL content must be passed to create a new JDL importer.");
  }
  const content = parseFromContent(jdlString);
  console.log("content::::", content);
  return makeJDLImporter(content, configuration3 || {});
}
function makeJDLImporter(content, configuration3) {
  let importState = {
    exportedApplications: [],
    exportedApplicationsWithEntities: {},
    exportedEntities: [],
    exportedDeployments: []
  };
  return {
    import: (logger = console) => {
      const jdlObject4 = getJDLObject(content, configuration3);
      checkForErrors2(jdlObject4, configuration3, logger);
      if (jdlObject4.getApplicationQuantity() === 0 && jdlObject4.getEntityQuantity() > 0) {
        importState.exportedEntities = importOnlyEntities(jdlObject4, configuration3);
      } else if (jdlObject4.getApplicationQuantity() === 1) {
        importState = importOneApplicationAndEntities(jdlObject4, configuration3);
      } else {
        importState = importApplicationsAndEntities(jdlObject4, configuration3);
      }
      if (jdlObject4.getDeploymentQuantity()) {
        importState.exportedDeployments = importDeployments(jdlObject4.deployments);
      }
      return importState;
    }
  };
}
function parseFiles(files) {
  return parseFromFiles(files);
}
function getJDLObject(parsedJDLContent, configuration3) {
  let baseName = configuration3.applicationName;
  let applicationType = configuration3.applicationType;
  let databaseType = configuration3.databaseType;
  if (configuration3.application) {
    baseName = configuration3.application["generator-begcode"].baseName;
    applicationType = configuration3.application["generator-begcode"].applicationType;
    databaseType = configuration3.application["generator-begcode"].databaseType;
  }
  return parsed_jdl_to_jdl_object_converter_default.parseFromConfigurationObject({
    parsedContent: parsedJDLContent,
    applicationType,
    applicationName: baseName,
    databaseType
  });
}
function checkForErrors2(jdlObject4, configuration3, logger = console) {
  let validator;
  if (jdlObject4.getApplicationQuantity() === 0) {
    let application = configuration3.application;
    if (!application && doesFileExist(".yo-rc.json")) {
      application = readJSONFile(".yo-rc.json");
    }
    let applicationType = configuration3.applicationType;
    let databaseType = configuration3.databaseType;
    let blueprints = configuration3.blueprints;
    if (application && application["generator-begcode"]) {
      if (applicationType === void 0) {
        applicationType = application["generator-begcode"].applicationType;
      }
      if (databaseType === void 0) {
        databaseType = application["generator-begcode"].databaseType;
      }
      if (blueprints === void 0) {
        blueprints = application["generator-begcode"].blueprints;
      }
    }
    validator = createValidator2(jdlObject4, {
      applicationType,
      databaseType,
      blueprints
    }, logger);
  } else {
    validator = createValidator(jdlObject4, logger);
  }
  validator.checkForErrors();
}
function importOnlyEntities(jdlObject4, configuration3) {
  let { applicationName, applicationType, databaseType } = configuration3;
  let application = configuration3.application;
  if (!configuration3.application && doesFileExist(".yo-rc.json")) {
    application = readJSONFile(".yo-rc.json");
  }
  if (application && application["generator-begcode"]) {
    if (applicationType === void 0) {
      applicationType = application["generator-begcode"].applicationType;
    }
    if (applicationName === void 0) {
      applicationName = application["generator-begcode"].baseName;
    }
    if (databaseType === void 0) {
      databaseType = application["generator-begcode"].databaseType;
    }
  }
  const entitiesPerApplicationMap = jdl_without_application_to_json_converter_default.convert({
    jdlObject: jdlObject4,
    applicationName,
    applicationType,
    databaseType
  });
  const jsonEntities = entitiesPerApplicationMap.get(applicationName);
  return exportJSONEntities(jsonEntities, configuration3);
}
function importOneApplicationAndEntities(jdlObject4, configuration3) {
  const importState = {
    exportedApplications: [],
    exportedApplicationsWithEntities: {},
    exportedEntities: [],
    exportedDeployments: []
  };
  const formattedApplication = formatApplicationToExport(jdlObject4.getApplications()[0], configuration3);
  importState.exportedApplications.push(formattedApplication);
  const jdlApplication = jdlObject4.getApplications()[0];
  const applicationName = jdlApplication.getConfigurationOptionValue(BASE_NAME5);
  const entitiesPerApplicationMap = convert7({
    jdlObject: jdlObject4
  });
  const jsonEntities = entitiesPerApplicationMap.get(applicationName);
  const { "generator-begcode": config, ...remaining } = formattedApplication;
  importState.exportedApplicationsWithEntities[applicationName] = {
    config,
    ...remaining,
    entities: []
  };
  if (jsonEntities.length !== 0) {
    const exportedJSONEntities = exportJSONEntities(jsonEntities, {
      applicationName,
      applicationType: jdlApplication.getConfigurationOptionValue(APPLICATION_TYPE3),
      forSeveralApplications: false
    });
    importState.exportedApplicationsWithEntities[applicationName].entities = exportedJSONEntities;
    importState.exportedEntities = uniqBy_default([...importState.exportedEntities, ...exportedJSONEntities], "name");
  }
  return importState;
}
function importApplicationsAndEntities(jdlObject4, configuration3) {
  const importState = {
    exportedApplications: [],
    exportedApplicationsWithEntities: {},
    exportedEntities: [],
    exportedDeployments: []
  };
  const formattedApplications = formatApplicationsToExport(jdlObject4.applications, configuration3);
  importState.exportedApplications = formattedApplications;
  const entitiesPerApplicationMap = convert7({
    jdlObject: jdlObject4
  });
  entitiesPerApplicationMap.forEach((jsonEntities, applicationName) => {
    const jdlApplication = jdlObject4.getApplication(applicationName);
    const exportedJSONEntities = exportJSONEntities(jsonEntities, {
      applicationName,
      applicationType: jdlApplication.getConfigurationOptionValue(APPLICATION_TYPE3),
      forSeveralApplications: true
    });
    const exportedConfig = importState.exportedApplications.find((config2) => applicationName === config2["generator-begcode"].baseName);
    const { "generator-begcode": config, ...remaining } = exportedConfig;
    importState.exportedApplicationsWithEntities[applicationName] = {
      config,
      ...remaining,
      entities: exportedJSONEntities
    };
    importState.exportedEntities = uniqBy_default([...importState.exportedEntities, ...exportedJSONEntities], "name");
  });
  return importState;
}
function importDeployments(deployments) {
  return exportDeployments(deployments);
}
function exportJSONEntities(entities3, configuration3) {
  let baseName = configuration3.applicationName;
  let applicationType = configuration3.applicationType;
  if (configuration3.application) {
    baseName = configuration3.application["generator-begcode"].baseName;
    applicationType = configuration3.application["generator-begcode"].applicationType;
  }
  return exportEntities({
    entities: entities3,
    application: {
      name: baseName,
      type: applicationType,
      forSeveralApplications: !!configuration3.forSeveralApplications
    }
  });
}
var OptionNames8, APPLICATION_TYPE3, BASE_NAME5;
var init_jdl_importer = __esm({
  "node_modules/generator-begcode/dist/jdl/jdl-importer.js"() {
    init_lodash();
    init_jdl_reader();
    init_parsed_jdl_to_jdl_object_converter();
    init_json_file_reader();
    init_file_utils();
    init_jdl_without_application_to_json_converter();
    init_jdl_with_applications_to_json_converter();
    init_jhipster_application_formatter();
    init_jhipster_deployment_exporter();
    init_jhipster_entity_exporter();
    init_jdl_with_application_validator();
    init_jdl_without_application_validator();
    init_jhipster2();
    ({ OptionNames: OptionNames8 } = application_options_default);
    ({ APPLICATION_TYPE: APPLICATION_TYPE3, BASE_NAME: BASE_NAME5 } = OptionNames8);
  }
});

// node_modules/generator-begcode/dist/jdl/parsing/grammar-api.js
function _0x48d2(_0x47d888, _0x1b93b3) {
  const _0x48d2b4 = _0x1b93();
  _0x48d2 = function(_0x33c888, _0x1035ef) {
    _0x33c888 = _0x33c888 - 0;
    let _0x114322 = _0x48d2b4[_0x33c888];
    return _0x114322;
  };
  return _0x48d2(_0x47d888, _0x1b93b3);
}
function _0x1b93() {
  const _0x33201 = ["tsissAtnetnoCetupmoc".split("").reverse().join(""), "ezinekot".split("").reverse().join(""), "nmuloCtrats".split("").reverse().join(""), "297JLEDDA", "ICVBg".split("").reverse().join(""), "epyTnekot".split("").reverse().join(""), "srorre".split("").reverse().join(""), "uHwYf".split("").reverse().join(""), "rlCKZB346364".split("").reverse().join(""), "	\n.".split("").reverse().join(""), "ClPfU", "MFIDAk01".split("").reverse().join(""), "token", "mjvDK", "join", "dlXRg", "csTcU", "input", "' nekot dilavni na dnuoF".split("").reverse().join(""), "161dbDBWY", "1223428FFzqfI", ".snoitpo ro sdrowyek ,sretcarahc dilavni esu ton seod tnetnoc LDJ ruoy erus ekam esaelP".split("").reverse().join(""), "egami".split("").reverse().join(""), "afFYNt491938".split("").reverse().join(""), ", at line: ", "LMmjV".split("").reverse().join(""), "TmniZ".split("").reverse().join(""), "Snmrr", "71312VTkTVo", "epyTnekoTtxen".split("").reverse().join(""), "RWdtor2180892".split("").reverse().join(""), "values", "QvWxP", "\n	at line: ", "resraPteg".split("").reverse().join(""), "vOvao", " :nmuloc dna ".split("").reverse().join(""), "parse", "getGAstProductions", "length", "wlaKv", "rewlO", "pam".split("").reverse().join(""), "WXsnR", "snekot".split("").reverse().join(""), "push", "9ajqaZd", "ngissa".split("").reverse().join(""), "egassem".split("").reverse().join(""), "1121840lXcRlU", "eniLtrats".split("").reverse().join(""), "MismatchedTokenException", " :nmuloc ,".split("").reverse().join(""), "smkGe", "visit", "gorp".split("").reverse().join(""), "16229394BGTRjL", "xJeiF", "EUlOs".split("").reverse().join(""), "eman".split("").reverse().join(""), "YhVrt"];
  _0x1b93 = function() {
    return _0x33201;
  };
  return _0x1b93();
}
function grammarParse(_0x419178, _0x3002e0 = _0x345a70(54)) {
  const _0x3f29ae = getGrammarCst(_0x419178, _0x3002e0);
  const _0x27aa7e = new JDLAstBuilderVisitor();
  return _0x27aa7e["visit"](_0x3f29ae);
}
function getGrammarCst(_0x35399f, _0x2cd532 = _0x345a70(54)) {
  const _0x122b0e = { "QvWxP": function(_0x20fe7d, _0x39ab58) {
    return _0x20fe7d > _0x39ab58;
  }, "mjvDK": function(_0x3652d5, _0x530f4c) {
    return _0x3652d5 ^ _0x530f4c;
  }, "YhVrt": function(_0x189c4c, _0x441e6d) {
    return _0x189c4c ^ _0x441e6d;
  }, "rewlO": function(_0xb2fa97, _0x46ff81) {
    return _0xb2fa97 ^ _0x46ff81;
  }, "csTcU": function(_0x27bfe9, _0x2dfc95) {
    return _0x27bfe9(_0x2dfc95);
  }, "xJeiF": function(_0x93bc49, _0x3ec58f) {
    return _0x93bc49 ^ _0x3ec58f;
  }, "Snmrr": function(_0xad12d5, _0x313d62) {
    return _0xad12d5(_0x313d62);
  } };
  const _0x209bd1 = JDLLexer["tokenize"](_0x35399f);
  if (_0x122b0e["QvWxP"](_0x209bd1["errors"]["length"], _0x122b0e["mjvDK"](974630, 974630))) {
    throw Error(_0x209bd1["errors"][_0x122b0e["YhVrt"](566504, 566504)]["message"]);
  }
  parserSingleton2["input"] = _0x209bd1["tokens"];
  const _0x232d6b = parserSingleton2[_0x2cd532]();
  if (parserSingleton2["errors"]["length"] > _0x122b0e["rewlO"](430394, 430394)) {
    throwParserError2(parserSingleton2["errors"]);
  }
  const _0x5d65dd = _0x122b0e["csTcU"](performAdditionalSyntaxChecks, _0x232d6b);
  if (_0x122b0e["QvWxP"](_0x5d65dd["length"], _0x122b0e["xJeiF"](419847, 419847))) {
    _0x122b0e["Snmrr"](throwSyntaxError2, _0x5d65dd);
  }
  return _0x232d6b;
}
function throwParserError2(_0x5e6317) {
  const _0x5f05cf = _0x48d2;
  const _0x2ecb08 = { "vOvao": function(_0x15e4f8, _0x339165) {
    return _0x15e4f8 === _0x339165;
  }, "fYwHu": _0x5f05cf(50), "VjmML": function(_0x80cd23, _0x1fbbf1) {
    return _0x80cd23(_0x1fbbf1);
  } };
  const _0x18ba6d = _0x5e6317[453822 ^ 453822];
  if (_0x2ecb08["vOvao"](_0x18ba6d["name"], _0x2ecb08["fYwHu"])) {
    _0x2ecb08["VjmML"](throwErrorAboutInvalidToken2, _0x18ba6d);
  }
  const _0x136edd = _0x18ba6d["name"] + " :".split("").reverse().join("") + _0x18ba6d["message"];
  const { token: _0x31e702 } = _0x18ba6d;
  const _0x339a01 = _0x31e702["tokenType"] !== EOF ? _0x5f05cf(32) + _0x31e702["startLine"] + _0x5f05cf(51) + _0x31e702["startColumn"] : "";
  throw _0x2ecb08["VjmML"](Error, "" + _0x136edd + _0x339a01);
}
function throwErrorAboutInvalidToken2(_0xc3c7c6) {
  const _0x24f9dc = _0x48d2;
  const _0x4dc80b = { "ClPfU": function(_0x389032, _0x3942bd) {
    return _0x389032 !== _0x3942bd;
  }, "ZinmT": function(_0x60b382, _0x12da70) {
    return _0x60b382(_0x12da70);
  } };
  const { token: _0x37fa9d } = _0xc3c7c6;
  const _0x23c2b4 = _0x24f9dc(17) + _0x37fa9d["image"] + "'";
  const _0x121c65 = _0x4dc80b["ClPfU"](_0x37fa9d["tokenType"], EOF) ? _0x24f9dc(23) + _0x37fa9d["startLine"] + _0x24f9dc(35) + _0x37fa9d["startColumn"] : "";
  const _0x50faca = _0x24f9dc(20);
  throw _0x4dc80b["ZinmT"](Error, _0xc3c7c6["name"] + " :".split("").reverse().join("") + _0x23c2b4 + _0x121c65 + _0x24f9dc(8) + _0x50faca);
}
function throwSyntaxError2(_0x2da791) {
  const _0x31e644 = _0x48d2;
  throw Error(_0x2da791["map"]((_0x2b196a) => _0x2b196a["message"] + _0x31e644(32) + _0x2b196a["token"]["startLine"] + _0x31e644(51) + _0x2b196a["token"]["startColumn"])["join"]("\n"));
}
function getGrammarAutoCompleteSuggestions(_0x33b25e, _0x5487a5 = _0x345a70(54)) {
  const _0x4d1824 = { "wlaKv": function(_0x38abaf, _0x3e0fcc) {
    return _0x38abaf(_0x3e0fcc);
  } };
  const _0x228175 = JDLLexer["tokenize"](_0x33b25e);
  parserSingleton2["input"] = _0x228175["tokens"];
  const _0xf86d88 = parserSingleton2["computeContentAssist"](_0x5487a5, _0x228175["tokens"]);
  return _0x4d1824["wlaKv"](uniq_default, _0xf86d88["map"]((_0x57f82e) => _0x57f82e["nextTokenType"]));
}
function getLexResult(_0x1e3ee3, _0x5eb026 = _0x345a70(54)) {
  const _0xbc5f6d = { "sOlUE": function(_0x56f304, _0x4ee3e1) {
    return _0x56f304 > _0x4ee3e1;
  }, "gBVCI": function(_0x201ec0, _0x45cfa6) {
    return _0x201ec0 ^ _0x45cfa6;
  }, "dlXRg": function(_0x19b226, _0xdd925b) {
    return _0x19b226 > _0xdd925b;
  }, "smkGe": function(_0x792eb4, _0x4e0285) {
    return _0x792eb4(_0x4e0285);
  }, "WXsnR": function(_0x4060be, _0x8c8f88) {
    return _0x4060be > _0x8c8f88;
  } };
  const _0x74c712 = {};
  const _0x41b2ea = [];
  const _0x2a901f = JDLLexer["tokenize"](_0x1e3ee3);
  if (_0xbc5f6d["sOlUE"](_0x2a901f["errors"]["length"], _0xbc5f6d["gBVCI"](101944, 101944))) {
    _0x41b2ea["push"](..._0x2a901f["errors"]);
  }
  Object["assign"](_0x74c712, _0x2a901f);
  parserSingleton2["input"] = _0x2a901f["tokens"];
  const _0x301981 = parserSingleton2[_0x5eb026]();
  if (_0xbc5f6d["dlXRg"](parserSingleton2["errors"]["length"], 837905 ^ 837905)) {
    _0x41b2ea["push"](...parserSingleton2["errors"]);
  }
  Object["assign"](_0x74c712, _0x301981);
  const _0x2f6cae = _0xbc5f6d["smkGe"](performAdditionalSyntaxChecks, _0x301981);
  if (_0xbc5f6d["WXsnR"](_0x2f6cae["length"], 295305 ^ 295305)) {
    _0x41b2ea["push"](..._0x2f6cae);
  }
  _0x74c712["errors"] = _0x41b2ea;
  return _0x74c712;
}
var _0x345a70, parserSingleton2, rules2;
var init_grammar_api = __esm({
  "node_modules/generator-begcode/dist/jdl/parsing/grammar-api.js"() {
    init_lodash();
    init_api5();
    init_jdl_ast_builder_visitor();
    init_lexer2();
    init_jdl_parser();
    init_validator();
    init_parsing_system_checker();
    _0x345a70 = _0x48d2;
    (function(_0xd989d8, _0xa2bb64) {
      const _0xbf3aab = _0x48d2;
      const _0xc024a4 = _0xd989d8();
      while (!![]) {
        try {
          const _0x1cc1fd = parseInt(_0xbf3aab(7)) / 1 + -parseInt(_0xbf3aab(22)) / 2 * (-parseInt(_0xbf3aab(45)) / 3) + -parseInt(_0xbf3aab(19)) / 4 + -parseInt(_0xbf3aab(10)) / 5 * (-parseInt(_0xbf3aab(29)) / 6) + parseInt(_0xbf3aab(18)) / 7 * (-parseInt(_0xbf3aab(27)) / 8) + parseInt(_0xbf3aab(55)) / 9 + -parseInt(_0xbf3aab(48)) / 10 * (parseInt(_0xbf3aab(2)) / 11);
          if (_0x1cc1fd === _0xa2bb64) {
            break;
          } else {
            _0xc024a4["push"](_0xc024a4["shift"]());
          }
        } catch (_0x279b40) {
          _0xc024a4["push"](_0xc024a4["shift"]());
        }
      }
    })(_0x1b93, 979457);
    parserSingleton2 = JDLParser["getParser"]({ "recoveryEnabled": !![] });
    parserSingleton2["parse"]();
    rules2 = parserSingleton2["getGAstProductions"]();
    checkTokens(Object["values"](tokens2), Object["values"](rules2));
  }
});

// node_modules/generator-begcode/dist/jdl/index.js
var jdl_exports = {};
__export(jdl_exports, {
  APPLICATION_TYPE_GATEWAY: () => APPLICATION_TYPE_GATEWAY,
  APPLICATION_TYPE_MICROSERVICE: () => APPLICATION_TYPE_MICROSERVICE,
  APPLICATION_TYPE_MONOLITH: () => APPLICATION_TYPE_MONOLITH,
  SUPPORTED_VALIDATION_RULES: () => SUPPORTED_VALIDATION_RULES,
  Validations: () => Validations,
  aigcTypes: () => aigc_types_default,
  applicationOptions: () => application_options_default,
  applicationTypes: () => application_types_default,
  authenticationTypes: () => authentication_types_default,
  binaryOptions: () => binary_options_default,
  buildToolTypes: () => build_tool_types_default,
  cacheTypes: () => cache_types_default,
  checkAndReturnRelationshipOnValue: () => checkAndReturnRelationshipOnValue,
  clientFrameworkTypes: () => client_framework_types_default,
  createImporterFromContent: () => createImporterFromContent,
  createImporterFromFiles: () => createImporterFromFiles,
  databaseTypes: () => database_types_default,
  defaultApplicationOptions: () => default_application_options_exports,
  deploymentOptions: () => deployment_options_default,
  entityOptions: () => entity_options_default,
  entityTableNameCreator: () => getTableNameFromEntityName,
  fieldTypes: () => field_types_default,
  getConfigForAuthenticationType: () => getConfigForAuthenticationType,
  getConfigForCacheProvider: () => getConfigForCacheProvider,
  getConfigForClientApplication: () => getConfigForClientApplication,
  getConfigForDatabaseType: () => getConfigForDatabaseType,
  getConfigForGatewayApplication: () => getConfigForGatewayApplication,
  getConfigForMicroserviceApplication: () => getConfigForMicroserviceApplication,
  getConfigForMonolithApplication: () => getConfigForMonolithApplication,
  getConfigForPackageName: () => getConfigForPackageName,
  getConfigForReactive: () => getConfigForReactive,
  getConfigForTranslation: () => getConfigForTranslation,
  getConfigWithDefaults: () => getConfigWithDefaults,
  getCst: () => getCst,
  getDefaultConfigForNewApplication: () => getDefaultConfigForNewApplication,
  getGrammarAutoCompleteSuggestions: () => getGrammarAutoCompleteSuggestions,
  getGrammarCst: () => getGrammarCst,
  getLexResult: () => getLexResult,
  getServerConfigForGatewayApplication: () => getServerConfigForGatewayApplication,
  getServerConfigForMicroserviceApplication: () => getServerConfigForMicroserviceApplication,
  getServerConfigForMonolithApplication: () => getServerConfigForMonolithApplication,
  getSyntacticAutoCompleteSuggestions: () => getSyntacticAutoCompleteSuggestions,
  getTableNameFromEntityNameFallback: () => getTableNameFromEntityNameFallback,
  grammarParse: () => grammarParse,
  ingressTypes: () => IngressTypes,
  jsonEntity: () => json_entity_default,
  kubernetesPlatformTypes: () => kubernetes_platform_types_default,
  mergeYoRcContent: () => mergeYoRcContent,
  messageBrokerTypes: () => message_broker_types_default,
  monitoringTypes: () => monitoring_types_default,
  openapiOptions: () => openapi_options_default,
  openshiftPlatformTypes: () => openshift_platform_types_default,
  parse: () => parse,
  relationshipOptions: () => relationship_options_default,
  relationshipTypes: () => relationship_types_default,
  reservedKeywords: () => reserved_keywords_default,
  searchEngineTypes: () => search_engine_types_default,
  serviceDiscoveryTypes: () => service_discovery_types_default,
  shouldWriteEntityTableName: () => shouldWriteEntityTableName,
  testFrameworkTypes: () => test_framework_types_default,
  unaryOptions: () => unary_options_default,
  validations: () => validations_default,
  websocketTypes: () => websocket_types_default
});
var init_jdl3 = __esm({
  "node_modules/generator-begcode/dist/jdl/index.js"() {
    init_jdl_importer();
    init_api6();
    init_grammar_api();
    init_jhipster2();
    init_config();
  }
});

// src/extension.ts
var extension_exports = {};
__export(extension_exports, {
  activate: () => activate,
  cstTokens: () => cstTokens
});
module.exports = __toCommonJS(extension_exports);
var import_console3 = require("console");
var vscode3 = __toESM(require("vscode"));

// src/completeItems.ts
var vscode2 = __toESM(require("vscode"));

// src/hoverHelper.ts
var import_console = require("console");
var import_lodash = __toESM(require_lodash());
var vscode = __toESM(require("vscode"));
var hoverData = {
  entity: {
    anno: {
      ExtendAbstractAuditingEntity: {
        completeItem: {
          label: {
            label: "ExtendAbstractAuditingEntity",
            detail: "",
            description: "\u5B9E\u4F53\u7EE7\u627F\u57FA\u7840\u5BA1\u8BA1\u7C7B"
          },
          kind: vscode.CompletionItemKind.Class
        },
        contents: [
          "\u5B9E\u4F53\u7EE7\u627F\u57FA\u7840\u5BA1\u8BA1\u7C7B\u6CE8\u89E3",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @extendAbstractAuditingEntity",
            "```"
          ].join("\n"),
          [
            "#### \u5305\u542B\u5B57\u6BB5\uFF1A",
            "- createdBy // \u521B\u5EFA\u7528\u6237ID",
            "- CreatedDate // \u521B\u5EFA\u65F6\u95F4",
            "- lastModifiedBy // \u66F4\u65B0\u7528\u6237ID",
            "- lastModifiedDate // \u66F4\u65B0\u65F6\u95F4"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode"
          ].join("\n")
        ]
      },
      EntityPackage: {
        completeItem: {
          label: {
            label: "EntityPackage",
            detail: "",
            description: "\u5B9E\u4F53\u6307\u5B9A\u5305\u540D"
          },
          insertText: new vscode.SnippetString("EntityPackage(${1})${0}"),
          kind: vscode.CompletionItemKind.Module
        },
        contents: [
          "\u5B9E\u4F53\u6307\u5B9A\u5305\u540D\u6CE8\u89E3",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @entityPackage(xxx)",
            "```"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode",
            "- JHipster"
          ].join("\n")
        ]
      },
      SkipFakeData: {
        completeItem: {
          label: {
            label: "SkipFakeData",
            detail: "",
            description: "\u53D6\u6D88\u751F\u6210\u5047\u6570\u636E"
          },
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u53D6\u6D88\u751F\u6210\u5047\u6570\u636E",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @SkipFakeData(xxx)",
            "```"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode"
          ].join("\n")
        ]
      },
      ImportData: {
        completeItem: {
          label: {
            label: "ImportData",
            detail: "",
            description: "\u5BFC\u5165\u5B9E\u4F53\u6570\u636E"
          },
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u5BFC\u5165\u5B9E\u4F53\u6570\u636E",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @ImportData",
            "```",
            "**\u6CE8\u610F\uFF1A**: \u9700\u8981\u5B58\u5728\u76F8\u5E94\u7684csv\u6587\u4EF6"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode"
          ].join("\n")
        ]
      },
      SkipComponent: {
        completeItem: {
          label: {
            label: "SkipComponent",
            detail: "",
            description: "\u5FFD\u7565\u90E8\u5206\u6587\u4EF6\u751F\u6210"
          },
          insertText: new vscode.SnippetString("SkipComponent(${1}|listPage, editPage, detailPage, clientService, clientRoute, domain, mapper, controllerTest, serviceClass, restController, repository, queryService|)${0}"),
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u5FFD\u7565\u90E8\u5206\u6587\u4EF6\u751F\u6210",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @SkipComponent(listPage)",
            "```",
            "**\u6CE8\u610F\uFF1A**: \u591A\u4E2A\u6587\u4EF6\u65F6\u4F7F\u7528-\u5206\u9694"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode"
          ].join("\n")
        ]
      },
      SkipMultiTenant: {
        completeItem: {
          label: {
            label: "SkipMultiTenant",
            detail: "",
            description: "\u5FFD\u7565\u591A\u79DF\u6237"
          },
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u5FFD\u7565\u591A\u79DF\u6237",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @SkipMultiTenant",
            " entity SysConfig {}",
            "```",
            "**\u6CE8\u610F\uFF1A**: \u4EC5\u5728\u8BBE\u7F6E\u591A\u79DF\u6237\u6A21\u5F0F\u65F6\u6709\u6548"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode"
          ].join("\n")
        ]
      },
      SkipRestApi: {
        completeItem: {
          label: {
            label: "SkipRestApi",
            detail: "",
            description: "\u5FFD\u7565\u6307\u5B9AAPI\u63A5\u53E3"
          },
          insertText: new vscode.SnippetString("SkipRestApi(${1}|dataExport, dataImport, create|)${0}"),
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u5FFD\u7565\u6307\u5B9AAPI\u63A5\u53E3\u751F\u6210",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @SkipRestApi(dataExport)",
            " entity SysConfig {}",
            "```",
            "**\u6CE8\u610F\uFF1A**: \u591A\u4E2A\u63A5\u53E3\u65F6\u4F7F\u7528-\u5206\u9694"
          ].join("\n"),
          [
            "#### \u53EF\u9009\u503C\uFF1A",
            "- dataExport",
            "- dataImport",
            "- create"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode"
          ].join("\n")
        ]
      },
      SkipWebButton: {
        completeItem: {
          label: {
            label: "SkipWebButton",
            detail: "",
            description: "\u5FFD\u7565\u524D\u7AEF\u90E8\u5206\u6309\u94AE"
          },
          insertText: new vscode.SnippetString("SkipWebButton(${1}|listAdd, listModalEdit, listEdit, listDelete, listDetail|)${0}"),
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u5FFD\u7565\u524D\u7AEF\u90E8\u5206\u6309\u94AE\u751F\u6210",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @SkipWebButton(listAdd)",
            " entity SysConfig {}",
            "```",
            "**\u6CE8\u610F\uFF1A**: \u591A\u4E2A\u65F6\u4F7F\u7528-\u5206\u9694"
          ].join("\n"),
          [
            "#### \u53EF\u9009\u503C\uFF1A",
            "- listAdd",
            "- listModalEdit",
            "- listEdit",
            "- listDelete",
            "- listDetail"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode"
          ].join("\n")
        ]
      },
      ListBy: {
        completeItem: {
          label: {
            label: "ListBy",
            detail: "",
            description: "\u6307\u5B9A\u5217\u8868\u6837\u5F0F"
          },
          insertText: new vscode.SnippetString("ListBy(${1}|table, list|)${0}"),
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u6307\u5B9A\u5217\u8868\u6837\u5F0F",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @ListBy(table)",
            " entity SysConfig {}",
            "```"
          ].join("\n"),
          [
            "#### \u53EF\u9009\u503C\uFF1A",
            "- table",
            "- list"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode"
          ].join("\n")
        ]
      },
      Readonly: {
        completeItem: {
          label: {
            label: "Readonly",
            detail: "",
            description: "\u53EA\u8BFB\u5B9E\u4F53"
          },
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u53EA\u8BFB\u5B9E\u4F53",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @Readonly",
            " entity SysConfig {}",
            "```"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode",
            "- JHipster"
          ].join("\n")
        ]
      },
      Dto: {
        completeItem: {
          label: {
            label: "Dto",
            detail: "",
            description: "\u8BBE\u7F6EDTO"
          },
          insertText: new vscode.SnippetString("Dto(${1|mapstruct, no |})${0}"),
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u8BBE\u7F6EDTO",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @Dto(mapstruct)",
            " entity SysConfig {}",
            "```"
          ].join("\n"),
          [
            "#### \u53EF\u9009\u503C\uFF1A",
            "- mapstruct",
            "- no"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode",
            "- JHipster"
          ].join("\n")
        ]
      },
      SkipClient: {
        completeItem: {
          label: {
            label: "SkipClient",
            detail: "",
            description: "\u53D6\u6D88\u524D\u7AEF\u751F\u6210"
          },
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u53D6\u6D88\u524D\u7AEF\u751F\u6210",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @SkipClient",
            " entity SysConfig {}",
            "```"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode",
            "- JHipster"
          ].join("\n")
        ]
      },
      SkipServer: {
        completeItem: {
          label: {
            label: "SkipServer",
            detail: "",
            description: "\u53D6\u6D88\u540E\u7AEF\u751F\u6210"
          },
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u53D6\u6D88\u540E\u7AEF\u751F\u6210",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @SkipServer",
            " entity SysConfig {}",
            "```"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode",
            "- JHipster"
          ].join("\n")
        ]
      },
      Filter: {
        completeItem: {
          label: {
            label: "Filter",
            detail: "",
            description: "\u4F7F\u7528\u8FC7\u6EE4\u5668"
          },
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u4F7F\u7528\u8FC7\u6EE4\u5668",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @Filter",
            " entity SysConfig {}",
            "```",
            "**\u6CE8\u610F\uFF1A**: \u6B64\u529F\u80FD\u5F3A\u70C8\u5EFA\u8BAE\u5F00\u542F"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode",
            "- JHipster"
          ].join("\n")
        ]
      },
      Service: {
        completeItem: {
          label: {
            label: "Service",
            detail: "",
            description: "Service\u5B9E\u73B0\u65B9\u5F0F"
          },
          insertText: new vscode.SnippetString("Service(${1|serviceClass, serviceImpl|})${0}"),
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u8BBE\u7F6EService\u7C7B\u5B9E\u73B0\u65B9\u5F0F",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @Service(serviceClass)",
            " entity SysConfig {}",
            "```",
            "**\u6CE8\u610F\uFF1A**: \u5EFA\u8BAE\u4F7F\u7528serviceClass"
          ].join("\n"),
          [
            "#### \u53EF\u9009\u503C\uFF1A",
            "- serviceClass",
            "- serviceImpl"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode",
            "- JHipster"
          ].join("\n")
        ]
      },
      Paginate: {
        completeItem: {
          label: {
            label: "Paginate",
            detail: "",
            description: "\u8BBE\u7F6E\u5206\u9875\u65B9\u5F0F"
          },
          insertText: new vscode.SnippetString("Paginate(${1|pagination, servinfinite-scroll, no|})${0}"),
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u8BBE\u7F6E\u5206\u9875\u65B9\u5F0F",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @Paginate(pagination)",
            " entity SysConfig {}",
            "```"
          ].join("\n"),
          [
            "#### \u53EF\u9009\u503C\uFF1A",
            "- pagination",
            "- servinfinite-scroll",
            "- no"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode",
            "- JHipster"
          ].join("\n")
        ]
      },
      Search: {
        completeItem: {
          label: {
            label: "Search",
            detail: "",
            description: "\u4F7F\u7528\u5168\u6587\u68C0\u7D22"
          },
          insertText: new vscode.SnippetString("Search(${1|elasticsearch, no |})${0}"),
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u4F7F\u7528\u5168\u6587\u68C0\u7D22",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @Search(elasticsearch)",
            " entity SysConfig {}",
            "```"
          ].join("\n"),
          [
            "#### \u53EF\u9009\u503C\uFF1A",
            "- elasticsearch",
            "- no"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode",
            "- JHipster"
          ].join("\n")
        ]
      },
      Microservice: {
        completeItem: {
          label: {
            label: "Microservice",
            detail: "",
            description: "\u6240\u5C5E\u5FAE\u670D\u52A1\u540D\u79F0"
          },
          insertText: new vscode.SnippetString("Microservice(${1})${0}"),
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u6240\u5C5E\u5FAE\u670D\u52A1\u540D\u79F0",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @Microservice(system)",
            " entity SysConfig {}",
            "```"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode",
            "- JHipster"
          ].join("\n")
        ]
      },
      PublicApiBy: {
        completeItem: {
          label: {
            label: "PublicApiBy",
            detail: "",
            description: "\u516C\u5F00\u8BBF\u95EEAPI\u53CA\u6761\u4EF6"
          },
          insertText: new vscode.SnippetString("PublicApiBy(${1})${0}"),
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u516C\u5F00\u8BBF\u95EEAPI\u53CA\u6761\u4EF6",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @PublicApiBy(open==true)",
            " entity SysConfig {}",
            "```",
            "**\u6CE8\u610F\uFF1A**: \u4EC5\u652F\u6301\u7B80\u5355\u7684\u6761\u4EF6\u8868\u8FBE\u5F0F",
            `'!=', '>=', '<=', '==', '<>', '>', '<'`
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode"
          ].join("\n")
        ]
      },
      SkipDbChangelog: {
        completeItem: {
          label: {
            label: "SkipDbChangelog",
            detail: "",
            description: "\u5FFD\u7565Liquidbase\u7684Changlog"
          },
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u5FFD\u7565Liquidbase\u7684Changlog\u6587\u4EF6",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @SkipDbChangelog",
            " entity SysConfig {}",
            "```",
            "**\u6CE8\u610F\uFF1A**: \u5DF2\u7ECF\u5177\u6709\u8868\u7ED3\u6784\u60C5\u51B5\u4E0B\u4F7F\u7528"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode"
          ].join("\n")
        ]
      },
      HasImageField: {
        completeItem: {
          label: {
            label: "HasImageField",
            detail: "",
            description: "\u5B9E\u4F53\u4E2D\u6709\u56FE\u7247\u5B57\u6BB5"
          },
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u5B9E\u4F53\u4E2D\u6709\u56FE\u7247\u5B57\u6BB5",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @HasImageField",
            " entity SysConfig {}",
            "```",
            "**\u6CE8\u610F\uFF1A**: \u4EC5\u7528\u5728User\u5B9E\u4F53"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode"
          ].join("\n")
        ]
      },
      SkipSoftDelete: {
        completeItem: {
          label: {
            label: "SkipSoftDelete",
            detail: "",
            description: "\u5FFD\u7565\u903B\u8F91\u5220\u9664"
          },
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u5FFD\u7565\u903B\u8F91\u5220\u9664",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @SkipSoftDelete",
            " entity SysConfig {}",
            "```",
            "**\u6CE8\u610F\uFF1A**: \u4EC5\u5728\u7CFB\u7EDF\u542F\u7528\u903B\u8F91\u5220\u9664\u65F6\u6709\u6548"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode"
          ].join("\n")
        ]
      },
      ImportDataFile: {
        completeItem: {
          label: {
            label: "ImportDataFile",
            detail: "",
            description: "\u5BFC\u5165\u6570\u636E\u7684\u6587\u4EF6"
          },
          insertText: new vscode.SnippetString("ImportDataFile(${1})${0}"),
          kind: vscode.CompletionItemKind.Operator
        },
        "contents": [
          "\u5BFC\u5165\u6570\u636E\u7684\u6587\u4EF6",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @ImportDataFile(jhi_authority-rel_jhi_authority__view_permissions)",
            " entity SysConfig {}",
            "```"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode"
          ].join("\n")
        ]
      },
      AddCustomMethod: {
        completeItem: {
          label: {
            label: "AddCustomMethod",
            detail: "",
            description: "\u5728\u6307\u5B9A\u4EE3\u7801\u4E2D\u589E\u52A0\u81EA\u5B9A\u4E49\u65B9\u6CD5"
          },
          insertText: new vscode.SnippetString("AddCustomMethod(${1|repository, service, rest, clientService, queryService, updateComponent, listComponent, clientRoute, editComponent, dto, listRelation, detailTemplate|})${0}"),
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u5728\u6307\u5B9A\u4EE3\u7801\u4E2D\u589E\u52A0\u81EA\u5B9A\u4E49\u65B9\u6CD5",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @AddCustomMethod(repository-service)",
            " entity SysConfig {}",
            "```",
            "**\u6CE8\u610F\uFF1A**: \u84DD\u56FE\u4E2D\u4F7F\u7528, -\u5206\u9694"
          ].join("\n"),
          [
            "#### \u53EF\u9009\u503C\uFF1A",
            "- repository",
            "- service",
            "- rest",
            "- no",
            "- clientService",
            "- queryService",
            "- updateComponent",
            "- listComponent",
            "- clientRoute",
            "- \u66F4\u591A\u8BF7\u53C2\u8003\u6587\u6863"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode"
          ].join("\n")
        ]
      },
      UpdateById: {
        completeItem: {
          label: {
            label: "UpdateById",
            detail: "",
            description: "\u589E\u52A0updateXXXById\u65B9\u6CD5"
          },
          insertText: new vscode.SnippetString("@Update${1}ById(${2})${0}"),
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u589E\u52A0updateXXXById\u65B9\u6CD5",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @UpdateAgeById(age)",
            " entity SysConfig {}",
            "```",
            "**\u6CE8\u610F\uFF1A**: \u5185\u5BB9\u4E3A\u66F4\u65B0\u7684\u5B57\u6BB5\u5217\u8868\uFF0C\u4F7F\u7528-\u5206\u9694"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode"
          ].join("\n")
        ]
      },
      UpdateBy: {
        completeItem: {
          label: {
            label: "UpdateBy",
            detail: "",
            description: "\u589E\u52A0updateXXXByYYY\u65B9\u6CD5"
          },
          insertText: new vscode.SnippetString('@Update${1}By${2}("${3},${4}")${0}'),
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u589E\u52A0updateByXXX\u65B9\u6CD5",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            ' @UpdateAgeByName("name, age")',
            " entity SysConfig {}",
            "```",
            "**\u6CE8\u610F\uFF1A**: \u524D\u90E8\u5206\u53C2\u6570\u4E3A\u66F4\u65B0\u6761\u4EF6\uFF0C\u540E\u90E8\u5206\u53C2\u6570\u4E3A\u66F4\u65B0\u5B57\u6BB5\uFF0C\u591A\u4E2A\u5B57\u6BB5\u4F7F\u7528-\u5206\u9694"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode"
          ].join("\n")
        ]
      },
      RemoveBy: {
        completeItem: {
          label: {
            label: "RemoveBy",
            detail: "",
            description: "\u589E\u52A0removeByXXX\u65B9\u6CD5"
          },
          insertText: new vscode.SnippetString("@RemoveBy${1}(${2})${0}"),
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u589E\u52A0removeByXXX\u65B9\u6CD5",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @RemoveByName(name-disabled)",
            " entity SysConfig {}",
            "```",
            "**\u6CE8\u610F\uFF1A**: \u591A\u4E2A\u5B57\u6BB5\u4F7F\u7528-\u5206\u9694"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode"
          ].join("\n")
        ]
      },
      SaveWith: {
        completeItem: {
          label: {
            label: "SaveWith",
            detail: "",
            description: "\u589E\u52A0saveWithXXX\u65B9\u6CD5"
          },
          insertText: new vscode.SnippetString("@SaveWith${1}(${2})${0}"),
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u589E\u52A0saveWithXXX\u65B9\u6CD5",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @SaveWithName(name-disabled-label)",
            " entity SysConfig {}",
            "```",
            "**\u6CE8\u610F\uFF1A**: \u591A\u4E2A\u5B57\u6BB5\u4F7F\u7528-\u5206\u9694"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode"
          ].join("\n")
        ]
      },
      EntityDomainLayer: {
        completeItem: {
          label: {
            label: "EntityDomainLayer",
            detail: "",
            description: "\u751F\u6210Demain\u5C42\u6587\u4EF6"
          },
          insertText: new vscode.SnippetString("@EntityDomainLayer(${1|true, false|})${0}"),
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u751F\u6210Demain\u5C42\u6587\u4EF6",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @EntityDomainLayer(false)",
            " entity SysConfig {}",
            "```"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode",
            "- JHipster"
          ].join("\n")
        ]
      },
      EntityPersistenceLayer: {
        completeItem: {
          label: {
            label: "EntityPersistenceLayer",
            detail: "",
            description: "\u751F\u6210Persistence\u5C42\u6587\u4EF6"
          },
          insertText: new vscode.SnippetString("@EntityPersistenceLayer(${1|true, false|})${0}"),
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u751F\u6210Persistence\u5C42\u6587\u4EF6",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @EntityPersistenceLayer(false)",
            " entity SysConfig {}",
            "```"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode",
            "- JHipster"
          ].join("\n")
        ]
      },
      RestLayer: {
        completeItem: {
          label: {
            label: "RestLayer",
            detail: "",
            description: "\u751F\u6210Rest\u5C42\u6587\u4EF6"
          },
          insertText: new vscode.SnippetString("@RestLayer(${1|true, false|})${0}"),
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u751F\u6210Rest\u5C42\u6587\u4EF6",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @RestLayer(false)",
            " entity SysConfig {}",
            "```"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode",
            "- JHipster"
          ].join("\n")
        ]
      },
      EntitySpringPreAuthorize: {
        completeItem: {
          label: {
            label: "RestLayer",
            detail: "",
            description: "\u589E\u52A0\u6743\u9650\u6CE8\u89E3"
          },
          insertText: new vscode.SnippetString('@EntitySpringPreAuthorize("${1}")${0}'),
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u589E\u52A0\u6743\u9650\u6CE8\u89E3",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            ` @EntitySpringPreAuthorize("hasAuthority('ROLE_CUSTOM')")`,
            " entity SysConfig {}",
            "```"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode",
            "- JHipster"
          ].join("\n")
        ]
      },
      EntitySpringReadPreAuthorize: {
        completeItem: {
          label: {
            label: "EntitySpringReadPreAuthorize",
            detail: "",
            description: "\u589E\u52A0Read\u6743\u9650\u6CE8\u89E3"
          },
          insertText: new vscode.SnippetString('@EntitySpringReadPreAuthorize("${1}")${0}'),
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u589E\u52A0Read\u6743\u9650\u6CE8\u89E3",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            ` @EntitySpringReadPreAuthorize("hasAuthority('ROLE_CUSTOM_READ')")`,
            " entity SysConfig {}",
            "```"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode",
            "- JHipster"
          ].join("\n")
        ]
      },
      EntitySearchLayer: {
        completeItem: {
          label: {
            label: "EntitySearchLayer",
            detail: "",
            description: "\u751F\u6210\u5168\u6587\u68C0\u7D22\u5C42\u6587\u4EF6"
          },
          insertText: new vscode.SnippetString('@EntitySearchLayer("${1|true, false|}")${0}'),
          kind: vscode.CompletionItemKind.Operator
        },
        contents: [
          "\u751F\u6210\u5168\u6587\u68C0\u7D22\u5C42\u6587\u4EF6",
          [
            "#### \u4F7F\u7528\u65B9\u6CD5:",
            "```java",
            " @EntitySearchLayer(true)",
            " entity SysConfig {}",
            "```"
          ].join("\n"),
          [
            "#### \u9002\u7528\u8303\u56F4\uFF1A",
            "- BegCode",
            "- JHipster"
          ].join("\n")
        ]
      }
    },
    field: {
      anno: {
        EndUsed: {
          completeItem: {
            label: {
              label: "EndUsed",
              detail: "",
              description: "\u8BBE\u7F6E\u5B57\u6BB5\u7684\u524D\u7AEF\u7EC4\u4EF6"
            },
            insertText: new vscode.SnippetString("EndUsed(${1|fileUrl, iconPicker, imageUrl, videoUrl, audioUrl, editor, codeEditor, select, modalSelect, checkbox, radio, radioButton, rate, slider, switch, textArea, avatar |})${0}"),
            kind: vscode.CompletionItemKind.Operator
          },
          contents: [
            "\u8BBE\u7F6E\u5B57\u6BB5\u7684\u524D\u7AEF\u7EC4\u4EF6",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " @EndUsed(editor)",
              " content TextBlob",
              "```"
            ].join("\n"),
            [
              "#### \u53EF\u9009\u503C\uFF1A",
              "- editor",
              "- select",
              "- checkbox",
              "- radio",
              "- radio",
              "- textArea",
              "- \u66F4\u591A\u8BF7\u53C2\u8003\u6587\u6863"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode"
            ].join("\n")
          ]
        },
        FieldConfig: {
          completeItem: {
            label: {
              label: "FieldConfig",
              detail: "",
              description: "\u589E\u52A0\u5B57\u6BB5\u914D\u7F6E"
            },
            insertText: new vscode.SnippetString("FieldConfig(${1}|hideInForm, hideInList, editInList, searchForm, hideInDetail, filter, sortable |)${0}"),
            kind: vscode.CompletionItemKind.Operator
          },
          contents: [
            "\u589E\u52A0\u5B57\u6BB5\u914D\u7F6E",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " @FieldConfig(searchForm)",
              " name String",
              "```"
            ].join("\n"),
            [
              "#### \u53EF\u9009\u503C\uFF1A",
              "- hideInForm",
              "- hideInList",
              "- editInList",
              "- searchForm",
              "- hideInDetail",
              "- filter",
              "- sortable",
              "**\u6CE8\u610F\uFF1A**: \u591A\u4E2A\u4F7F\u7528-\u5206\u9694"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode"
            ].join("\n")
          ],
          value: {
            hideInForm: {
              "contents": [
                "\u5728\u8868\u5355\u4E2D\u9690\u85CF",
                [
                  "#### \u4F7F\u7528\u65B9\u6CD5:",
                  "```java",
                  " @FieldConfig(hideInForm)",
                  " name String",
                  "```"
                ].join("\n"),
                [
                  "#### \u9002\u7528\u8303\u56F4\uFF1A",
                  "- BegCode"
                ].join("\n")
              ]
            }
          }
        },
        ShowBy: {
          completeItem: {
            label: {
              label: "ShowBy",
              detail: "",
              description: "\u5B57\u6BB5\u5728\u8868\u5355\u663E\u793A\u7684\u6761\u4EF6"
            },
            insertText: new vscode.SnippetString("ShowBy(${1})${0}"),
            kind: vscode.CompletionItemKind.Operator
          },
          contents: [
            "\u5B57\u6BB5\u5728\u8868\u5355\u663E\u793A\u7684\u6761\u4EF6",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " @ShowBy(disabled==true)",
              " name String",
              "```",
              "**\u6CE8\u610F\uFF1A**: \u4EC5\u652F\u6301\u7B80\u5355\u7684\u6761\u4EF6\u8868\u8FBE\u5F0F",
              `'!=', '>=', '<=', '==', '<>', '>', '<'`
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode"
            ].join("\n")
          ]
        },
        DefaultValue: {
          completeItem: {
            label: {
              label: "DefaultValue",
              detail: "",
              description: "\u5B57\u6BB5\u9ED8\u8BA4\u503C"
            },
            insertText: new vscode.SnippetString("DefaultValue(${1})${0}"),
            kind: vscode.CompletionItemKind.Operator
          },
          contents: [
            "\u5B57\u6BB5\u9ED8\u8BA4\u503C",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              ' @DefaultValue("abc")',
              " name String",
              "```",
              "**\u6CE8\u610F\uFF1A**: \u6D89\u53CA\u7279\u6B8A\u5B57\u7B26\u65F6\u9700\u8981\u4F7F\u7528\u53CC\u5F15\u53F7"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        SortField: {
          completeItem: {
            label: {
              label: "SortField",
              detail: "",
              description: "\u6392\u5E8F\u5B57\u6BB5"
            },
            insertText: new vscode.SnippetString("SortField(${1|asc, desc|})${0}"),
            kind: vscode.CompletionItemKind.Operator
          },
          contents: [
            "\u6392\u5E8F\u5B57\u6BB5",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              ' @SortField("asc")',
              " name String",
              "```"
            ].join("\n"),
            [
              "#### \u53EF\u9009\u503C\uFF1A",
              "- asc",
              "- desc"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode"
            ].join("\n")
          ]
        },
        ColumnWidth: {
          completeItem: {
            label: {
              label: "ColumnWidth",
              detail: "",
              description: "\u8868\u683C\u5217\u5BBD"
            },
            insertText: new vscode.SnippetString("ColumnWidth(${1})${0}"),
            kind: vscode.CompletionItemKind.Operator
          },
          contents: [
            "\u8868\u683C\u5217\u5BBD",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " @ColumnWidth(120)",
              " name String",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode"
            ].join("\n")
          ]
        },
        FieldColumnName: {
          completeItem: {
            label: {
              label: "FieldColumnName",
              detail: "",
              description: "\u6570\u636E\u8868\u5217\u540D"
            },
            insertText: new vscode.SnippetString("FieldColumnName(${1})${0}"),
            kind: vscode.CompletionItemKind.Operator
          },
          contents: [
            "\u6570\u636E\u8868\u5217\u540D",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              ' @FieldColumnName("user_name")',
              " name String",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode"
            ].join("\n")
          ]
        },
        SkipDto: {
          completeItem: {
            label: {
              label: "SkipDto",
              detail: "",
              description: "DTO\u4E2D\u5FFD\u7565\u8BE5\u5B57\u6BB5"
            },
            kind: vscode.CompletionItemKind.Operator
          },
          contents: [
            "DTO\u4E2D\u5FFD\u7565\u8BE5\u5B57\u6BB5",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " @SkipDto",
              " name String",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode"
            ].join("\n")
          ]
        },
        SkipCriteria: {
          completeItem: {
            label: {
              label: "SkipCriteria",
              detail: "",
              description: "Criteria\u6761\u4EF6\u7C7B\u4E2D\u5FFD\u7565\u8BE5\u5B57\u6BB5"
            },
            kind: vscode.CompletionItemKind.Operator
          },
          contents: [
            "Criteria\u6761\u4EF6\u7C7B\u4E2D\u5FFD\u7565\u8BE5\u5B57\u6BB5",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " @SkipCriteria",
              " name String",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode"
            ].join("\n")
          ]
        },
        ImportDataField: {
          completeItem: {
            label: {
              label: "ImportDataField",
              detail: "",
              description: "Liqiudbase\u5BFC\u5165\u5B57\u6BB5"
            },
            kind: vscode.CompletionItemKind.Operator
          },
          contents: [
            "Liqiudbase\u5BFC\u5165\u5B57\u6BB5",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " @ImportDataField",
              " name String",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode"
            ].join("\n")
          ]
        },
        EditInContainer: {
          completeItem: {
            label: {
              label: "EditInContainer",
              detail: "",
              description: "\u7F16\u8F91\u8868\u5355\u5BB9\u5668"
            },
            insertText: new vscode.SnippetString("EditInContainer(${1|modal, page, drawer|})${0}"),
            kind: vscode.CompletionItemKind.Operator
          },
          "contents": [
            "\u7F16\u8F91\u8868\u5355\u5BB9\u5668",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " @EditInContainer(drawer)",
              " name String",
              "```"
            ].join("\n"),
            [
              "#### \u53EF\u9009\u503C\uFF1A",
              "- drawer",
              "- modal",
              "- page"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode"
            ].join("\n")
          ]
        }
      },
      type: {
        Integer: {
          contents: [
            "\u6574\u6570\u7C7B\u578B",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " age Integer",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        String: {
          contents: [
            "\u5B57\u7B26\u4E32\u7C7B\u578B",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " name String",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        Long: {
          contents: [
            "\u957F\u6574\u6570\u7C7B\u578B",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " age Long",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        Boolean: {
          contents: [
            "\u5E03\u5C14\u7C7B\u578B",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " deleted Boolean",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        Float: {
          contents: [
            "\u6D6E\u70B9\u7C7B\u578B",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " price Float",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        Double: {
          contents: [
            "\u53CC\u7CBE\u5EA6\u7C7B\u578B",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " price Double",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        LocalDate: {
          contents: [
            "\u65E5\u671F\u7C7B\u578B",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " birthday LocalDate",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        BigDecimal: {
          contents: [
            "\u5927\u6570\u5B57\u7C7B\u578B",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " price BigDecimal",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        ZonedDateTime: {
          contents: [
            "\u65E5\u671F\u65F6\u95F4\u7C7B\u578B",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " createTime ZonedDateTime",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        Instant: {
          contents: [
            "\u65F6\u95F4\u6233\u7C7B\u578B",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " createTime Instant",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        Duration: {
          contents: [
            "\u6301\u7EED\u65F6\u95F4\u7C7B\u578B",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " duration Duration",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        UUID: {
          contents: [
            "UUID\u7C7B\u578B",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " uuid UUID",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        Blob: {
          contents: [
            "\u4E8C\u8FDB\u5236\u7C7B\u578B",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " image Blob",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        AnyBlob: {
          contents: [
            "\u4EFB\u610F\u4E8C\u8FDB\u5236\u7C7B\u578B",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " image AnyBlob",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        ImageBlob: {
          contents: [
            "\u56FE\u7247\u4E8C\u8FDB\u5236\u7C7B\u578B",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " image ImageBlob",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        TextBlob: {
          contents: [
            "\u957F\u6587\u672C\u7C7B\u578B",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " content TextBlob",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        }
      },
      validation: {
        required: {
          completeItem: {
            label: {
              label: "required",
              "detail": "",
              "description": "\u975E\u7A7A"
            },
            kind: vscode.CompletionItemKind.Operator,
            scope: ["String", "Integer", "Long", "BigDecimal", "Float", "Double", "Enum", "Boolean", "LocalDate", "ZonedDateTime", "Instant", "Duration", "UUID", "Blob", "AnyBlob", "ImageBlob", "TextBlob"]
          },
          contents: [
            "\u5B57\u6BB5\u975E\u7A7A\u6821\u9A8C",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " name String required",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        minlength: {
          completeItem: {
            label: {
              label: "minlength",
              "detail": "",
              "description": "\u6700\u5C0F\u957F\u5EA6"
            },
            insertText: new vscode.SnippetString("minlength(${1})${0}"),
            kind: vscode.CompletionItemKind.Operator,
            scope: ["String"]
          },
          contents: [
            "\u6700\u5C0F\u957F\u5EA6\u6821\u9A8C",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " name String minlength(5)",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        maxlength: {
          completeItem: {
            label: {
              label: "maxlength",
              "detail": "",
              "description": "\u6700\u5927\u957F\u5EA6"
            },
            insertText: new vscode.SnippetString("maxlength(${1})${0}"),
            kind: vscode.CompletionItemKind.Operator,
            scope: ["String"]
          },
          contents: [
            "\u6700\u5927\u957F\u5EA6\u6821\u9A8C",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " name String maxlength(10)",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        pattern: {
          completeItem: {
            label: {
              label: "pattern",
              "detail": "",
              "description": "\u6B63\u5219\u8868\u8FBE\u5F0F\u6821\u9A8C"
            },
            insertText: new vscode.SnippetString("pattern(/${1}/)${0}"),
            kind: vscode.CompletionItemKind.Operator,
            scope: ["String"]
          },
          contents: [
            "\u6B63\u5219\u8868\u8FBE\u5F0F\u6821\u9A8C",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              ' name String pattern("[a-zA-Z]+")',
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        unique: {
          completeItem: {
            label: {
              label: "unique",
              "detail": "",
              "description": "\u552F\u4E00\u6027"
            },
            kind: vscode.CompletionItemKind.Operator,
            scope: ["String", "Integer", "Long", "BigDecimal", "Float", "Double", "Enum", "Boolean", "LocalDate", "ZonedDateTime", "Instant", "Duration", "UUID", "Blob", "AnyBlob", "ImageBlob", "TextBlob"]
          },
          contents: [
            "\u552F\u4E00\u6027\u6821\u9A8C",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " name String unique",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        min: {
          completeItem: {
            label: {
              label: "min",
              "detail": "",
              "description": "\u6700\u5C0F\u503C"
            },
            insertText: new vscode.SnippetString("min(${1})${0}"),
            kind: vscode.CompletionItemKind.Operator,
            scope: ["Integer", "Long", "BigDecimal", "Float", "Double"]
          },
          contents: [
            "\u6700\u5C0F\u503C\u6821\u9A8C",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " age Integer min(18)",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        max: {
          completeItem: {
            label: {
              label: "max",
              "detail": "",
              "description": "\u6700\u5927\u503C"
            },
            insertText: new vscode.SnippetString("max(${1})${0}"),
            kind: vscode.CompletionItemKind.Operator,
            scope: ["Integer", "Long", "BigDecimal", "Float", "Double"]
          },
          contents: [
            "\u6700\u5927\u503C\u6821\u9A8C",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " age Integer max(100)",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        minbytes: {
          completeItem: {
            label: {
              label: "minbytes",
              "detail": "",
              "description": "\u6700\u5C0F\u5B57\u8282\u957F\u5EA6"
            },
            insertText: new vscode.SnippetString("minbytes(${1})${0}"),
            kind: vscode.CompletionItemKind.Operator,
            scope: ["Blob", "AnyBlob", "ImageBlob"]
          },
          contents: [
            "\u6700\u5C0F\u5B57\u8282\u957F\u5EA6\u6821\u9A8C",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " name String minbytes(5)",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        },
        maxbytes: {
          completeItem: {
            label: {
              label: "maxbytes",
              "detail": "",
              "description": "\u6700\u5927\u5B57\u8282\u957F\u5EA6"
            },
            insertText: new vscode.SnippetString("maxbytes(${1})${0}"),
            kind: vscode.CompletionItemKind.Operator,
            scope: ["Blob", "AnyBlob", "ImageBlob"]
          },
          contents: [
            "\u6700\u5927\u5B57\u8282\u957F\u5EA6\u6821\u9A8C",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " name String maxbytes(10)",
              "```"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode",
              "- JHipster"
            ].join("\n")
          ]
        }
      }
    }
  },
  relationship: {
    from: {
      anno: {
        AnnotationOnSource: {
          completeItem: {
            label: {
              label: "AnnotationOnSource",
              detail: "",
              description: "\u5173\u8054\u5173\u7CFB\u5DE6\u4FA7\u6CE8\u89E3"
            },
            insertText: new vscode.SnippetString("AnnotationOnSource(${1|relateByIdEntity, unidirectional, editInForm, editBySelect, editByFormList, editByList, editInList, detailInList, editByTable, countByPrimaryKey, editBySelectModal, editBySelectDrawer, editByTableModal, editByTableDrawer, importData, hideInList|})${0}"),
            kind: vscode.CompletionItemKind.Operator
          },
          contents: [
            "\u5173\u8054\u5173\u7CFB\u5DE6\u4FA7\u6CE8\u89E3",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " @AnnotationOnSource(hideInList)",
              " SysConfig{user}",
              " to",
              " User",
              "```",
              "**\u6CE8\u610F\uFF1A**: \u591A\u4E2A\u4F7F\u7528-\u5206\u9694"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode"
            ].join("\n")
          ]
        }
      }
    },
    to: {
      anno: {
        AnnotationOnDestination: {
          completeItem: {
            label: {
              label: "AnnotationOnDestination",
              detail: "",
              description: "\u5173\u8054\u5173\u7CFB\u53F3\u4FA7\u6CE8\u89E3"
            },
            insertText: new vscode.SnippetString("AnnotationOnDestination(${1|hideInList, editByTableDrawer, editByTableModal, editBySelectDrawer, editBySelectModal, detailInList, editInList|})${0}"),
            kind: vscode.CompletionItemKind.Operator
          },
          contents: [
            "\u5173\u8054\u5173\u7CFB\u53F3\u4FA7\u6CE8\u89E3",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " SysConfig{user}",
              " to",
              " @AnnotationOnDestination(hideInList)",
              " User",
              "```",
              "**\u6CE8\u610F\uFF1A**: \u591A\u4E2A\u4F7F\u7528-\u5206\u9694"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode"
            ].join("\n")
          ]
        },
        OnDelete: {
          completeItem: {
            label: {
              label: "OnDelete",
              detail: "",
              description: "\u7EA7\u8054\u5220\u9664\u5904\u7406\u65B9\u5F0F"
            },
            insertText: new vscode.SnippetString("OnDelete(${1|NO ACTION, RESTRICT, CASCADE, SET NULL, SET DEFAULT |})${0}"),
            kind: vscode.CompletionItemKind.Operator
          },
          contents: [
            "\u7EA7\u8054\u5220\u9664\u5904\u7406\u65B9\u5F0F",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " SysConfig{user}",
              " to",
              ' @OnDelete("SET NULL")',
              " User",
              "```",
              "**\u6CE8\u610F\uFF1A**: \u591A\u4E2A\u4F7F\u7528-\u5206\u9694"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode"
            ].join("\n")
          ]
        },
        OnUpdate: {
          completeItem: {
            label: {
              label: "OnUpdate",
              detail: "",
              description: "\u7EA7\u8054\u66F4\u65B0\u5904\u7406\u65B9\u5F0F"
            },
            insertText: new vscode.SnippetString("OnUpdate(${1|NO ACTION, RESTRICT, CASCADE, SET NULL, SET DEFAULT |})${0}"),
            kind: vscode.CompletionItemKind.Operator
          },
          contents: [
            "\u7EA7\u8054\u66F4\u65B0\u5904\u7406\u65B9\u5F0F",
            [
              "#### \u4F7F\u7528\u65B9\u6CD5:",
              "```java",
              " SysConfig{user}",
              " to",
              ' @OnUpdate("SET NULL")',
              " User",
              "```",
              "**\u6CE8\u610F\uFF1A**: \u591A\u4E2A\u4F7F\u7528-\u5206\u9694"
            ].join("\n"),
            [
              "#### \u9002\u7528\u8303\u56F4\uFF1A",
              "- BegCode"
            ].join("\n")
          ]
        }
      }
    },
    ManyToOne: {
      contents: [
        "\u591A\u5BF9\u4E00\u5173\u8054"
      ]
    },
    OneToMany: {
      contents: [
        "\u4E00\u5BF9\u591A\u5173\u8054"
      ]
    },
    ManyToMany: {
      contents: [
        "\u591A\u5BF9\u591A\u5173\u8054"
      ]
    },
    OneToOne: {
      contents: [
        "\u4E00\u5BF9\u4E00\u5173\u8054"
      ]
    }
  }
};
function tokenLableHover(tokenLabel3, jdlObject4) {
  if (tokenLabel3) {
    const labels = tokenLabel3.split("=>");
    if (tokenLabel3.startsWith("relationship:")) {
      (0, import_console.log)("tokenLabel.relationship", tokenLabel3);
      if (labels.length === 4 && labels[labels.length - 1].startsWith("injectedFieldParam:")) {
        const entity = labels[2].split(":")[1];
        const field = labels[3].split(":")[1];
        if (jdlObject4 && jdlObject4.entities) {
          const entityObj = jdlObject4.entities.find((entityObj2) => entityObj2.name === entity);
          if (entityObj && entityObj.body) {
            const fieldObj = entityObj.body.find((fieldObj2) => fieldObj2.name === field);
            if (fieldObj && fieldObj.documentation) {
              return [
                `${entity}.${field}`,
                [`\u7C7B\u578B\uFF1A${fieldObj.type}`, `\u5907\u6CE8\uFF1A${fieldObj.documentation || ""}`].join("\n")
              ];
            } else {
              return [];
            }
          } else {
            return [];
          }
        } else {
          return [];
        }
      } else if (labels.length === 2 && (labels[labels.length - 1].startsWith("to:") || labels[labels.length - 1].startsWith("from:"))) {
        const entity = labels[1].split(":")[1];
        if (jdlObject4 && jdlObject4.entities) {
          const entityObj = jdlObject4.entities.find((entityObj2) => entityObj2.name === entity);
          if (entityObj.documentation) {
            return [
              entityObj.documentation
            ];
          }
        }
        return [];
      } else {
        return [];
      }
    }
    const labelPath = labels.reduce((prev, current, index, arr) => {
      if (index === arr.length - 1 && index > 0) {
        return prev + "." + current.replace(":", ".");
      } else if (index === arr.length - 2 && index > 0 && current.startsWith("anno:")) {
        return prev + "." + current.replace(":", ".");
      } else {
        return (prev ? prev + "." : "") + current.split(":")[0];
      }
    }, "");
    return (0, import_lodash.get)(hoverData, labelPath + ".contents", []);
  }
  return [];
}
function tokenLableComplete(tokenLabel3, jdlObject4) {
  if (tokenLabel3) {
    const labels = tokenLabel3.split("=>");
    const typeChain = labels.map((label) => label.split(":")[0]).join(".");
    if (typeChain === "entity.field.type") {
      const validationPath = "entity.field.validation";
      const typeName = [...labels].pop()?.split(":")[1];
      const validationObject = (0, import_lodash.get)(hoverData, validationPath, {});
      const completeItems = [];
      Object.keys(validationObject).forEach((key) => {
        if (validationObject[key]?.completeItem?.scope?.includes(typeName)) {
          completeItems.push(validationObject[key].completeItem);
        }
      });
      return completeItems;
    }
    if (typeChain === "entity.field.validation") {
      const validationPath = "entity.field.validation";
      if (jdlObject4?.entities) {
        const entityName = labels[0].split(":")[1];
        const fieldName = labels[1].split(":")[1];
        const entity = jdlObject4?.entities.find((entity2) => entity2.name === entityName);
        if (entity?.body) {
          const field = entity?.body?.find((field2) => field2.name === fieldName);
          if (field) {
            const existValidations = field.validations?.map((valid) => valid.key) || [];
            const fieldType = field.type;
            const validationObject = (0, import_lodash.get)(hoverData, validationPath, {});
            const completeItems = [];
            Object.keys(validationObject).filter((key) => !existValidations.includes(key)).forEach((key) => {
              if (validationObject[key]?.completeItem?.scope?.includes(fieldType)) {
                completeItems.push(validationObject[key].completeItem);
              }
            });
            return completeItems;
          }
        }
      }
    }
    if (typeChain === "entity.field.validation.value") {
      const validationPath = "entity.field.validation";
      if (jdlObject4?.entities) {
        const entityName = labels[0].split(":")[1];
        const fieldName = labels[1].split(":")[1];
        const entity = jdlObject4?.entities.find((entity2) => entity2.name === entityName);
        if (entity?.body) {
          const field = entity?.body?.find((field2) => field2.name === fieldName);
          if (field) {
            const existValidations = field.validations?.map((valid) => valid.key) || [];
            const fieldType = field.type;
            const validationObject = (0, import_lodash.get)(hoverData, validationPath, {});
            const completeItems = [];
            Object.keys(validationObject).filter((key) => !existValidations.includes(key)).forEach((key) => {
              if (validationObject[key]?.completeItem?.scope?.includes(fieldType)) {
                completeItems.push(validationObject[key].completeItem);
              }
            });
            return completeItems;
          }
        }
      }
    }
  }
  return [];
}

// src/parseJdl.ts
var import_console2 = require("console");
var import_lodash2 = __toESM(require_lodash());
var jdl;
async function getJdl() {
  if (!jdl) {
    jdl = await Promise.resolve().then(() => (init_jdl3(), jdl_exports));
  }
}
getJdl();
function parseJdl(text) {
  const lexResult = jdl.getLexResult(text);
  let jdlObject4 = null;
  const errors = [];
  const cstTokens2 = [];
  try {
    if (!lexResult.errors || lexResult.errors?.length === 0) {
      const parseResult = jdl.grammarParse(text);
      if (parseResult) {
        jdlObject4 = parseResult;
      }
    } else {
      errors.push(...lexResult.errors || []);
    }
  } catch (error) {
    (0, import_console2.log)("error:", error);
  }
  if (lexResult.children) {
    cstTokens2.length = 0;
    Object.keys(lexResult.children).forEach((key) => {
      if (key === "binaryOptionDeclaration") {
        const binaryOptions = lexResult.children.binaryOptionDeclaration;
        binaryOptions.forEach((binaryOption) => {
          if (binaryOption.children?.BINARY_OPTION) {
            const binaryOptionLabel = "binaryOption:" + binaryOption.children.BINARY_OPTION[0].image;
            const binaryOptionData = { ...binaryOption.children.BINARY_OPTION[0], label: binaryOptionLabel };
            cstTokens2.push(binaryOptionData);
            binaryOption.children?.entityList?.forEach((entity) => {
              if (entity.children) {
                if (entity.children.WITH?.length > 0) {
                  const binaryOptionWithLabel = "=>with:" + entity.children.WITH[0].image;
                  const binaryOptionWithData = { ...entity.children.WITH[0], label: binaryOptionWithLabel };
                  cstTokens2.push(binaryOptionWithData);
                }
                entity.children?.NAME?.forEach((name) => {
                  const binaryOptionEntityNameLabel = binaryOptionLabel + "=>entity:" + name.image;
                  const binaryOptionEntityNameData = { ...name, label: binaryOptionEntityNameLabel };
                  cstTokens2.push(binaryOptionEntityNameData);
                });
                if (entity.children?.method[0]) {
                  const binaryOptionMethodLabel = binaryOptionLabel + "=>method:" + entity.children.method[0].image;
                  const binaryOptionMethodData = { ...entity.children.method[0], label: binaryOptionMethodLabel };
                  cstTokens2.push(binaryOptionMethodData);
                }
              }
            });
          }
        });
      }
      if (key === "entityDeclaration") {
        const entities3 = lexResult.children.entityDeclaration;
        entities3.forEach((entity) => {
          const keywordLabel = "keyword:entity=>entity:" + entity.children.NAME[0].image;
          const keywordData = { ...entity.children.ENTITY[0], label: keywordLabel };
          cstTokens2.push(keywordData);
          const label = "entity:" + entity.children.NAME[0].image;
          entity.children?.annotationDeclaration?.forEach((annotation) => {
            const annoLabel = label + "=>anno:" + (0, import_lodash2.upperFirst)(annotation.children.option[0].image);
            const data = { ...annotation.children.option[0], label: annoLabel };
            cstTokens2.push(data);
            if (annotation.children.value) {
              const valueLabel = annoLabel + "=>value:" + annotation.children.value[0].image;
              const valueData = { ...annotation.children.value[0], label: valueLabel };
              cstTokens2.push(valueData);
            }
          });
          entity.children?.entityBody?.forEach((entityBody) => {
            entityBody?.children?.fieldDeclaration?.forEach((field) => {
              const fieldLabel = label + "=>field:" + field.children.NAME[0].image;
              const fieldData = { ...field.children.NAME[0], label: fieldLabel };
              cstTokens2.push(fieldData);
              const fieldTypeLabel = fieldLabel + "=>type:" + field.children.type[0].children.NAME[0].image;
              const fieldTypeData = { ...field.children.type[0].children.NAME[0], label: fieldTypeLabel };
              cstTokens2.push(fieldTypeData);
              field.children?.annotationDeclaration?.forEach((annotation) => {
                const annoLabel = fieldLabel + "=>anno:" + (0, import_lodash2.upperFirst)(annotation.children.option[0].image);
                const data = { ...annotation.children.option[0], label: annoLabel };
                cstTokens2.push(data);
                if (annotation.children.value) {
                  const valueLabel = annoLabel + "=>value:" + annotation.children.value[0].image;
                  const valueData = { ...annotation.children.value[0], label: valueLabel };
                  cstTokens2.push(valueData);
                }
              });
              field.children?.validation?.forEach((validation) => {
                if (validation.children?.REQUIRED) {
                  const validationLabel = fieldLabel + "=>validation:" + validation.children?.REQUIRED[0].image;
                  const validationData = { ...validation.children?.REQUIRED[0], label: validationLabel };
                  cstTokens2.push(validationData);
                }
                if (validation.children?.UNIQUE) {
                  const validationLabel = fieldLabel + "=>validation:" + validation.children?.UNIQUE[0].image;
                  const validationData = { ...validation.children?.UNIQUE[0], label: validationLabel };
                  cstTokens2.push(validationData);
                }
                if (validation.children?.pattern) {
                  const validationLabel = fieldLabel + "=>validation:" + validation.children?.pattern[0].children.PATTERN[0].image;
                  const validationData = { ...validation.children?.pattern[0].children.PATTERN[0], label: validationLabel };
                  cstTokens2.push(validationData);
                  const validationValueLabel = validationLabel + "=>value:" + validation.children?.pattern[0].children?.REGEX[0].image;
                  const validationValueData = { ...validation.children?.pattern[0].children?.REGEX[0], label: validationValueLabel };
                  cstTokens2.push(validationValueData);
                }
                if (validation.children?.minMaxValidation) {
                  const validationLabel = fieldLabel + "=>validation:" + validation.children?.minMaxValidation[0].children?.MIN_MAX_KEYWORD[0].image;
                  const validationData = { ...validation.children?.minMaxValidation[0].children?.MIN_MAX_KEYWORD[0], label: validationLabel };
                  cstTokens2.push(validationData);
                  const validationValueLabel = validationLabel + "=>value:" + validation.children?.minMaxValidation[0].children?.INTEGER[0].image;
                  const validationValueData = { ...validation.children?.minMaxValidation[0].children?.INTEGER[0], label: validationValueLabel };
                  cstTokens2.push(validationValueData);
                }
              });
            });
          });
        });
      }
      if (key === "enumDeclaration") {
        const enums = lexResult.children.enumDeclaration;
        enums?.forEach((enumItem) => {
          if (enumItem.children) {
            const enumName = enumItem.children.NAME[0].image;
            const enumLabel = "enum:" + enumName;
            const enumData = { ...enumItem.children.NAME[0], label: enumLabel };
            cstTokens2.push(enumData);
            enumItem.children.enumPropList?.forEach((enumProp) => {
              enumProp.children?.enumProp?.forEach((prop) => {
                const propLabel = enumLabel + "=>prop:" + prop.children.enumPropKey[0].image;
                const propData = { ...prop.children.enumPropKey[0], label: propLabel };
                cstTokens2.push(propData);
                if (prop.children?.enumPropValue) {
                  const propValueLabel = propLabel + "=>value:" + prop.children.enumPropValue[0].image;
                  const propValueData = { ...prop.children.enumPropValue[0], label: propValueLabel };
                  cstTokens2.push(propValueData);
                }
                if (prop.children?.enumPropValueWithQuotes) {
                  const propValueLabel = propLabel + "=>value:" + prop.children.enumPropValueWithQuotes[0].image;
                  const propValueData = { ...prop.children.enumPropValueWithQuotes[0], label: propValueLabel };
                  cstTokens2.push(propValueData);
                }
              });
            });
          }
        });
      }
      if (key === "relationDeclaration") {
        const relationships = lexResult.children.relationDeclaration;
        relationships.forEach((relationship) => {
          if (relationship.children?.relationshipType && relationship.children?.relationshipType[0]?.children?.RELATIONSHIP_TYPE) {
            const relationshipLabel = "relationship:" + relationship.children.relationshipType[0].children.RELATIONSHIP_TYPE[0].image;
            const relationshipData = { ...relationship.children.relationshipType[0].children.RELATIONSHIP_TYPE[0], label: relationshipLabel };
            cstTokens2.push(relationshipData);
            relationship.children?.relationshipBody?.forEach((relationshipBody) => {
              if (relationshipBody.children && relationshipBody.children.from[0]?.children?.NAME && relationshipBody.children.to[0]?.children?.NAME) {
                const fromLabelOnly = "from:" + relationshipBody.children.from[0].children.NAME[0].image;
                const fromLabel = relationshipLabel + "=>" + fromLabelOnly;
                const fromData = { ...relationshipBody.children.from[0].children.NAME[0], label: fromLabel };
                cstTokens2.push(fromData);
                const toLabelOnly = "to:" + relationshipBody.children.to[0].children.NAME[0].image;
                const toLabel = relationshipLabel + "=>" + toLabelOnly;
                const toData = { ...relationshipBody.children.to[0].children.NAME[0], label: toLabel };
                cstTokens2.push(toData);
                const toKeywordOnly = "keyword:" + relationshipBody.children.TO[0].image;
                const toKeywordLabel = relationshipLabel + "=>" + toKeywordOnly;
                const toKeywordData = { ...relationshipBody.children.TO[0], label: toKeywordLabel };
                cstTokens2.push(toKeywordData);
                if (relationshipBody.children.from[0]?.children?.injectedField) {
                  const fromInjectedFieldLabel = fromLabel + "=>" + toLabelOnly + "=>injectedField:" + relationshipBody.children.from[0].children.injectedField[0].image;
                  const fromInjectedFieldData = { ...relationshipBody.children.from[0].children.injectedField[0], label: fromInjectedFieldLabel };
                  cstTokens2.push(fromInjectedFieldData);
                }
                if (relationshipBody.children.from[0]?.children?.injectedFieldParam) {
                  const fromInjectedFieldParamLabel = fromLabel + "=>" + toLabelOnly + "=>injectedFieldParam:" + relationshipBody.children.from[0].children.injectedFieldParam[0].image;
                  const fromInjectedFieldParamData = { ...relationshipBody.children.from[0].children.injectedFieldParam[0], label: fromInjectedFieldParamLabel };
                  cstTokens2.push(fromInjectedFieldParamData);
                }
                if (relationshipBody.children.to[0]?.children?.injectedField) {
                  const toInjectedFieldLabel = toLabel + "=>" + fromLabelOnly + "=>injectedField:" + relationshipBody.children.to[0].children.injectedField[0].image;
                  const toInjectedFieldData = { ...relationshipBody.children.to[0].children.injectedField[0], label: toInjectedFieldLabel };
                  cstTokens2.push(toInjectedFieldData);
                }
                if (relationshipBody.children.to[0]?.children?.injectedFieldParam) {
                  const toInjectedFieldParamLabel = toLabel + "=>" + fromLabelOnly + "=>injectedFieldParam:" + relationshipBody.children.to[0].children.injectedFieldParam[0].image;
                  const toInjectedFieldParamData = { ...relationshipBody.children.to[0].children.injectedFieldParam[0], label: toInjectedFieldParamLabel };
                  cstTokens2.push(toInjectedFieldParamData);
                }
              }
            });
          }
        });
      }
      if (key === "unaryOptionDeclaration") {
        const unaryOptions = lexResult.children.unaryOptionDeclaration;
        unaryOptions.forEach((unaryOption) => {
          if (unaryOption.children?.UNARY_OPTION) {
            const unaryOptionLabel = "unaryOption:" + unaryOption.children.UNARY_OPTION[0].image;
            const unaryOptionData = { ...unaryOption.children.UNARY_OPTION[0], label: unaryOptionLabel };
            cstTokens2.push(unaryOptionData);
            const defName = unaryOption.children.UNARY_OPTION[0].image + "Def";
            if (unaryOption.children[defName]) {
              const unaryOptionDef = unaryOption.children[defName][0];
              unaryOptionDef?.NAME?.forEach((name) => {
                const unaryOptionNameLabel = unaryOptionLabel + "=>name:" + name.image;
                const unaryOptionNameData = { ...name, label: unaryOptionNameLabel };
                cstTokens2.push(unaryOptionNameData);
              });
            }
          }
        });
      }
    });
  }
  return {
    jdlObject: jdlObject4,
    errors,
    cstTokens: cstTokens2,
    jdlCst: lexResult
  };
}

// src/completeItems.ts
var import_lodash3 = __toESM(require_lodash());
var annotationValueDetail = {
  AddCustomMethod: {
    repository: {
      "detail": "",
      "description": "\u5728DAO\u5C42\u589E\u52A0\u65B9\u6CD5"
    },
    service: {
      "detail": "",
      "description": "\u5728Service\u5C42\u589E\u52A0\u65B9\u6CD5"
    },
    rest: {
      "detail": "",
      "description": "\u5728REST\u5C42\u589E\u52A0\u65B9\u6CD5"
    },
    clientService: {
      "detail": "",
      "description": "\u5728\u524D\u7AEFAPI\u5C42\u589E\u52A0\u65B9\u6CD5"
    },
    queryService: {
      "detail": "",
      "description": "\u5728QueryService\u5C42\u589E\u52A0\u65B9\u6CD5"
    },
    updateComponent: {
      "detail": "",
      "description": "\u5728\u524D\u7AEFUpdate\u7EC4\u4EF6\u589E\u52A0\u4EE3\u7801"
    },
    listComponent: {
      "detail": "",
      "description": "\u5728\u524D\u7AEFList\u7EC4\u4EF6\u589E\u52A0\u4EE3\u7801"
    },
    clientRoute: {
      "detail": "",
      "description": "\u5728\u524D\u7AEFRouter\u589E\u52A0\u4EE3\u7801"
    },
    editComponent: {
      "detail": "",
      "description": "\u5728\u524D\u7AEFEdit\u7EC4\u4EF6\u589E\u52A0\u4EE3\u7801"
    },
    dto: {
      "detail": "",
      "description": "\u5728DTO\u5C42\u589E\u52A0\u4EE3\u7801"
    },
    listRelation: {
      "detail": "",
      "description": "\u5728\u524D\u7AEFRelationList\u4E2D\u589E\u52A0\u4EE3\u7801"
    },
    detailTemplate: {
      "detail": "",
      "description": "\u5728\u524D\u7AEFDetail\u7EC4\u4EF6\u4E2D\u589E\u52A0\u4EE3\u7801"
    }
  },
  SkipWebButton: {
    listAdd: {
      "detail": "",
      "description": "\u5728List\u4E2D\u53D6\u6D88Add\u6309\u94AE"
    },
    listModalEdit: {
      "detail": "",
      "description": "\u5728List\u4E2D\u53D6\u6D88Edit\u6309\u94AE"
    },
    listEdit: {
      "detail": "",
      "description": "\u5728List\u4E2D\u53D6\u6D88Edit\u6309\u94AE"
    },
    listDelete: {
      "detail": "",
      "description": "\u5728List\u4E2D\u53D6\u6D88Delete\u6309\u94AE"
    },
    listDetail: {
      "detail": "",
      "description": "\u5728List\u4E2D\u53D6\u6D88Detail\u6309\u94AE"
    }
  },
  AnnotationOnSource: {
    Unidirectional: {
      "detail": "",
      "description": "\u5355\u5411\u5173\u7CFB"
    },
    editBySelect: {
      "detail": "",
      "description": "\u901A\u8FC7\u9009\u62E9\u5668\u7F16\u8F91"
    },
    editByFormList: {
      "detail": "",
      "description": "\u901A\u8FC7\u8868\u5355\u5217\u8868\u7F16\u8F91"
    },
    editByList: {
      "detail": "",
      "description": "\u901A\u8FC7\u5217\u8868\u7F16\u8F91"
    },
    editByDescList: {
      "detail": "",
      "description": "\u901A\u8FC7\u8BE6\u60C5\u5217\u8868\u7F16\u8F91"
    },
    editByTable: {
      "detail": "",
      "description": "\u901A\u8FC7\u8868\u683C\u7F16\u8F91"
    },
    countByPrimaryKey: {
      "detail": "",
      "description": "\u6309\u4E3B\u952E\u8FDB\u884C\u7EDF\u8BA1"
    },
    relateByIdEntity: {
      "detail": "",
      "description": "\u4F7F\u7528\u5B9E\u4F53\u540D\u79F0\u548CID\u8FDB\u884C\u5173\u8054"
    },
    editBySelectModal: {
      "detail": "",
      "description": "\u901A\u8FC7\u5F39\u7A97\u9009\u62E9\u7F16\u8F91"
    },
    editBySelectDrawer: {
      "detail": "",
      "description": "\u901A\u8FC7\u62BD\u5C49\u7EC4\u4EF6\u7F16\u8F91"
    },
    editByTableModal: {
      "detail": "",
      "description": "\u901A\u8FC7\u5F39\u7A97\u8868\u683C\u7F16\u8F91"
    },
    editByTableDrawer: {
      "detail": "",
      "description": "\u901A\u8FC7\u62BD\u5C49\u8868\u683C\u7F16\u8F91"
    },
    importData: {
      "detail": "",
      "description": "\u5BFC\u5165\u5173\u7CFB\u6570\u636E"
    },
    editInForm: {
      "detail": "",
      "description": "\u5728\u8868\u5355\u4E2D\u7F16\u8F91"
    },
    editInList: {
      "detail": "",
      "description": "\u5728\u5217\u8868\u4E2D\u7F16\u8F91"
    },
    hideInList: {
      "detail": "",
      "description": "\u5728\u5217\u8868\u4E2D\u4E0D\u663E\u793A"
    },
    detailInList: {
      "detail": "",
      "description": "\u5728\u5217\u8868\u4E2D\u663E\u793A\u8BE6\u60C5"
    }
  },
  AnnotationOnDestination: {
    editInList: {
      "detail": "",
      "description": "\u5728\u5217\u8868\u4E2D\u7F16\u8F91"
    },
    editBySelectModal: {
      "detail": "",
      "description": "\u5728\u5F39\u7A97\u4E2D\u7F16\u8F91"
    }
  },
  FieldConfig: {
    editInList: {
      "detail": "",
      "description": "\u5728\u8868\u683C\u4E2D\u7F16\u8F91"
    },
    hideInList: {
      "detail": "",
      "description": "\u5728\u8868\u683C\u4E2D\u4E0D\u663E\u793A"
    },
    hideInForm: {
      "detail": "",
      "description": "\u5728\u8868\u5355\u4E2D\u4E0D\u663E\u793A"
    },
    searchForm: {
      "detail": "",
      "description": "\u5728\u641C\u7D22\u8868\u5355\u4E2D\u663E\u793A"
    },
    filter: {
      "detail": "",
      "description": "\u652F\u6301\u5217\u8868\u4E2D\u8FC7\u6EE4"
    }
  },
  SkipRestApi: {
    dataExport: {
      "detail": "",
      "description": "\u53D6\u6D88\u5BFC\u51FAAPI\u63A5\u53E3"
    },
    dataImport: {
      "detail": "",
      "description": "\u53D6\u6D88\u5BFC\u5165API\u63A5\u53E3"
    },
    create: {
      "detail": "",
      "description": "\u53D6\u6D88\u65B0\u5EFAAPI\u63A5\u53E3"
    }
  },
  SkipComponent: {
    listPage: {
      "detail": "",
      "description": "\u5FFD\u7565\u524D\u7AEF\u5217\u8868\u9875\u9762"
    },
    editPage: {
      "detail": "",
      "description": "\u5FFD\u7565\u524D\u7AEF\u7F16\u8F91\u9875\u9762"
    },
    detailPage: {
      "detail": "",
      "description": "\u5FFD\u7565\u524D\u7AEF\u8BE6\u60C5\u9875\u9762"
    },
    clientService: {
      "detail": "",
      "description": "\u5FFD\u7565\u524D\u7AEFAPI\u63A5\u53E3"
    },
    clientRoute: {
      "detail": "",
      "description": "\u5FFD\u7565\u524D\u7AEF\u8DEF\u7531"
    },
    domain: {
      "detail": "",
      "description": "\u5FFD\u7565\u540E\u7AEFDomain\u6587\u4EF6"
    },
    mapper: {
      "detail": "",
      "description": "\u5FFD\u7565\u540E\u7AEFDtoMapper\u6587\u4EF6"
    },
    controllerTest: {
      "detail": "",
      "description": "\u5FFD\u7565\u540E\u7AEFResourceIT\u6D4B\u8BD5\u6587\u4EF6"
    },
    serviceClass: {
      "detail": "",
      "description": "\u5FFD\u7565\u540E\u7AEFService\u6587\u4EF6"
    },
    restController: {
      "detail": "",
      "description": "\u5FFD\u7565\u540E\u7AEFRestApi\u6587\u4EF6"
    },
    repository: {
      "detail": "",
      "description": "\u5FFD\u7565\u540E\u7AEFDAO\u6587\u4EF6"
    },
    queryService: {
      "detail": "",
      "description": "\u5FFD\u7565\u540E\u7AEFQueryService\u6587\u4EF6"
    }
  }
};
var fieldTypeDetail = [
  {
    label: {
      label: "String",
      detail: "",
      description: "\u5B57\u7B26\u4E32"
    },
    kind: vscode2.CompletionItemKind.Class
  },
  {
    label: {
      label: "Integer",
      "detail": "",
      "description": "\u6574\u6570"
    },
    kind: vscode2.CompletionItemKind.Class
  },
  {
    label: {
      label: "Long",
      detail: "",
      description: "\u957F\u6574"
    },
    kind: vscode2.CompletionItemKind.Class
  },
  {
    label: {
      label: "BigDecimal",
      "detail": "",
      "description": "\u5927\u6D6E\u70B9\u6570"
    },
    kind: vscode2.CompletionItemKind.Class
  },
  {
    label: {
      label: "Float",
      "detail": "",
      "description": "\u5355\u7CBE\u5EA6"
    },
    kind: vscode2.CompletionItemKind.Class
  },
  {
    label: {
      label: "Double",
      "detail": "",
      "description": "\u53CC\u7CBE\u5EA6"
    },
    kind: vscode2.CompletionItemKind.Class
  },
  {
    label: {
      label: "Boolean",
      "detail": "",
      "description": "\u5E03\u5C14"
    },
    kind: vscode2.CompletionItemKind.Class
  },
  {
    label: {
      label: "LocalDate",
      "detail": "",
      "description": "\u672C\u5730\u5316\u65E5\u671F"
    },
    kind: vscode2.CompletionItemKind.Class
  },
  {
    label: {
      label: "ZonedDateTime",
      "detail": "",
      "description": "\u5E26\u65F6\u533A\u548C\u65F6\u95F4"
    },
    kind: vscode2.CompletionItemKind.Class
  },
  {
    label: {
      label: "Instant",
      "detail": "",
      "description": "\u65F6\u95F4\u6233\u7C7B\u578B"
    },
    kind: vscode2.CompletionItemKind.Class
  },
  {
    label: {
      label: "Duration",
      "detail": "",
      "description": "\u6301\u7EED\u65F6\u95F4"
    },
    kind: vscode2.CompletionItemKind.Class
  },
  {
    label: {
      label: "UUID",
      "detail": "",
      "description": "UUID"
    },
    kind: vscode2.CompletionItemKind.Class
  },
  {
    label: {
      label: "Blob",
      "detail": "",
      "description": "\u4E8C\u8FDB\u5236"
    },
    kind: vscode2.CompletionItemKind.Class
  },
  {
    label: {
      label: "AnyBlob",
      "detail": "",
      "description": "\u4EFB\u610F\u4E8C\u8FDB\u5236"
    },
    kind: vscode2.CompletionItemKind.Class
  },
  {
    label: {
      label: "ImageBlob",
      "detail": "",
      "description": "\u56FE\u7247\u4E8C\u8FDB\u5236"
    },
    kind: vscode2.CompletionItemKind.Class
  },
  {
    label: {
      label: "TextBlob",
      "detail": "",
      "description": "\u957F\u6587\u672C"
    },
    kind: vscode2.CompletionItemKind.Class
  }
];
var annotationData = Object.keys(annotationValueDetail).reduce((acc, key) => {
  acc[key] = Object.keys(annotationValueDetail[key]);
  return acc;
}, {});
function getCompleteItems(errors, jdlObject4) {
  const annotation = vscode2.languages.registerCompletionItemProvider(
    { language: "jdl" },
    {
      provideCompletionItems(document, position) {
        const linePrefix = document.lineAt(position).text.slice(0, position.character);
        const annotationRegex = new RegExp("@(?<annotationName>[a-z|A-Z]+)(\\((?<annotationValue>[a-z|A-Z|\\-]*)?\\)?)?");
        if (annotationRegex.test(linePrefix)) {
          const match = linePrefix.match(annotationRegex);
          const annotationName = match?.groups?.annotationName;
          const annotationValueData = match?.groups?.annotationValue;
          const annotationValues = !annotationValueData ? [] : annotationValueData?.split("-");
          if (annotationName && annotationData[annotationName]) {
            return annotationData[annotationName].filter((value) => !annotationValues?.includes(value)).map((item) => {
              const completionItem = new vscode2.CompletionItem({ label: item, ...annotationValueDetail[annotationName][item] });
              completionItem.kind = vscode2.CompletionItemKind.Text;
              return completionItem;
            });
          }
        }
        return void 0;
      }
    },
    "-",
    "("
  );
  const fieldType = vscode2.languages.registerCompletionItemProvider(
    { language: "jdl" },
    {
      provideCompletionItems(document, position) {
        const linePrefix = document.lineAt(position).text.slice(0, position.character);
        const cutNumber = linePrefix.length - linePrefix.trimEnd().length;
        const beforePosition = new vscode2.Position(position.line, position.character - cutNumber - 1);
        const range = document.getWordRangeAtPosition(beforePosition);
        const word = document.getText(range);
        const cstToken = cstTokens.find((cstToken2) => {
          return cstToken2.image === word && cstToken2.startLine <= range.start.line + 1 && cstToken2.endLine >= range.end.line + 1 && cstToken2.startColumn <= range.start.character + 1 && cstToken2.endColumn === range.end.character;
        });
        if (cstToken) {
          const labels = cstToken.label.split("=>");
          const typeChain = labels.map((label) => label.split(":")[0]).join(".");
          if (typeChain === "entity.field") {
            return fieldTypeDetail;
          }
          return tokenLableComplete(cstToken.label, jdlObject4);
        } else {
          if (errors && errors.length) {
            const error = errors.find((error2) => {
              return error2.name === "MismatchedTokenException" && error2.previousToken?.startLine === beforePosition.line + 1 && error2.previousToken?.endColumn <= beforePosition.character + 1;
            });
            if (error) {
              if (error.context?.ruleStack) {
                const ruleStackStr = error.context?.ruleStack.join("->");
                if (ruleStackStr === ["prog", "entityDeclaration", "entityBody", "fieldDeclaration", "type"].join("->")) {
                  return fieldTypeDetail;
                }
              }
            }
          }
        }
        return void 0;
      }
    },
    " "
  );
  const annotationType = vscode2.languages.registerCompletionItemProvider(
    { language: "jdl" },
    {
      provideCompletionItems(document, position) {
        let beforeLineToken = null;
        let afterLineToken = null;
        let entity = null;
        let entityName = "";
        let fieldName = "";
        let entities3 = jdlObject4.entities || [];
        if (errors?.length > 0) {
          const lineText = document.lineAt(position).text;
          if (lineText.trim() === "@") {
            const offset = document.offsetAt(position);
            const allText = document.getText();
            const replaceByIndex = (str, start, newContent) => {
              const part1 = str.substring(0, start);
              const part2 = str.substring(start + newContent.length);
              return part1 + newContent + part2;
            };
            const okText = replaceByIndex(allText, offset - 1, " ");
            const parseResult = parseJdl(okText);
            entities3 = parseResult.jdlObject?.entities || [];
            if (position.line > 0) {
              beforeLineToken = parseResult.cstTokens.find((token) => token.startLine === position.line);
            }
            if (position.line < document.lineCount - 1) {
              afterLineToken = parseResult.cstTokens.find((token) => token.startLine === position.line + 2);
            }
          }
        } else {
          if (position.line > 0) {
            beforeLineToken = cstTokens.find((token) => token.startLine === position.line);
          }
          if (position.line < document.lineCount - 1) {
            afterLineToken = cstTokens.find((token) => token.startLine === position.line + 2);
          }
        }
        let annotationTypeChain = "";
        let existAnnotations = [];
        if (beforeLineToken) {
          const beforeLabels = beforeLineToken.label.split("=>");
          const beforeTypeChain = beforeLabels.map((label) => label.split(":")[0]).join(".");
          if (beforeTypeChain === "entity.anno") {
            entityName = beforeLabels[0].split(":")[1];
            entity = entities3.find((entity2) => entity2.name === entityName);
            existAnnotations = entity.annotations?.map((annotation2) => annotation2.optionName) || [];
            annotationTypeChain = "entity.anno";
          }
          if (beforeTypeChain === "entity.field.anno") {
            entityName = beforeLabels[0].split(":")[1];
            fieldName = beforeLabels[1].split(":")[1];
            entity = entities3.find((entity2) => entity2.name === entityName);
            const field = entity.body.find((field2) => field2.name === fieldName);
            existAnnotations = field?.annotations?.map((annotation2) => annotation2.optionName) || [];
            annotationTypeChain = "entity.field.anno";
          }
          if (beforeTypeChain === "keyword.entity") {
            entityName = beforeLabels[1].split(":")[1];
            entity = entities3.find((entity2) => entity2.name === entityName);
            annotationTypeChain = "entity.field.anno";
          }
          if (beforeTypeChain === "relationship") {
            annotationTypeChain = "relationship.from.anno";
          }
          if (beforeTypeChain === "relationship.keyword") {
            annotationTypeChain = "relationship.to.anno";
          }
          if (afterLineToken) {
            const afterLineLabels = afterLineToken.label.split("=>");
            const afterLineTypeChain = afterLineLabels.map((label) => label.split(":")[0]).join(".");
            if (beforeTypeChain === "entity.anno") {
              annotationTypeChain = "entity.anno";
              if (["keyword.entity", "entity.anno"].includes(afterLineTypeChain)) {
                annotationTypeChain = "entity.anno";
                if (afterLineTypeChain === "keyword.entity") {
                  entityName = afterLineLabels[1].split(":")[1];
                  entity = entities3.find((entity2) => entity2.name === entityName);
                  existAnnotations = entity.annotations?.map((annotation2) => annotation2.optionName) || [];
                }
                if (afterLineTypeChain === "entity.anno") {
                  entityName = afterLineLabels[0].split(":")[1];
                  entity = entities3.find((entity2) => entity2.name === entityName);
                  existAnnotations = entity.annotations?.map((annotation2) => annotation2.optionName) || [];
                }
              }
            }
            if (["entity.field.anno", "entity.field"].includes(beforeTypeChain)) {
              if (["entity.field.anno", "entity.field"].includes(afterLineTypeChain)) {
                entityName = afterLineLabels[0].split(":")[1];
                fieldName = afterLineLabels[1].split(":")[1];
                entity = entities3.find((entity2) => entity2.name === entityName);
                const field = entity.body.find((field2) => field2.name === fieldName);
                existAnnotations = field?.annotations?.map((annotation2) => annotation2.optionName) || [];
                annotationTypeChain = "entity.field.anno";
              }
            }
            if (["keyword.entity"].includes(beforeTypeChain)) {
              if (["entity.field.anno", "entity.field"].includes(afterLineTypeChain)) {
                entityName = afterLineLabels[0].split(":")[1];
                fieldName = afterLineLabels[1].split(":")[1];
                entity = entities3.find((entity2) => entity2.name === entityName);
                const field = entity.body.find((field2) => field2.name === fieldName);
                existAnnotations = field?.annotations?.map((annotation2) => annotation2.optionName) || [];
                annotationTypeChain = "entity.field.anno";
              }
            }
            if (beforeTypeChain === "relationship") {
              if (afterLineTypeChain === "relationship.from") {
                annotationTypeChain = "relationship.from.anno";
              }
            }
            if (beforeTypeChain === "relationship.keyword") {
              if (afterLineTypeChain === "relationship.to") {
                annotationTypeChain = "relationship.to.anno";
              }
            }
          }
          if (annotationTypeChain) {
            const annotationObject = (0, import_lodash3.get)(hoverData, annotationTypeChain, {});
            const completeItems = [];
            Object.keys(annotationObject).filter((key) => !existAnnotations.includes(key)).forEach((key) => {
              completeItems.push(annotationObject[key].completeItem);
            });
            return completeItems;
          }
        } else if (afterLineToken) {
          const afterLineLabels = afterLineToken.label.split("=>");
          const afterLineTypeChain = afterLineLabels.map((label) => label.split(":")[0]).join(".");
          if (["keyword.entity", "entity.anno"].includes(afterLineTypeChain)) {
            annotationTypeChain = "entity.anno";
            if (afterLineTypeChain === "keyword.entity") {
              entityName = afterLineLabels[1].split(":")[1];
              entity = entities3.find((entity2) => entity2.name === entityName);
              existAnnotations = entity.annotations?.map((annotation2) => annotation2.optionName) || [];
            }
            if (afterLineTypeChain === "entity.anno") {
              entityName = afterLineLabels[0].split(":")[1];
              entity = entities3.find((entity2) => entity2.name === entityName);
              existAnnotations = entity.annotations?.map((annotation2) => annotation2.optionName) || [];
            }
            if (annotationTypeChain) {
              const annotationObject = (0, import_lodash3.get)(hoverData, annotationTypeChain, {});
              const completeItems = [];
              Object.keys(annotationObject).filter((key) => !existAnnotations.includes(key)).forEach((key) => {
                completeItems.push(annotationObject[key].completeItem);
              });
              return completeItems;
            }
          }
          if (["entity.field.anno", "entity.field"].includes(afterLineTypeChain)) {
            entityName = afterLineLabels[0].split(":")[1];
            fieldName = afterLineLabels[1].split(":")[1];
            entity = entities3.find((entity2) => entity2.name === entityName);
            const field = entity.body.find((field2) => field2.name === fieldName);
            existAnnotations = field?.annotations?.map((annotation2) => annotation2.optionName) || [];
            annotationTypeChain = "entity.field.anno";
            if (annotationTypeChain) {
              const annotationObject = (0, import_lodash3.get)(hoverData, annotationTypeChain, {});
              const completeItems = [];
              Object.keys(annotationObject).filter((key) => !existAnnotations.includes(key)).forEach((key) => {
                completeItems.push(annotationObject[key].completeItem);
              });
              return completeItems;
            }
          }
        }
        return void 0;
      }
    },
    "@"
  );
  return [annotation, fieldType, annotationType];
}

// src/extension.ts
var import_lodash4 = __toESM(require_lodash());
var jdl2;
async function getJdl2() {
  if (!jdl2) {
    jdl2 = await Promise.resolve().then(() => (init_jdl3(), jdl_exports));
  }
}
getJdl2();
var jdlKeywordTokenTypes = {
  ENTITY: "JDL\u5B9A\u4E49\u5B9E\u4F53\u5173\u952E\u5B57",
  ENUM: "JDL\u5B9A\u4E49\u679A\u4E3E\u5173\u952E\u5B57",
  RELATIONSHIP: "JDL\u5B9A\u4E49\u5173\u8054\u5173\u7CFB\u5173\u952E\u5B57",
  APPLICATION: "JDL\u5B9A\u4E49\u5E94\u7528\u5173\u952E\u5B57",
  DEPLOYMENT: "JDL\u5B9A\u4E49\u90E8\u7F72\u5173\u952E\u5B57",
  WITH: "JDL\u5173\u952E\u5B57",
  SERVICE: "JDL\u5B9A\u4E49Service\u5173\u952E\u5B57"
};
var cstTokens = [];
function activate(context) {
  let jdlObject4 = {};
  let jdlCst = {};
  const errors = [];
  context.subscriptions.push(
    vscode3.languages.registerHoverProvider("jdl", {
      provideHover(document, position, token) {
        const line = position.line + 1;
        const character = position.character + 1;
        if (Object.keys(jdlCst).length >= 0) {
          const token2 = jdlCst.tokens.find((token3) => {
            return token3.startLine <= line + 1 && token3.endLine >= line && token3.startColumn <= character && token3.endColumn >= character;
          });
          if (token2?.tokenType && Object.keys(jdlKeywordTokenTypes).includes(token2.tokenType.name)) {
            return {
              contents: [jdlKeywordTokenTypes[token2.tokenType.name]]
            };
          }
        }
        if (document.getText(new vscode3.Range(new vscode3.Position(line, character - 1), new vscode3.Position(line, character))) === " ") {
          return {
            contents: []
          };
        }
        const word = document.getText(document.getWordRangeAtPosition(position));
        const cstToken = cstTokens.find((cstToken2) => {
          return cstToken2.image === word && cstToken2.startLine <= line && cstToken2.endLine >= line && cstToken2.startColumn <= character && cstToken2.endColumn >= character;
        });
        if (cstToken) {
          return {
            contents: tokenLableHover(cstToken.label, jdlObject4)
          };
        }
        return {
          contents: []
        };
      }
    })
  );
  function updateDiagnostics(document, collection) {
    if (document) {
      try {
        errors.length = 0;
        const lexResult = jdl2.getLexResult(document.getText());
        jdlCst = lexResult;
        try {
          if (!lexResult.errors || lexResult.errors?.length === 0) {
            const parseResult = jdl2.grammarParse(document.getText());
            if (parseResult) {
              jdlObject4 = parseResult;
            }
          } else {
            errors.push(...lexResult.errors || []);
          }
        } catch (error) {
          (0, import_console3.log)("error:", error);
        }
        if (jdlCst.children) {
          cstTokens.length = 0;
          Object.keys(jdlCst.children).forEach((key) => {
            if (key === "binaryOptionDeclaration") {
              const binaryOptions = jdlCst.children.binaryOptionDeclaration;
              binaryOptions.forEach((binaryOption) => {
                if (binaryOption.children?.BINARY_OPTION) {
                  const binaryOptionLabel = "binaryOption:" + binaryOption.children.BINARY_OPTION[0].image;
                  const binaryOptionData = { ...binaryOption.children.BINARY_OPTION[0], label: binaryOptionLabel };
                  cstTokens.push(binaryOptionData);
                  binaryOption.children?.entityList?.forEach((entity) => {
                    if (entity.children) {
                      if (entity.children.WITH?.length > 0) {
                        const binaryOptionWithLabel = "=>with:" + entity.children.WITH[0].image;
                        const binaryOptionWithData = { ...entity.children.WITH[0], label: binaryOptionWithLabel };
                        cstTokens.push(binaryOptionWithData);
                      }
                      entity.children?.NAME?.forEach((name) => {
                        const binaryOptionEntityNameLabel = binaryOptionLabel + "=>entity:" + name.image;
                        const binaryOptionEntityNameData = { ...name, label: binaryOptionEntityNameLabel };
                        cstTokens.push(binaryOptionEntityNameData);
                      });
                      if (entity.children?.method[0]) {
                        const binaryOptionMethodLabel = binaryOptionLabel + "=>method:" + entity.children.method[0].image;
                        const binaryOptionMethodData = { ...entity.children.method[0], label: binaryOptionMethodLabel };
                        cstTokens.push(binaryOptionMethodData);
                      }
                    }
                  });
                }
              });
            }
            if (key === "entityDeclaration") {
              const entities3 = jdlCst.children.entityDeclaration;
              (0, import_console3.log)("entities::", entities3);
              entities3.forEach((entity) => {
                const label = "entity:" + entity.children.NAME[0].image;
                entity.children?.annotationDeclaration?.forEach((annotation) => {
                  const annoLabel = label + "=>anno:" + (0, import_lodash4.upperFirst)(annotation.children.option[0].image);
                  const data = { ...annotation.children.option[0], label: annoLabel };
                  cstTokens.push(data);
                  if (annotation.children.value) {
                    const valueLabel = annoLabel + "=>value:" + annotation.children.value[0].image;
                    const valueData = { ...annotation.children.value[0], label: valueLabel };
                    cstTokens.push(valueData);
                  }
                });
                entity.children?.entityBody?.forEach((entityBody) => {
                  entityBody?.children?.fieldDeclaration?.forEach((field) => {
                    const fieldLabel = label + "=>field:" + field.children.NAME[0].image;
                    const fieldData = { ...field.children.NAME[0], label: fieldLabel };
                    cstTokens.push(fieldData);
                    const fieldTypeLabel = fieldLabel + "=>type:" + field.children.type[0].children.NAME[0].image;
                    const fieldTypeData = { ...field.children.type[0].children.NAME[0], label: fieldTypeLabel };
                    cstTokens.push(fieldTypeData);
                    field.children?.annotationDeclaration?.forEach((annotation) => {
                      const annoLabel = fieldLabel + "=>anno:" + (0, import_lodash4.upperFirst)(annotation.children.option[0].image);
                      const data = { ...annotation.children.option[0], label: annoLabel };
                      cstTokens.push(data);
                      if (annotation.children.value) {
                        const valueLabel = annoLabel + "=>value:" + annotation.children.value[0].image;
                        const valueData = { ...annotation.children.value[0], label: valueLabel };
                        cstTokens.push(valueData);
                      }
                    });
                    field.children?.validation?.forEach((validation) => {
                      if (validation.children?.REQUIRED) {
                        const validationLabel = fieldLabel + "=>validation:" + validation.children?.REQUIRED[0].image;
                        const validationData = { ...validation.children?.REQUIRED[0], label: validationLabel };
                        cstTokens.push(validationData);
                      }
                      if (validation.children?.UNIQUE) {
                        const validationLabel = fieldLabel + "=>validation:" + validation.children?.UNIQUE[0].image;
                        const validationData = { ...validation.children?.UNIQUE[0], label: validationLabel };
                        cstTokens.push(validationData);
                      }
                      if (validation.children?.pattern) {
                        const validationLabel = fieldLabel + "=>validation:" + validation.children?.pattern[0].children.PATTERN[0].image;
                        const validationData = { ...validation.children?.pattern[0].children.PATTERN[0], label: validationLabel };
                        cstTokens.push(validationData);
                        const validationValueLabel = validationLabel + "=>value:" + validation.children?.pattern[0].children?.REGEX[0].image;
                        const validationValueData = { ...validation.children?.pattern[0].children?.REGEX[0], label: validationValueLabel };
                        cstTokens.push(validationValueData);
                      }
                      if (validation.children?.minMaxValidation) {
                        const validationLabel = fieldLabel + "=>validation:" + validation.children?.minMaxValidation[0].children?.MIN_MAX_KEYWORD[0].image;
                        const validationData = { ...validation.children?.minMaxValidation[0].children?.MIN_MAX_KEYWORD[0], label: validationLabel };
                        cstTokens.push(validationData);
                        const validationValueLabel = validationLabel + "=>value:" + validation.children?.minMaxValidation[0].children?.INTEGER[0].image;
                        const validationValueData = { ...validation.children?.minMaxValidation[0].children?.INTEGER[0], label: validationValueLabel };
                        cstTokens.push(validationValueData);
                      }
                    });
                  });
                });
              });
            }
            if (key === "enumDeclaration") {
              const enums = jdlCst.children.enumDeclaration;
              enums?.forEach((enumItem) => {
                if (enumItem.children) {
                  const enumName = enumItem.children.NAME[0].image;
                  const enumLabel = "enum:" + enumName;
                  const enumData = { ...enumItem.children.NAME[0], label: enumLabel };
                  cstTokens.push(enumData);
                  enumItem.children.enumPropList?.forEach((enumProp) => {
                    enumProp.children?.enumProp?.forEach((prop) => {
                      const propLabel = enumLabel + "=>prop:" + prop.children.enumPropKey[0].image;
                      const propData = { ...prop.children.enumPropKey[0], label: propLabel };
                      cstTokens.push(propData);
                      if (prop.children?.enumPropValue) {
                        const propValueLabel = propLabel + "=>value:" + prop.children.enumPropValue[0].image;
                        const propValueData = { ...prop.children.enumPropValue[0], label: propValueLabel };
                        cstTokens.push(propValueData);
                      }
                      if (prop.children?.enumPropValueWithQuotes) {
                        const propValueLabel = propLabel + "=>value:" + prop.children.enumPropValueWithQuotes[0].image;
                        const propValueData = { ...prop.children.enumPropValueWithQuotes[0], label: propValueLabel };
                        cstTokens.push(propValueData);
                      }
                    });
                  });
                }
              });
            }
            if (key === "relationDeclaration") {
              const relationships = jdlCst.children.relationDeclaration;
              relationships.forEach((relationship) => {
                if (relationship.children?.relationshipType && relationship.children?.relationshipType[0]?.children?.RELATIONSHIP_TYPE) {
                  const relationshipLabel = "relationship:" + relationship.children.relationshipType[0].children.RELATIONSHIP_TYPE[0].image;
                  const relationshipData = { ...relationship.children.relationshipType[0].children.RELATIONSHIP_TYPE[0], label: relationshipLabel };
                  cstTokens.push(relationshipData);
                  relationship.children?.relationshipBody?.forEach((relationshipBody) => {
                    if (relationshipBody.children && relationshipBody.children.from[0]?.children?.NAME && relationshipBody.children.to[0]?.children?.NAME) {
                      const fromLabelOnly = "from:" + relationshipBody.children.from[0].children.NAME[0].image;
                      const fromLabel = relationshipLabel + "=>" + fromLabelOnly;
                      const fromData = { ...relationshipBody.children.from[0].children.NAME[0], label: fromLabel };
                      cstTokens.push(fromData);
                      const toLabelOnly = "to:" + relationshipBody.children.to[0].children.NAME[0].image;
                      const toLabel = relationshipLabel + "=>" + toLabelOnly;
                      const toData = { ...relationshipBody.children.to[0].children.NAME[0], label: toLabel };
                      cstTokens.push(toData);
                      if (relationshipBody.children.from[0]?.children?.injectedField) {
                        const fromInjectedFieldLabel = fromLabel + "=>" + toLabelOnly + "=>injectedField:" + relationshipBody.children.from[0].children.injectedField[0].image;
                        const fromInjectedFieldData = { ...relationshipBody.children.from[0].children.injectedField[0], label: fromInjectedFieldLabel };
                        cstTokens.push(fromInjectedFieldData);
                      }
                      if (relationshipBody.children.from[0]?.children?.injectedFieldParam) {
                        const fromInjectedFieldParamLabel = fromLabel + "=>" + toLabelOnly + "=>injectedFieldParam:" + relationshipBody.children.from[0].children.injectedFieldParam[0].image;
                        const fromInjectedFieldParamData = { ...relationshipBody.children.from[0].children.injectedFieldParam[0], label: fromInjectedFieldParamLabel };
                        cstTokens.push(fromInjectedFieldParamData);
                      }
                      if (relationshipBody.children.to[0]?.children?.injectedField) {
                        const toInjectedFieldLabel = toLabel + "=>" + fromLabelOnly + "=>injectedField:" + relationshipBody.children.to[0].children.injectedField[0].image;
                        const toInjectedFieldData = { ...relationshipBody.children.to[0].children.injectedField[0], label: toInjectedFieldLabel };
                        cstTokens.push(toInjectedFieldData);
                      }
                      if (relationshipBody.children.to[0]?.children?.injectedFieldParam) {
                        const toInjectedFieldParamLabel = toLabel + "=>" + fromLabelOnly + "=>injectedFieldParam:" + relationshipBody.children.to[0].children.injectedFieldParam[0].image;
                        const toInjectedFieldParamData = { ...relationshipBody.children.to[0].children.injectedFieldParam[0], label: toInjectedFieldParamLabel };
                        cstTokens.push(toInjectedFieldParamData);
                      }
                    }
                  });
                }
              });
            }
            if (key === "unaryOptionDeclaration") {
              const unaryOptions = jdlCst.children.unaryOptionDeclaration;
              unaryOptions.forEach((unaryOption) => {
                if (unaryOption.children?.UNARY_OPTION) {
                  const unaryOptionLabel = "unaryOption:" + unaryOption.children.UNARY_OPTION[0].image;
                  const unaryOptionData = { ...unaryOption.children.UNARY_OPTION[0], label: unaryOptionLabel };
                  cstTokens.push(unaryOptionData);
                  const defName = unaryOption.children.UNARY_OPTION[0].image + "Def";
                  if (unaryOption.children[defName]) {
                    const unaryOptionDef = unaryOption.children[defName][0];
                    unaryOptionDef?.NAME?.forEach((name) => {
                      const unaryOptionNameLabel = unaryOptionLabel + "=>name:" + name.image;
                      const unaryOptionNameData = { ...name, label: unaryOptionNameLabel };
                      cstTokens.push(unaryOptionNameData);
                    });
                  }
                }
              });
            }
          });
        }
        if (lexResult.errors?.length > 0) {
          const errors2 = lexResult.errors.map((error) => {
            const diagnostic = {
              code: "",
              message: error.message,
              range: new vscode3.Range(new vscode3.Position(error.token.startLine - 1, error.token.startColumn - 1), new vscode3.Position(error.token.endLine - 1, error.token.endColumn - 1)),
              severity: vscode3.DiagnosticSeverity.Error,
              source: ""
            };
            return diagnostic;
          });
          collection.set(document.uri, errors2);
        } else {
          collection.clear();
        }
      } catch (error) {
        (0, import_console3.log)("error:", error);
      }
    } else {
      collection.clear();
    }
  }
  const diagnosticCollection = vscode3.languages.createDiagnosticCollection("jdl");
  context.subscriptions.push(
    vscode3.workspace.onDidChangeTextDocument((e) => updateDiagnostics(e.document, diagnosticCollection))
  );
  context.subscriptions.push(
    vscode3.workspace.onDidCloseTextDocument((doc) => diagnosticCollection.delete(doc.uri))
  );
  if (vscode3.window.activeTextEditor) {
    updateDiagnostics(vscode3.window.activeTextEditor.document, diagnosticCollection);
  }
  context.subscriptions.push(vscode3.window.onDidChangeActiveTextEditor((editor) => {
    if (editor) {
      updateDiagnostics(editor.document, diagnosticCollection);
    }
  }));
  context.subscriptions.push(...getCompleteItems(errors, jdlObject4));
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate,
  cstTokens
});
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=extension.js.map
